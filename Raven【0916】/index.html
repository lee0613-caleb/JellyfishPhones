<!DOCTYPE html>
<!-- saved from url=(0035)https://raven7-7.github.io/Lemuria/ -->
<html lang="zh-CN" style="--moments-cover-image: url(https://placehold.co/375x192/333/fff?text=Cover); --scenario-bg-image: none;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>RavenPhone</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://tc-new.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250825/5nvZ/1280X1280/3d8950a849829447f24466a851153f8f.jpg/webp">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="./RavenPhone【0916自存】_files/saved_resource"></script>
    <script src="./RavenPhone【0916自存】_files/jquery-3.7.1.min.js.下载"></script>
    <link rel="stylesheet" href="./RavenPhone【0916自存】_files/all.min.css">
    <link href="./RavenPhone【0916自存】_files/remixicon.css" rel="stylesheet">
    <link href="./RavenPhone【0916自存】_files/css2" rel="stylesheet">
    <link href="./RavenPhone【0916自存】_files/css2(1)" rel="stylesheet">
    

    
    <!-- 邀請函專用字體 -->
    <link href="./RavenPhone【0916自存】_files/css2(2)" rel="stylesheet">
    <link href="./RavenPhone【0916自存】_files/css2(3)" rel="stylesheet">
    <link href="./RavenPhone【0916自存】_files/css2(4)" rel="stylesheet">
    <!-- 星空图缩放库 -->
    <script src="./RavenPhone【0916自存】_files/panzoom.min.js.下载"></script>
    <style>
        /* ====== 【【V6.1 黑底粉字美观版】】爱之迷宫主题样式 ====== */
        #love-map-board {
            display: grid;
            grid-template-columns: repeat(6, 1fr); /* 【【核心修改】】从4列变为6列 */
            grid-template-rows: repeat(9, 1fr);   /* 【【核心修改】】减少行数以适应屏幕 */
            gap: 4px; /* 缩小格子间距 */
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            position: relative;
            overflow: auto; /* 【【V8.0 新增】】当内容超出时显示滚动条 */
            /* 美化滚动条样式 */
            scrollbar-width: thin;
            scrollbar-color: rgba(244, 114, 182, 0.6) rgba(0, 0, 0, 0.3);
        }

        /* 【【V8.0 新增】】Webkit 浏览器滚动条样式 */
        #love-map-board::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        #love-map-board::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        #love-map-board::-webkit-scrollbar-thumb {
            background: rgba(244, 114, 182, 0.6);
            border-radius: 4px;
        }
        
        #love-map-board::-webkit-scrollbar-thumb:hover {
            background: rgba(244, 114, 182, 0.8);
        }

        .map-cell {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(244, 114, 182, 0.4);
            border-radius: 8px; /* 边角更柔和 */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 9px; /* 调整字体大小以适应更小的格子 */
            line-height: 1.2;
            padding: 1px;
            box-sizing: border-box;
            color: #F9A8D4;
            backdrop-filter: blur(2px);
            transition: all 0.3s ease;
            white-space: pre-wrap;
            box-shadow: inset 0 0 8px rgba(244, 114, 182, 0.3);
            overflow: hidden; /* 防止文字溢出 */
        }

        .map-cell.start-point, .map-cell.end-point {
            background: #F472B6;
            color: #000000;
            font-weight: bold;
            font-size: 10px; /* 【【V8.3 修复】】调小终点文字大小，避免显示过大 */
            box-shadow: 0 0 15px #F472B6, inset 0 0 10px rgba(0,0,0,0.3);
        }

        .map-piece {
            position: absolute; /* 保持绝对定位以实现平滑移动 */
            width: 22px;   /* 棋子尺寸微调 */
            height: 22px;
            border-radius: 50%;
            transition: all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .user-piece { background-color: #F472B6; border: 2px solid #000000; box-shadow: 0 0 12px #F472B6, 0 0 20px #F472B6; color: #000000; }
        .ai-piece { background-color: #EC4899; border: 2px solid #000000; box-shadow: 0 0 12px #EC4899, 0 0 20px #EC4899; color: #000000; }

        /* 骰子动画 (保持不变) */
        @keyframes roll {
            0% { transform: rotate(0deg) scale(1); box-shadow: 0 0 10px #F472B6; }
            50% { transform: rotate(180deg) scale(1.2); box-shadow: 0 0 25px #F472B6; }
            100% { transform: rotate(360deg) scale(1); box-shadow: 0 0 10px #F472B6; }
        }
        .dice-rolling { animation: roll 0.6s ease-in-out; }

        /* ====== 【【新增】】HTML内容防溢出安全网 ====== */
        .html-content-bubble > * {
            /* 核心规则：让HTML内容的最大宽度不超过其父容器（也就是我们的透明气泡） */
            max-width: 100% !important;
            /* 确保元素的边框和内边距被包含在其总宽度内，这是防止溢出的关键 */
            box-sizing: border-box !important;
        }

        .html-content-bubble img {
            /* 专门为图片设置，防止图片被拉伸变形 */
            max-width: 100% !important;
            height: auto !important;
            display: block; /* 移除图片下方的多余空白 */
        }

        /* --- V13.0 头像结构性终极修正 --- */
        .avatar-frame {
            /* 这是外层的"圆形相框" */
            width: 2.5rem; /* 40px */
            height: 2.5rem; /* 40px */
            border-radius: 50%;
            overflow: hidden; /* 这是最重要的属性，用于"裁剪"照片边角 */
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #4b5563; /* 图片加载失败时的底色 */
            flex-shrink: 0; /* 防止被挤压变形 */
            border: 1px solid rgba(255, 255, 255, 0.2); /* 增加一点边框质感 */
        }

        .avatar-frame img {
            /* 这是里面的"照片" */
            width: 100%;
            height: 100%;
            object-fit: cover; /* 这一行保证图片能填满相框且不变形 */
        }

        .avatar-frame .perch-avatar {
            /* 当perch-avatar在avatar-frame内部时，移除margin避免偏移 */
            margin-right: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }

        /* CSS变量定义 */
        :root {
            --moments-cover-image: url('https://placehold.co/375x192/333/fff?text=Cover');
            --moments-avatar-image: url('https://placehold.co/128x128/777/FFF?text=Me');
        }
        
        /* 第一层：html, body 作为稳定的根基 */
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* 彻底禁止最外层滚动 */
            position: relative; /* 使用 relative 作为定位的根 */
            margin: 0;
            padding: 0;
        }
        
        /* 全屏激活时的额外滚动控制 */
        .fullscreen-active html,
        .fullscreen-active body {
            overflow: hidden !important;
            position: relative !important;
            -webkit-overflow-scrolling: auto;
        }

        /* 新增：长按删除的震动动画 */
        @keyframes shake {
          0%, 100% { transform: translateX(0); }
          10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
          20%, 40%, 60%, 80% { transform: translateX(2px); }
        }

        .ticket-wrapper.deleting {
          animation: shake 0.5s ease-in-out;
        }



        /* 修复：防止 iOS 输入框聚焦时页面自动放大 */
        #chat-input:focus {
            font-size: 16px !important;
        }

        /* ====== 时间胶囊小组件 V1.2 (布局修正版) ====== */
        .time-capsule-widget {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            height: 52px; /* 增加高度让胶囊更饱满 */
            padding: 0 1rem;
            border-radius: 9999px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .time-capsule-widget:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .dark-mode .time-capsule-widget {
            background: rgba(80, 80, 80, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .light-mode .time-capsule-widget {
            background: rgba(229, 231, 235, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .capsule-text-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            text-align: center;
        }

        .capsule-text {
            font-family: 'Playfair Display', 'Georgia', 'Times New Roman', 'Baskerville', 'Palatino', serif;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
            line-height: 1;
            font-style: italic;
        }

        .capsule-subtitle {
            font-family: 'Cormorant', 'Cormorant Garamond', 'EB Garamond', 'Garamond', serif;
            font-size: 0.45rem;
            font-weight: 300;
            letter-spacing: 0.15em;
            opacity: 0.7;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.2);
            font-style: normal;
            text-transform: none;
            color: #d1d5db;
            line-height: 1.2;
            text-align: left;
            margin-left: -1.4rem;
            position: relative;
            left: 0rem;
        }

        .dark-mode .capsule-text { color: #f0f0f0; }
        .dark-mode .capsule-subtitle { color: #d1d5db; }
        .light-mode .capsule-text { color: #1f2937; text-shadow: 0 0 5px rgba(0, 0, 0, 0.2); }
        .light-mode .capsule-subtitle { color: #6b7280; }

        /* 新增：胶囊图片容器样式 */
        .capsule-image-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .capsule-image-container:hover {
            transform: scale(1.05);
        }

        .capsule-icon {
            width: 40px;
            height: 40px;
            opacity: 0.8;
            transition: all 0.3s ease;
            border-radius: 50%;
            object-fit: cover;
        }

        .capsule-image-container:hover .capsule-icon {
            opacity: 1;
            transform: rotate(5deg);
        }
        






        /* ======================================================== */
        /* ====== 交互式机票邀请函 V5.0 (横版下方展开) ====== */
        /* ======================================================== */

        /* 1. 整体容器 */
        .ticket-wrapper {
            position: relative;
            width: 260px;
            height: 150px;
            cursor: pointer;
            margin: 2rem auto; /* 居中显示 */
        }

        /* 2. 票夹 (Sleeve) */
        .sleeve {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 110px;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            z-index: 10;
            transition: transform 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.5rem;
        }
        .sleeve-content .main-title {
            font-family: 'Noto Serif SC', serif;
            font-weight: 700;
            font-size: 1.1rem; /* 已缩小 */
            letter-spacing: 0.1em;
            color: #dc2626;
            text-shadow: 0 0 8px rgba(220, 38, 38, 0.3);
        }
        .sleeve-content .subtitle {
            font-family: 'Source Code Pro', monospace;
            font-size: 0.45rem;
            color: rgba(255,255,255,0.4);
            letter-spacing: 0.1em;
            margin-top: 0.3rem;
            text-transform: uppercase;
        }

        /* 3. 机票 (Ticket) */
        .ticket {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 240px;
            height: 130px;
            background-color: #fdfbf6;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: row;
            z-index: 5;
            transition: transform 0.5s ease-out;
        }

        /* 4. 机票主区域和票根 */
        .ticket-main {
            flex-grow: 1;
            padding: 0.8rem 1rem;
            display: flex;
            flex-direction: column;
            border-right: 2px dashed #c9c1b3;
        }
        .ticket-stub {
            flex-shrink: 0;
            width: 50px; /* 已缩小 */
            background-color: #e9e5de;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Source Code Pro', monospace;
            font-weight: 600;
            color: #991B1B;
            font-size: 0.7rem;
            letter-spacing: 0.1em;
            border-radius: 0 8px 8px 0;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        /* 5. 机票内部内容样式 */
        .ticket .info-header {
            display: flex;
            justify-content: space-between;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.5rem;
            color: #b0a696;
            text-transform: uppercase;
        }
        .ticket .event-title {
            font-family: 'Noto Serif SC', serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: #991B1B;
            text-align: left;
            line-height: 1.3;
            margin: 0.5rem 0;
        }
        .ticket .event-details {
            display: flex;
            gap: 1rem;
            font-family: 'Source Code Pro', monospace;
            color: #991B1B;
            margin-top: auto;
        }
        .ticket .detail-item span {
            display: block;
            font-size: 0.5rem;
            color: #b0a696;
            margin-bottom: 0.1rem;
            text-transform: uppercase;
        }
        .ticket .detail-item strong {
            font-size: 0.7rem;
            font-weight: 600;
            white-space: nowrap;
        }

        /* 6. 动画触发样式 (通过JS添加 .open 类) */
        .ticket-wrapper.open .sleeve {
            transform: translateY(40px); /* 票夹向下滑动，距离更近 */
        }
        .ticket-wrapper.open .ticket {
            transform: translate(-50%, -40px); /* 机票向上滑动，距离更近 */
        }

        /* 基础字体样式 */
        body {
            font-family: 'SF Pro Display', 'SF Pro Text', 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* 防止意外滚动 */
        }

        /* 字体大小调整 */
        #phone-screen {
            /* V36.0 新增：定义一个CSS变量用于自定义字体 */
            --custom-font: 'SF Pro Display', 'SF Pro Text', 'Inter', sans-serif;

            font-size: 15px; /* 中 (默认) */
            transition: font-size 0.2s ease-in-out;
            /* V36.0 修改：使用变量来设置字体 */
            font-family: var(--custom-font);
            flex: 1;
            border-radius: 2.5rem; /* 恢复圆角 */
            overflow: hidden;
            position: relative;
            /* 移除 padding-top 和 padding-bottom 的安全区域设置 */
        }
        #phone-screen.text-size-small {
            font-size: 13.5px; /* 小 */
        }
        #phone-screen.text-size-large {
            font-size: 16.5px; /* 大 */
        }
        
        /* 第二层：.phone-frame 变成绝对定位的"屏幕画框" */
        .phone-frame {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            
            /* 在桌面端预览时保持原样 */
            max-width: 375px;
            max-height: 720px;
            margin: auto; /* 让其在桌面端居中 */
            border-radius: 3rem;
            box-shadow: 0 1rem 3rem rgba(0,0,0,0.5);
            padding: 0.5rem; /* p-2 */
            
            display: flex; /* 保持flex布局 */
            flex-direction: column; /* 保持纵向排列 */
            overflow: hidden; /* 这一层也禁止溢出 */
            transition: all 0.3s ease-in-out; /* 添加平滑过渡效果 */
        }
        
        .dark-mode .phone-frame, .light-mode .phone-frame {
            background-color: transparent; /* 背景设为透明，由body控制 */
        }
        
        /* 應用程式圖示互動效果 */
        .app-icon {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, width 0.3s, height 0.3s; /* 添加width和height的过渡效果 */
            background-size: cover;
            background-position: center;
            width: 4rem;  /* 默认手机框尺寸 (等于 w-16) */
            height: 4rem; /* 默认手机框尺寸 (等于 w-16) */
        }
        .app-icon:hover {
            transform: scale(1.05);
        }
        .app-icon:active {
            transform: scale(0.95);
            box-shadow: none;
        }

        .app-icon-glass {
            background: rgba(55, 65, 81, 0.5); /* bg-gray-600 with 50% opacity */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* 全屏模式下，图标变大 */
        .fullscreen-active .app-icon {
            width: 5rem;  /* 全屏尺寸 (等于 w-20) */
            height: 5rem; /* 全屏尺寸 (等于 w-20) */
        }
        
        /* --- 新增：背景图片动态切换的核心样式 --- */
        
        /* 默认手机框模式下，背景图是绝对定位，跟随phone-screen */
        #home-wallpaper {
            position: absolute;
            inset: 0;    /* 【核心修复】让其四边紧贴父容器 */
            width: 100%; /* 【核心修复】确保宽度为100% */
            height: 100%;/* 【核心修复】确保高度为100% */
            z-index: 0;
        }
        
        /* 全屏模式下，背景图变为绝对定位，铺满整个 phone-frame */
        .fullscreen-active #home-wallpaper {
            position: absolute; /* 修改：相对于 .phone-frame 定位 */
            inset: 0;           /* 新增：使用 inset: 0 替代 top/bottom/left/right: 0，让它填满 .phone-frame */
            width: 100%;        /* 确保宽高 */
            height: 100%;
            z-index: 0;         /* 修改：作为 .phone-frame 内的最底层，而不是整个页面的最底层 */
        }
        

        
        /* 訊息提示框樣式 */
        .message-box {
            position: absolute; /* 相對於父容器phone-screen定位 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1rem 2rem;
            border-radius: 1rem;
            text-align: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 11000; /* Ensure it's above everything */
        }
        .message-box.show {
            opacity: 1;
            visibility: visible;
        }
        
        /* 淡入動畫 */
        .animate-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .hidden {
            display: none;
        }
        
        /* 黑膠唱片旋轉動畫 */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .record-spin {
            animation: spin 12s linear infinite;
        }
        /* 接收按钮动画 - 极简优雅版 */
        /* 邮件发送图标闪烁动画 - 保持图标不变，只改变显示效果 */
        @keyframes mail-send-flash {
            0% { opacity: 1; filter: brightness(1); }
            25% { opacity: 0.6; filter: brightness(0.8); }
            50% { opacity: 1; filter: brightness(1.2); }
            75% { opacity: 0.6; filter: brightness(0.8); }
            100% { opacity: 1; filter: brightness(1); }
        }
        
        .spinning {
            animation: mail-send-flash 1.2s ease-in-out infinite;
        }
        
        /* --- 未读消息红点样式 --- */
        .wechat-list-item .avatar {
            position: relative;
        }

        .unread-badge {
            position: absolute;
            top: 0px;
            right: 0px;
            background-color: #fa3e3e;
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            border: 1.5px solid rgba(255, 255, 255, 0.9); /* 边框更细，且略带透明 */
        }
        
        .dark-mode .unread-badge {
            border-color: rgba(26, 26, 26, 0.9); /* 深色模式下，使用略带透明的深色边框 */
        }
        
        /* 接收按钮悬停效果 */
        #receive-chat-button {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #receive-chat-button:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        #receive-chat-button:active {
            transform: scale(0.98);
        }
        
        /* 隱藏文件輸入框 */
        #music-upload-input, #background-input, #vinyl-input, #widget-image-input, #photo-widget-input, #wallpaper-input, #character-avatar-input, #user-avatar-input, #chat-bg-input, #import-data-input, #image-upload-input, #sticker-upload-input, #user-video-image-input, #my-video-image-input, #moment-image-input {
            display: none;
        }
        
        .music-block-background {
            background-image: url('https://placehold.co/400x150/1a1a1a/ffffff?text=UPLOAD+BACKGROUND');
            background-size: cover;
            background-position: center;
            cursor: pointer;
        }
        
        .vinyl-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            border-radius: 50%;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .vinyl-image-container {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 67%;
            height: 67%;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            background-image: url('https://placehold.co/100x100/000000/ffffff?text=UPLOAD');
            background-size: cover;
            background-position: center;
            cursor: pointer;
        }
        
        .vinyl-center {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 1rem;
            height: 1rem;
            background-color: #f3f4f6;
            border-radius: 50%;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9000;
            display: none;
            justify-content: center;
            align-items: center;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible {
            display: flex;
        }
        .modal-content {
            width: 80%;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s;
        }
        
        /* 日夜间模式下的模态框背景 */
        .dark-mode .modal-content {
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .light-mode .modal-content {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        /* 日间模式下删除确认对话框的文字颜色 */
        .light-mode #confirm-delete-modal .modal-content {
            color: #1f2937;
        }
        
        .light-mode #confirm-delete-modal .modal-content h3,
        .light-mode #confirm-delete-modal .modal-content p {
            color: #1f2937;
        }
        
        .light-mode #confirm-delete-modal .modal-content button:not(.bg-red-600) {
            color: #4b5563;
        }
        
        /* 日间模式下其他模态框的文字颜色 */
        .light-mode .modal-content h3,
        .light-mode .modal-content label {
            color: #1f2937;
        }
        
        .light-mode .modal-content button:not(.bg-red-600):not(.bg-blue-600):not(.bg-gray-700) {
            color: #4b5563;
        }
        .modal-overlay.visible .modal-content {
            transform: scale(1);
            opacity: 1;
        }

        /* 表情包添加模态框专用样式 */
        .sticker-modal-content {
            width: 90%;
            max-width: 280px;
            padding: 0;
            border-radius: 1rem;
        }
        
        .sticker-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1rem 0.75rem 1rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        /* 日夜间模式下的头部边框 */
        .dark-mode .sticker-modal-header {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        .sticker-modal-title {
            font-size: 1rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        /* ====== 记忆卡片 Modal ====== */
        #memory-card-content {
            background: rgba(0, 0, 0, 0.9); /* 深黑色半透明背景 */
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1.5rem;
            color: #e5e7eb;
            display: flex;
            flex-direction: column;
            max-height: 80vh;
        }
        
        /* 日夜间模式下的记忆卡片样式 */
        .light-mode #memory-card-content {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1f2937;
        }
        
        .light-mode #memory-card-content .card-header {
            border-bottom-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode #memory-card-content .card-footer {
            border-top-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode #memory-card-content .card-quote {
            background: rgba(0, 0, 0, 0.05);
        }
        
        /* 日夜间模式下的记忆卡片内容样式 */
        .light-mode #memory-card-content .card-header h3 {
            color: #1f2937;
        }
        
        .light-mode #memory-card-content .card-header p {
            color: #6b7280;
        }
        
        .light-mode #memory-card-content .card-body h4 {
            color: #374151;
        }
        
        .light-mode #memory-card-content .card-body .bg-gray-50 {
            background-color: #f9fafb;
            color: #1f2937;
        }
        
        .light-mode #memory-card-content .card-body .bg-blue-50 {
            background-color: #eff6ff;
            color: #1e40af;
        }
        
        .light-mode #memory-card-content .card-body .bg-purple-50 {
            background-color: #faf5ff;
            color: #7c3aed;
        }
        
        /* 日夜间模式下的关闭按钮 */
        .light-mode #memory-card-content button[onclick*="classList.remove"] {
            color: #6b7280;
        }
        
        .light-mode #memory-card-content button[onclick*="classList.remove"]:hover {
            color: #374151;
        }
        #memory-card-content .card-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        #memory-card-content .card-title {
            font-family: 'Noto Serif SC', serif;
            font-size: 1.25rem;
            font-weight: 700;
        }
        #memory-card-content .card-timestamp { font-size: 0.75rem; opacity: 0.6; }
        /* 【【请用这个新版本，替换旧的 #memory-card-content .card-body 样式】】 */
        #memory-card-content .card-body {
            padding: 1.25rem;
            overflow-y: auto; /* 【核心】允许内容区垂直滚动 */
            flex: 1; /* 【核心】让内容区占据所有可用的剩余空间 */
            min-height: 0; /* 【核心】一个flex布局中的重要技巧，确保在内容过多时可以正确收缩和滚动 */
        }
        #memory-card-content .card-section-title { font-weight: 600; margin-bottom: 0.5rem; opacity: 0.8; }
        #memory-card-content .card-quote { background: rgba(255, 255, 255, 0.05); padding: 0.75rem; border-radius: 0.5rem; font-style: italic; }
        #memory-card-content .card-footer { padding: 1rem 1.25rem; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        
        /* 记忆卡片底部按钮样式 */
        #memory-card-content .card-footer button {
            min-width: 2rem !important;
            height: 2rem !important;
            font-size: 0.8rem !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            border-radius: 0.5rem !important;
        }
        
        .sticker-modal-close {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            color: #1f2937;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .sticker-modal-close:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: scale(1.1);
        }
        
        /* 日夜间模式下的标题和关闭按钮 */
        .dark-mode .sticker-modal-title {
            color: #ffffff;
        }
        
        .dark-mode .sticker-modal-close {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        .dark-mode .sticker-modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .sticker-modal-body {
            padding: 1rem;
        }
        
        .sticker-input-group {
            margin-bottom: 1rem;
        }
        
        .sticker-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #4b5563;
            margin-bottom: 0.5rem;
        }
        
        .sticker-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 0.5rem;
            color: #1f2937;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        
        .sticker-input:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(0, 0, 0, 0.02);
        }
        
        /* 日夜间模式下的标签和输入框 */
        .dark-mode .sticker-label {
            color: #d1d5db;
        }
        
        .dark-mode .sticker-input {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }
        
        .dark-mode .sticker-input:focus {
            border-color: #60a5fa;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .sticker-upload-btn {
            width: 100%;
            padding: 0.75rem;
            background: rgba(59, 130, 246, 0.8);
            border: none;
            border-radius: 0.5rem;
            color: #ffffff;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 1rem;
        }
        
        .sticker-upload-btn:hover {
            background: rgba(59, 130, 246, 1);
            transform: translateY(-1px);
        }
        
        .sticker-url-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .sticker-url-group .sticker-input {
            flex: 1;
        }
        
        .sticker-add-btn {
            padding: 0.5rem 1rem;
            background: rgba(34, 197, 94, 0.8);
            border: none;
            border-radius: 0.5rem;
            color: #ffffff;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .sticker-add-btn:hover {
            background: rgba(34, 197, 94, 1);
            transform: translateY(-1px);
        }

        .song-list-item {
            padding: 0.75rem 0.5rem;
            border-radius: 0.75rem;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: default;
        }
        .song-list-item:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .song-list-item.active {
            font-weight: 600;
            color: #ffffff;
        }
        .song-list-item-left {
            display: flex;
            align-items: center;
            flex-grow: 1;
            min-width: 0;
        }
        .song-list-item-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }
        .drag-handle {
            cursor: grab;
            padding-right: 0.75rem;
            color: #9ca3af;
        }
        .delete-button {
            cursor: pointer;
            transition: color 0.2s;
            padding-left: 0.75rem;
        }
        .delete-button.pending-delete {
            color: #ef4444;
        }

        .player-button {
            transition: color 0.2s;
        }

        .loop-button.active, .single-loop-button.active {
            color: #ffffff;
        }
        
        .text-widget-input {
            width: 100%;
            background: transparent;
            border: none;
            outline: none;
            padding: 0.25rem 0;
        }
        
        .image-placeholder {
            background-color: rgba(255, 255, 255, 0.2);
            background-size: cover;
            background-position: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* 日夜间模式样式 */
        .dark-mode {
            background-color: #333333;
            color: #ffffff;
        }
        .dark-mode .phone-frame { background-color: #1a1a1a; }
        .dark-mode .phone-screen { background-color: transparent; }
        .dark-mode #home-wallpaper { 
            background-color: #000000; 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        .dark-mode .status-bar, .dark-mode .text-dark, .dark-mode .player-button i, .dark-mode #music-upload-button i, .dark-mode #mood-text::placeholder, .dark-mode #playlist-button i, .dark-mode .text-widget-input::placeholder, .dark-mode .app-header-btn, .dark-mode .quick-action-btn { color: #ffffff; }
        .dark-mode .status-bar { transition: background-color 0.3s; background-color: #1a1a1a; }
        .dark-mode .status-bar.on-home { background-color: transparent !important; }
        .dark-mode .dock, .dark-mode .music-block {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* 深色主题下的剧本内容毛玻璃效果 */
        .dark-mode #scenario-content-container {
            background: rgba(0, 0, 0, 0.3) !important;
            backdrop-filter: blur(20px) !important;
            -webkit-backdrop-filter: blur(20px) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.5),
                0 4px 16px rgba(0, 0, 0, 0.3) !important;
        }
        .dark-mode .app-screen-view:not(#home-screen):not(#wechat-chat-screen) { background-color: #1a1a1a; }
        .dark-mode #wechat-chat-screen { background-color: #1a1a1a; }
        .dark-mode .app-header { 
            background-color: rgba(26, 26, 26, 0.9); 
            border-color: rgba(255, 255, 255, 0.15); 
        }
        .dark-mode .wechat-tab-bar { background-color: #2c2c2c; border-color: #4a4a4a; }
        .dark-mode .image-placeholder { background-color: rgba(255, 255, 255, 0.2); }
        .dark-mode .bg-card { background-color: rgba(255, 255, 255, 0.08); }
        .dark-mode .settings-item, .dark-mode .list-item { background-color: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.15); }
        .dark-mode .wechat-list-item { border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .dark-mode .wechat-list-item:hover { background-color: rgba(255, 255, 255, 0.1); }
        .dark-mode .api-status-on { color: #ffffff; }
        .dark-mode .chat-input-btn { color: #d1d5db; }
        .dark-mode .chat-system-message { background-color: rgba(255, 255, 255, 0.1); }
        
        .light-mode { background-color: white; color: #1f2937; }
        .light-mode .phone-frame { background-color: #1a1a1a; }
        .light-mode .phone-screen { background-color: transparent; }
        .light-mode #home-wallpaper { 
            background-color: white; /* 【修复】改为background-color，不影响背景图片 */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        .light-mode .status-bar, .light-mode .text-dark, .light-mode .app-header-btn, .light-mode .quick-action-btn { color: #1f2937; }
        .light-mode .status-bar { transition: background-color 0.3s; background-color: #ffffff; }
        .light-mode .status-bar.on-home { background-color: transparent !important; }
        .light-mode .player-button i, .light-mode #music-upload-button i, .light-mode #playlist-button i, .light-mode .text-widget-input::placeholder { color: #1f2937; }
        
        /* 浅色模式下歌曲列表文字颜色 */
        .light-mode .song-list-item {
            color: #1f2937 !important; /* 深色文字 */
        }
        .light-mode .song-list-item.active {
            color: #3b82f6 !important; /* 激活状态使用蓝色 */
            font-weight: 600;
        }
        .light-mode .song-list-item:hover {
            background-color: rgba(0, 0, 0, 0.05); /* 浅色悬停背景 */
        }
        .light-mode .song-list-item .delete-button {
            color: #6b7280 !important; /* 删除按钮灰色 */
        }
        .light-mode .song-list-item .drag-handle {
            color: #9ca3af !important; /* 拖拽图标灰色 */
        }
        
        /* 浅色模式下播放列表模态框样式 */
        .light-mode #song-list-modal .modal-content {
            color: #1f2937; /* 深色文字 */
        }
        .light-mode #song-list-modal .modal-content h3 {
            color: #1f2937 !important; /* 标题深色 */
        }
        .light-mode #song-list-modal .modal-content button {
            color: #4b5563; /* 按钮深色 */
        }
        .light-mode #mood-text { color: #1f2937; }
        .light-mode #mood-text::placeholder { color: #9ca3af; }
        .light-mode .dock, .light-mode .music-block {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .light-mode .app-screen-view:not(#home-screen):not(#wechat-chat-screen) { background-color: white; }
        .light-mode #wechat-chat-screen { background-color: white; }
        .light-mode .app-header { 
            background-color: rgba(255, 255, 255, 0.9); 
            border-color: rgba(0, 0, 0, 0.1); 
        }
        .light-mode .wechat-tab-bar { background-color: #ffffff; border-color: #e5e7eb; }
        .light-mode .image-placeholder { background-color: rgba(0, 0, 0, 0.1); }
        .light-mode .bg-card { background-color: #ffffff; }
        .light-mode .settings-item, .light-mode .list-item { background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        .light-mode .wechat-list-item { border-bottom: 1px solid rgba(0, 0, 0, 0.08); }
        .light-mode .wechat-list-item:hover { background-color: rgba(0, 0, 0, 0.05); }
        .light-mode .api-status-on { color: #1f2937; }
        .light-mode .chat-input-btn { color: #4b5563; }
        .light-mode .chat-system-message { background-color: rgba(0, 0, 0, 0.1); }





        /* 聊天界面样式 */
        #wechat-content-chat {
            padding-top: 0.5rem;
        }
        #wechat-content-chat .chat-message-wrapper.new-sender:first-child {
            margin-top: 0.5rem;
        }
        .chat-message-wrapper {
            display: flex;
            align-items: flex-start;
            width: 100%;
            position: relative;
            min-height: 18px; /* <-- 核心修正：统一所有行的最小高度 */
        }
        
        /* ====== 【【修正版】】拉黑消息的红色感叹号样式 ====== */
        .chat-message-wrapper {
            position: relative; /* 确保惊叹号可以相对于此元素定位 */
        }
        .blocked-message-indicator {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.1rem;
            color: #ef4444; /* 红色 */
            text-shadow: 0 0 5px rgba(239, 68, 68, 0.5);
            /* 【核心修正】将负边距改为正边距，确保在wrapper内部 */
        }
        .chat-message-wrapper.sent .blocked-message-indicator {
            left: 0.75rem; /* 在用户消息气泡的左侧 */
        }
        .chat-message-wrapper.received .blocked-message-indicator {
            right: 0.75rem; /* 在AI消息气泡的右侧 */
        }
        .chat-message-wrapper.sent {
            justify-content: flex-end;
        }
        .chat-message-wrapper.received {
            justify-content: flex-start;
        }
        .chat-message-wrapper + .chat-message-wrapper {
            margin-top: 0.1rem !important; /* 为每条消息之间都设置一个固定的间距 */
        }
        
        /* 针对多行气泡后的消息增加额外间距（仅在显示头像模式下） */
        #wechat-content-chat:not(.no-avatars) .chat-message-wrapper.has-multiline + .chat-message-wrapper {
            margin-top: 0.7rem !important; /* 多行气泡后需要更大间距 */
        }
        .chat-avatar {
            width: 36px;  /* <-- 修改这里 */
            height: 36px; /* <-- 修改这里 */
            border-radius: 50%;
            background-color: #9ca3af;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.5);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            visibility: hidden;
            position: relative; /* <-- 新增：开启相对定位 */
            top: -5px;          /* <-- 新增：向上移动5px */
        }
        /* 仅当消息是新的发言者时，才显示头像 */
        .chat-message-wrapper.new-sender .chat-avatar {
            visibility: visible;
        }
        .chat-avatar i {
            font-size: 22px;
            color: rgba(255, 255, 255, 0.8);
        }
        .light-mode .chat-avatar i {
             color: rgba(0, 0, 0, 0.6);
        }
        .chat-message-content {
            display: flex;
            flex-direction: column;
            min-width: 0;
            margin: 0 0.25rem;
            max-width: 75%;
        }
        .chat-message-wrapper.sent .chat-message-content { align-items: flex-end; }
        .chat-message-wrapper.received .chat-message-content { align-items: flex-start; }
        .chat-message {
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border-radius: 1.5rem;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 4px 16px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            padding-top: 0.15rem;     /* <-- 新增 */
            padding-bottom: 0.15rem;  /* <-- 新增 */
            padding-left: 0.5rem;     /* <-- 新增 (比原来稍大一点) */
            padding-right: 0.35rem;    /* <-- 新增 (比原来稍小一点，用于抵消标点空白) */
            width: -moz-fit-content;
            width: fit-content;
            max-width: 100%; 
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: 
                linear-gradient(135deg, 
                    rgba(255, 255, 255, 0.1) 0%, 
                    rgba(255, 255, 255, 0.05) 50%, 
                    rgba(255, 255, 255, 0.02) 100%
                );
            overflow: hidden;
        }
        
        .chat-message::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
            transition: left 0.6s ease;
        }
        
        .chat-message:hover::before {
            left: 100%;
        }
        
        .chat-message:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.18),
                0 6px 20px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        }
        .chat-message.image-message, .chat-message.sticker-message {
            padding: 0.25rem;
            background-color: transparent !important;
            border: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .chat-message.image-message img, .chat-message.sticker-message img {
            max-width: 150px;
            max-height: 200px;
            border-radius: 1rem;
            display: block;
        }
        .chat-message.sticker-message img {
            max-width: 100px;
            max-height: 100px;
        }
        .chat-message.voice-message {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .voice-main {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .voice-play-icon {
            font-size: 1.25rem;
        }
        .voice-duration {
            font-size: 0.8em;
            white-space: nowrap;
        }
        .voice-text {
            padding-top: 0.5rem;
            margin-top: 0.5rem;
            border-top: 1px solid rgba(128, 128, 128, 0.2);
            font-size: 0.9em;
            display: none;
        }
        .chat-message p, .chat-message i {
            font-size: inherit;
            line-height: 1.5;
            margin: 0; /* 消除p标签的默认margin，确保气泡间距统一 */
        }

        .chat-message.image-message::before, .chat-message.voice-message::before, .chat-message.sticker-message::before, .chat-message.red-packet-message::before, .chat-message.transfer-message::before {
            display: none;
        }
        .chat-message::after {
            content: '';
            position: absolute;
            bottom: 6px;
            width: 14px;
            height: 14px;
            background: inherit;
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 12C5.33333 12 12 5.33333 12 0C12 5.33333 5.33333 12 0 12Z' fill='%23C4C4C4'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 12C5.33333 12 12 5.33333 12 0C12 5.33333 5.33333 12 0 12Z' fill='%23C4C4C4'/%3E%3C/svg%3E");
        }
        .chat-message.image-message::after, .chat-message.sticker-message::after, .chat-message.red-packet-message::after, .chat-message.transfer-message::after {
            display: none;
        }
        .chat-message.sent::after {
            right: -7px;
            transform: scaleX(-1);
            border-radius: 0 0 14px 0;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .chat-message.received::after {
            left: -7px;
            border-radius: 0 0 0 14px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }
        .message-meta {
            font-size: 0.6rem;
            color: #9ca3af;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            margin-bottom: 10px;
            white-space: nowrap;
            align-self: flex-end;
        }
        .chat-message-wrapper.sent .message-meta {
            align-items: flex-end;
        }
        .chat-message-wrapper.received .message-meta {
            align-items: flex-start;
        }
        .message-read-status {
            margin-left: 0;
            display: none;
        }
        .message-read-status.visible {
            display: inline;
        }
        .dark-mode .chat-message { 
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 3px 15px rgba(0,0,0,0.12), 0 1px 6px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        .light-mode .chat-message { 
            border: 1px solid rgba(0, 0, 0, 0.06);
            box-shadow: 0 3px 15px rgba(0,0,0,0.08), 0 1px 6px rgba(0,0,0,0.04), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        /* 用户气泡颜色修改 - 水滴毛玻璃效果 */
        .dark-mode .chat-message.sent { 
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.4), rgba(31, 41, 55, 0.3));
            color: #f3f4f6;
        }
        .light-mode .chat-message.sent { 
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.5), rgba(31, 41, 55, 0.4));
            color: #f3f4f6;
        }
        .dark-mode .chat-message.received { 
            background: linear-gradient(135deg, rgba(74, 74, 74, 0.15), rgba(55, 65, 81, 0.1));
        }
        .light-mode .chat-message.received { 
            background: linear-gradient(135deg, rgba(229, 231, 250, 0.4), rgba(214, 219, 230, 0.3));
        }
        .dark-mode .chat-message.sent.image-message, .light-mode .chat-message.sent.image-message { border: 2px solid #4b5563; }
        .dark-mode .chat-message.received.image-message, .light-mode .chat-message.received.image-message { border: 2px solid rgba(229, 231, 250, 0.8); }

        /* ====== 【新增】隐藏头像 (类WhatsApp风格) 的CSS样式 ====== */

        /* 当聊天容器有 .no-avatars 类时，彻底隐藏头像 */
        #wechat-content-chat.no-avatars .chat-avatar {
            display: none;
        }

        /* 隐藏头像后，移除气泡内容区的左右间距，让它直接贴近头像原本的位置 */
        #wechat-content-chat.no-avatars .chat-message-content {
            margin-left: 0;
            margin-right: 0;
        }

        /* 隐藏头像后，将整个聊天行的左右内边距调小，让气泡更靠近屏幕边缘 */
        #wechat-content-chat.no-avatars .chat-message-wrapper {
            padding-left: 0.5rem;  /* 8px，可以按喜好调整 */
            padding-right: 0.5rem; /* 8px，可以按喜好调整 */
        }

        /* ======================================================== */

        /* ====== 画板样式 ====== */
        .drawing-modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .drawing-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .drawing-modal-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .drawing-modal-content {
            background: white;
            border-radius: 20px;
            padding: 0;
            max-width: 400px;
            max-height: 90vh;
            width: 90%;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .drawing-modal-overlay.visible .drawing-modal-content {
            transform: scale(1);
        }

        .drawing-modal-header {
            background: linear-gradient(135deg, #2c2c2c 0%, #666666 50%, #a0a0a0 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 20px 20px 0 0;
        }

        .drawing-modal-title {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .drawing-modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .drawing-modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .drawing-board-container {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        #drawing-canvas {
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            cursor: crosshair;
            background: white;
            display: block;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 300px;
            height: 300px;
        }

        .drawing-tools {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            width: 100%;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 6px;
            justify-content: center;
            max-width: 280px;
            margin: 0 auto;
        }

        .color-swatch {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .color-swatch.selected {
            border-color: #667eea;
            transform: scale(1.1);
        }

        .brush-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }
        
        .brush-preview {
            width: 40px;
            height: 40px;
            border: 2px solid #e5e7eb;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
        }
        
        #brush-preview-circle {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: #000000;
            transition: all 0.2s ease;
        }

        .brush-size-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .brush-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .brush-size-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        #brush-size-value {
            font-size: 14px;
            color: #6b7280;
            min-width: 40px;
            text-align: center;
        }

        .drawing-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .drawing-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .drawing-btn.secondary {
            background: #f3f4f6;
            color: #6b7280;
        }

        .drawing-btn.secondary:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
        }

        .drawing-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .drawing-btn.primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .drawing-modal-content {
                margin: 15px;
                max-width: calc(100% - 30px);
                max-height: calc(100% - 30px);
                width: calc(100% - 30px);
                height: calc(100% - 30px);
            }
            
            #drawing-canvas {
                width: 100%;
                height: 75vw;
                max-width: 300px;
                max-height: 300px;
            }
            
            .drawing-tools {
                gap: 10px;
            }
            
            .color-palette {
                grid-template-columns: repeat(6, 1fr);
                gap: 5px;
                max-width: 180px;
            }
            
            .color-swatch {
                width: 20px;
                height: 20px;
            }
        }
        


        /* ====== 塔罗牌样式 ====== */
        /* 确保塔罗牌界面不受其他样式影响 */
        html, body {
            overflow: visible !important;
            position: relative !important;
        }
        
        .tarot-modal-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 20, 0.98) 100%);
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            z-index: 99999 !important;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            box-sizing: border-box !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        .tarot-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .tarot-modal-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .tarot-modal-content {
            background: linear-gradient(145deg, #0a0a0a 0%, #1a1a1a 25%, #2a2a2a 50%, #3a3a3a 75%, #1a1a1a 100%);
            border-radius: 25px;
            padding: 0;
            max-width: 420px;
            max-height: 90vh;
            width: 90%;
            height: auto;
            min-height: 600px;
            overflow: hidden;
            box-shadow: 
                0 25px 80px rgba(0, 0, 0, 0.8),
                0 0 100px rgba(128, 128, 128, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transform: scale(0.7) rotateY(-15deg);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            position: relative;
            box-sizing: border-box;
            margin: 0;
        }

        .tarot-modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: none;
            border-radius: 25px;
            animation: none;
            pointer-events: none;
            z-index: 1;
            box-sizing: border-box;
        }

        .tarot-modal-content::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: none;
            border-radius: 25px;
            z-index: 0;
            animation: none;
            opacity: 0;
            box-sizing: border-box;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.2; transform: translateX(-100%); }
            50% { opacity: 0.5; transform: translateX(100%); }
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .tarot-modal-overlay.visible .tarot-modal-content {
            transform: scale(1) rotateY(0deg);
        }

        .tarot-modal-header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 50%, #3a3a3a 100%);
            color: #e0e0e0;
            padding: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 25px 25px 0 0;
            position: relative;
            overflow: hidden;
            z-index: 3;
            margin: 0;
        }

        .tarot-modal-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            animation: headerShine 4s ease-in-out infinite;
        }

        @keyframes headerShine {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }

        .tarot-modal-title {
            margin: 0;
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(45deg, #ffffff, #cccccc, #ffffff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s ease-in-out infinite;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        @keyframes titleGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .tarot-modal-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e0e0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .tarot-modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .tarot-container {
            padding: 25px;
            text-align: center;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
            min-height: 400px;
        }

        .tarot-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(128, 128, 128, 0.05) 0%, transparent 80%),
                radial-gradient(circle at 80% 80%, rgba(64, 64, 64, 0.05) 0%, transparent 80%);
            pointer-events: none;
        }

        .tarot-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.05) 0%, transparent 25px),
                radial-gradient(circle at 75% 75%, rgba(128, 128, 128, 0.05) 0%, transparent 25px),
                radial-gradient(circle at 50% 10%, rgba(64, 64, 64, 0.05) 0%, transparent 20px),
                radial-gradient(circle at 10% 60%, rgba(255, 255, 255, 0.05) 0%, transparent 20px),
                radial-gradient(circle at 90% 40%, rgba(128, 128, 128, 0.05) 0%, transparent 20px);
            animation: particleFloat 8s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes particleFloat {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg);
                opacity: 0.2;
            }
            25% { 
                transform: translateY(-8px) rotate(90deg);
                opacity: 0.4;
            }
            50% { 
                transform: translateY(-4px) rotate(180deg);
                opacity: 0.3;
            }
            75% { 
                transform: translateY(-12px) rotate(270deg);
                opacity: 0.5;
            }
        }

        @keyframes darkGradientShift {
            0%, 100% { 
                background-position: 0% 50%;
            }
            25% { 
                background-position: 100% 50%;
            }
            50% { 
                background-position: 100% 100%;
            }
            75% { 
                background-position: 0% 100%;
            }
        }

        .tarot-card-display {
            margin-bottom: 12px;
            flex-shrink: 0;
            position: relative;
        }

        .tarot-card-back {
            width: 180px;
            height: 260px;
            margin: 0 auto;
            background: linear-gradient(145deg, #1a1a1a 0%, #2a2a2a 25%, #3a3a3a 50%, #4a4a4a 75%, #2a2a2a 100%);
            border-radius: 16px;
            border: 2px solid #666666;
            box-shadow: 
                0 12px 30px rgba(0, 0, 0, 0.6),
                0 0 25px rgba(128, 128, 128, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
        }

        .tarot-card-back::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.05) 0%, transparent 80%),
                radial-gradient(circle at 70% 70%, rgba(255, 255, 255, 0.03) 0%, transparent 80%);
            animation: cardGlow 3s ease-in-out infinite;
        }

        .tarot-card-back::after {
            content: '✧';
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite;
        }

        .tarot-card-back .symbol-top-right {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite 0.5s;
        }

        .tarot-card-back .symbol-bottom-left {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 16px;
            color: rgba(128, 128, 128, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite 1s;
        }

        .tarot-card-back .symbol-bottom-right {
            position: absolute;
            bottom: 15px;
            right: 15px;
            font-size: 16px;
            color: rgba(192, 192, 192, 0.6);
            animation: symbolTwinkle 2s ease-in-out infinite 1.5s;
        }

        @keyframes symbolTwinkle {
            0%, 100% { opacity: 0.3; transform: scale(1) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.2) rotate(180deg); }
        }

        @keyframes cardGlow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        .tarot-card-back:hover {
            transform: translateY(-8px) rotateY(5deg);
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.7),
                0 0 40px rgba(128, 128, 128, 0.6);
        }

        .card-back-pattern {
            position: absolute;
            top: 25px;
            left: 25px;
            right: 25px;
            bottom: 25px;
            background: 
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 15px,
                    rgba(255, 255, 255, 0.08) 15px,
                    rgba(255, 255, 255, 0.08) 30px
                ),
                repeating-linear-gradient(
                    -45deg,
                    transparent,
                    transparent 15px,
                    rgba(255, 255, 255, 0.05) 15px,
                    rgba(255, 255, 255, 0.05) 30px
                );
            border-radius: 15px;
            opacity: 0.8;
        }

        .card-back-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            background: linear-gradient(45deg, #ffffff, #cccccc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: textPulse 2s ease-in-out infinite;
        }

        @keyframes textPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        .tarot-card-front {
            width: 180px;
            height: 260px;
            margin: 0 auto;
            background: linear-gradient(145deg, #f5f5f5 0%, #e8e8e8 25%, #d8d8d8 50%, #c8c8c8 75%, #f5f5f5 100%);
            border-radius: 16px;
            border: 2px solid #999999;
            box-shadow: 
                0 12px 30px rgba(0, 0, 0, 0.5),
                0 0 25px rgba(128, 128, 128, 0.3);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            transform: rotateY(180deg);
            transform-style: preserve-3d;
        }

        .tarot-card-front.flipped {
            transform: rotateY(0deg);
        }

        .card-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 17px;
        }

        .tarot-info {
            margin: 15px 0 8px 0;
            padding: 15px;
            background: linear-gradient(135deg, rgba(26, 26, 26, 0.8) 0%, rgba(42, 42, 42, 0.8) 100%);
            border-radius: 12px;
            border: 1px solid rgba(128, 128, 128, 0.3);
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .tarot-info::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                transparent 0%, 
                rgba(128, 128, 128, 0.05) 50%, 
                transparent 100%);
            animation: infoShimmer 4s ease-in-out infinite;
        }

        @keyframes infoShimmer {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .card-name {
            margin: 0 0 12px 0;
            font-size: 19px;
            font-weight: bold;
            background: linear-gradient(45deg, #ffffff, #cccccc, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .card-meaning {
            margin: 0 0 15px 0;
            font-size: 15px;
            line-height: 1.6;
            color: #e0e0e0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .card-orientation {
            margin-top: 10px;
        }

        .orientation-text {
            padding: 8px 18px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(192, 192, 192, 0.1) 100%);
            border-radius: 25px;
            font-size: 13px;
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(5px);
            animation: orientationPulse 3s ease-in-out infinite;
        }

        @keyframes orientationPulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .tarot-actions {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 8px;
            padding-top: 12px;
            flex-shrink: 0;
        }

        .tarot-btn {
            padding: 12px 22px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 110px;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .tarot-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.2), 
                transparent);
            transition: left 0.5s ease;
        }

        .tarot-btn:hover::before {
            left: 100%;
        }

        .tarot-btn.primary {
            background: linear-gradient(135deg, #333333 0%, #666666 50%, #333333 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(128, 128, 128, 0.4);
            border: 1px solid rgba(128, 128, 128, 0.3);
        }

        .tarot-btn.primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(128, 128, 128, 0.6);
        }

        .tarot-btn.secondary {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .tarot-btn.secondary:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.2);
        }

        /* 塔罗牌响应式设计 */
        @media (max-width: 768px) {
            .tarot-modal-content {
                margin: 15px;
                max-width: calc(100% - 30px);
                max-height: 85vh;
                width: calc(100% - 30px);
                height: auto;
                min-height: 500px;
                transform: scale(0.9) rotateY(0deg);
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg);
            }
            
            .tarot-card-back,
            .tarot-card-front {
                width: 160px;
                height: 240px;
            }
            
            .tarot-container {
                padding: 20px;
            }
            
            .tarot-actions {
                gap: 15px;
                margin-top: 20px;
            }
            
            .tarot-btn {
                padding: 12px 24px;
                min-width: 120px;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .tarot-modal-overlay {
                padding: 10px;
            }
            
            .tarot-modal-content {
                transform: scale(0.95) rotateY(0deg);
                max-width: 95%;
                max-height: 80vh;
                min-height: 450px;
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg);
            }
            
            .tarot-card-back,
            .tarot-card-front {
                width: 140px;
                height: 200px;
            }
            
            .tarot-actions {
                flex-direction: column;
                gap: 15px;
            }
            
            .tarot-btn {
                min-width: 100%;
                padding: 14px 24px;
                font-size: 15px;
            }
            
            .tarot-info {
                margin: 20px 0;
                padding: 18px;
            }
            
            .card-name {
                font-size: 19px;
            }
            
            .card-meaning {
                font-size: 14px;
            }
            

        

        }
        
        @media (max-width: 360px) {
            .tarot-modal-overlay {
                padding: 5px;
            }
            
            .tarot-modal-content {
                transform: scale(0.98) rotateY(0deg);
                max-width: 98%;
                max-height: 85vh;
                min-height: 400px;
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg);
            }
            
            .tarot-card-back,
            .tarot-card-front {
                width: 120px;
                height: 180px;
            }
            
            .tarot-info {
                margin: 15px 0;
                padding: 15px;
            }
            
            .card-name {
                font-size: 17px;
            }
            
            .card-meaning {
                font-size: 13px;
            }
            
            .tarot-btn {
                padding: 12px 20px;
                font-size: 14px;
            }
            

        }
        
        /* 移动端特殊处理 */
        @media (max-width: 768px) {
            .tarot-modal-overlay {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                min-height: 100vh !important;
                overflow: hidden !important;
            }
            
            .tarot-modal-content {
                position: relative !important;
                transform: scale(1) rotateY(0deg) !important;
                max-width: 95vw !important;
                max-height: 85vh !important;
                margin: 0 auto !important;
                min-height: 500px !important;
            }
            
            .tarot-modal-overlay.visible .tarot-modal-content {
                transform: scale(1) rotateY(0deg) !important;
            }
        }
        
        /* 强制覆盖所有可能的定位问题 */
        .tarot-modal-overlay.visible {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            z-index: 99999 !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        /* 修复垂直居中偏下的问题 */
        .tarot-modal-content {
            position: relative !important;
            transform: none !important;
            margin: 0 auto !important;
            max-height: 90vh !important;
            overflow-y: auto !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: center !important;
        }
        
        /* 移动端垂直居中优化 */
        @media (max-width: 768px) {
            .tarot-modal-content {
                max-height: 85vh !important;
                min-height: 500px !important;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-modal-content {
                max-height: 80vh !important;
                min-height: 450px !important;
            }
        }
        
        /* 更精确的垂直居中 */
        .tarot-modal-overlay.visible {
            align-items: center !important;
            padding-top: 2vh !important;
            padding-bottom: 2vh !important;
            overflow-y: auto !important;
        }
        
        /* 移动端塔罗牌卡片显示优化 */
        @media (max-width: 768px) {
            .tarot-card-display {
                margin-bottom: 20px;
            }
            
            .tarot-info {
                margin: 20px 0;
                padding: 20px;
            }
            
            .tarot-actions {
                margin-top: 25px;
                padding-bottom: 10px;
            }
        }
        
        /* ====== 钱包样式 ====== */
        .wallet-container {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .wallet-summary {
            background: var(--primary-gradient);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            color: white;
            text-align: center;
        }
        
        .wallet-total h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            opacity: 0.9;
        }
        
        .total-amount {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .wallet-stats {
            display: flex;
            justify-content: space-around;
            gap: 20px;
        }
        
        .stat-item {
            text-align: center;
            flex: 1;
        }
        
        .stat-label {
            display: block;
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .stat-value {
            display: block;
            font-size: 18px;
            font-weight: bold;
        }
        
        .wallet-records h4 {
            margin: 0 0 15px 0;
            color: var(--text-primary);
            font-size: 18px;
        }
        
        .records-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .record-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-radius: 10px;
            background: var(--background-secondary);
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
        }
        
        .record-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .record-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
        }
        
        .record-icon.red-packet {
            background: linear-gradient(135deg, #ff4757, #ff3838);
        }
        
        .record-icon.transfer {
            background: linear-gradient(135deg, #5352ed, #3742fa);
        }
        
        .record-info {
            flex: 1;
        }
        
        .record-type {
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 2px;
        }
        
        .record-character {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .record-amount {
            font-weight: bold;
            color: #2ed573;
            font-size: 16px;
        }
        
        .record-time {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .empty-records {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        
        .empty-records i {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        /* 钱包响应式设计 */
        @media (max-width: 768px) {
            .wallet-container {
                padding: 15px;
            }
            
            .wallet-summary {
                padding: 15px;
            }
            
            .total-amount {
                font-size: 28px;
            }
            
            .wallet-stats {
                gap: 15px;
            }
            
            .stat-value {
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-card-display {
                margin-bottom: 25px;
            }
            
            .tarot-info {
                margin: 25px 0;
                padding: 22px;
            }
            
            .tarot-actions {
                margin-top: 30px;
                padding-bottom: 15px;
            }
        }
        
        /* 移动端更精确的垂直居中 */
        @media (max-width: 768px) {
            .tarot-modal-overlay.visible {
                padding-top: 3vh !important;
                padding-bottom: 3vh !important;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-modal-overlay.visible {
                padding-top: 2vh !important;
                padding-bottom: 2vh !important;
            }
        }
        
        /* 确保在移动端也能正确显示 */
        @media (orientation: portrait) {
            .tarot-modal-overlay {
                width: 100vw !important;
                height: 100vh !important;
                min-height: 100vh !important;
            }
        }
        
        @media (orientation: landscape) {
            .tarot-modal-overlay {
                width: 100vw !important;
                height: 100vh !important;
                min-height: 100vh !important;
            }
        }
        
        /* 确保按钮区域完全可见 */
        .tarot-buttons {
            margin-top: 15px !important;
            padding: 10px 0 !important;
            position: relative !important;
            z-index: 10 !important;
        }
        
        .tarot-btn {
            margin: 5px !important;
            position: relative !important;
            z-index: 10 !important;
        }
        

        
        /* 移动端按钮优化 */
        @media (max-width: 768px) {
            .tarot-buttons {
                margin-top: 20px !important;
                padding: 15px 0 !important;
            }
        }
        
        @media (max-width: 480px) {
            .tarot-buttons {
                margin-top: 25px !important;
                padding: 20px 0 !important;
            }
        }
        .chat-system-message {
            background-color: rgba(128, 128, 128, 0.2);
            color: #d1d5db;
            font-size: 0.75rem;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            margin: 0.5rem auto;
            width: fit-content;
        }
        .light-mode .chat-system-message {
            color: #4b5563;
        }
        .chat-input-bar {
            background-color: transparent;
            border-top-width: 1px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .dark-mode .chat-input-bar { border-color: rgba(255, 255, 255, 0.1); }
        .light-mode .chat-input-bar { border-color: rgba(0, 0, 0, 0.1); }
        #chat-input {
            border: 1px solid transparent;
            box-shadow: none;
            transition: background-color 0.3s, box-shadow 0.3s, height 0.2s ease-in-out;
            resize: none;
            overflow-y: auto;
            line-height: 1.5;
        }
        .dark-mode #chat-input { background-color: transparent; color: #ffffff; }
        .light-mode #chat-input { background-color: transparent; color: #1f2937; }
        #chat-input::placeholder {
            color: var(--placeholder-color, rgba(156, 163, 175, 0.7));
        }
        .status-bar.transparent-override {
            background-color: transparent !important;
        }
        #wechat-chat-screen.has-custom-bg {
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
            background-color: transparent !important; /* 确保覆盖默认背景色 */
        }

        #wechat-chat-screen.has-custom-bg .app-header,
        #wechat-chat-screen.has-custom-bg .chat-input-bar,
        #wechat-chat-screen.has-custom-bg #chat-quick-actions-bar {
                background: transparent !important; /* 将背景设置为完全透明 */
    backdrop-filter: none !important; /* 移除模糊效果 */
    -webkit-backdrop-filter: none !important; /* 移除模糊效果 */
            border-color: transparent !important;
        }

        .light-mode #wechat-chat-screen.has-custom-bg .app-header,
        .light-mode #wechat-chat-screen.has-custom-bg .chat-input-bar,
        .light-mode #wechat-chat-screen.has-custom-bg #chat-quick-actions-bar {
             background: transparent !important; /* 同样设置为完全透明 */
        }
        .chat-time-divider {
            display: none;
        }
        
        /* 修改后 */
        .bubble-context-menu {
            position: absolute;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 1rem; /* 圆角改小一点，更适合多行 */
            padding: 0.5rem; /* 增加一点内边距，让按钮更舒展 */
            display: none;

            /* ====== 核心修改：从Flex变为Grid ====== */
            display: grid;
            grid-template-columns: repeat(4, auto); /* 每行最多4个按钮，宽度自适应 */
            gap: 4px; /* 按钮之间的间隙 */
            justify-items: center; /* 让按钮在各自的格子内居中 */

            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: translateY(5px) scale(0.95);
            opacity: 0;
            transition: opacity 0.15s ease-out, transform 0.15s ease-out;
            visibility: hidden;
        }
        .bubble-context-menu.visible {
            display: grid; /* 配合上面的Grid布局 */
            opacity: 1;
            transform: translateY(0) scale(1);
            visibility: visible;
        }
        .bubble-menu-button {
            background: none;
            border: none;
            color: #f0f0f0;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 11px;
            border-radius: 2rem;
            transition: background-color 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }
        .bubble-menu-button:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .bubble-menu-button:disabled {
            color: #6b7280;
            cursor: not-allowed;
        }
        .bubble-menu-button i {
            font-size: 12px;
            margin-right: 3px;
        }
        
        .chat-message-wrapper.selected .chat-message {
            background-color: rgba(59, 130, 246, 0.4) !important;
            border-color: rgba(96, 165, 250, 0.8) !important;
        }
        .light-mode .chat-message-wrapper.selected .chat-message {
             background-color: rgba(96, 165, 250, 0.5) !important;
        }


        .color-picker-input {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 1.75rem;
            height: 1.75rem;
            padding: 0;
            border: 2px solid rgba(128, 128, 128, 0.3);
            border-radius: 50%;
            cursor: pointer;
            background-color: transparent;
        }
        .color-picker-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .color-picker-input::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }
        .color-picker-input::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }

        /* 重置外观设置按钮样式 */
        #reset-colors-btn {
            font-size: 14px;
            min-width: 160px;
        }
        
        #reset-colors-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .dark-mode #reset-colors-btn {
            background-color: #3b82f6;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .dark-mode #reset-colors-btn:hover {
            background-color: #2563eb;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.25);
        }

        .app-header { 
            display: flex; 
            align-items: center; /* 垂直居中所有子元素 */
            justify-content: space-between; 
            padding: 0.5rem 1rem;
            height: 4.5rem; /* 增加标题栏高度以容纳多行文字 */
            flex-shrink: 0;
            position: relative; /* 确保z-index生效 */
            z-index: 20;
            border-bottom: 1px solid rgba(128, 128, 128, 0.2); /* 中性边框颜色 */
            background: transparent;
        }

        /* 剧场界面头部标题栏下移 */
        #theater-screen .app-header {
            padding-top: 2rem;
            padding-bottom: 0.5rem;
            /* 确保标题栏在手机模式下始终可见 */
            min-height: 4.5rem;
            overflow: visible;
        }

        .app-header .text-center {
            /* 这个容器包裹着中英文标题 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .app-header-title { 
            font-weight: 700; 
            font-size: 1.125em; /* 18px */
            color: inherit; /* 继承父元素颜色 */
            margin: 0; /* 移除任何可能的外边距 */
        }

        .app-header .text-xs {
            font-size: 0.75rem; /* 12px */
            color: inherit; /* 继承父元素颜色 */
            letter-spacing: 0.1em; /* 增加字母间距 */
            margin-top: 0.25rem; /* 与主标题的间距 */
        }
        .app-header-title.clickable { cursor: pointer; }
        .app-header-btn.text-pink-500 {
            color: #d1d5db;
        }
        .app-header-btn { font-size: 1.25em; }
        
        /* 时光回廊返回按钮样式 - 根据日夜间模式调整 */
        #back-to-character-select {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .dark-mode #back-to-character-select {
            background: rgba(255, 255, 255, 0.1) !important;
            color: #ffffff !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
        }
        
        .light-mode #back-to-character-select {
            background: rgba(0, 0, 0, 0.1) !important;
            color: #000000 !important;
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
        }
        
        .dark-mode #back-to-character-select:hover {
            background: rgba(255, 255, 255, 0.2) !important;
            border-color: rgba(255, 255, 255, 0.4) !important;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3) !important;
        }
        
        .light-mode #back-to-character-select:hover {
            background: rgba(0, 0, 0, 0.2) !important;
            border-color: rgba(0, 0, 0, 0.4) !important;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) !important;
        }

        .list-item {
            display: flex;                 /* <-- 确保是Flex布局 */
            justify-content: space-between;  /* <-- 新增：让左右两端对齐 */
            align-items: center;           /* <-- 垂直居中对齐 */
            padding: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 0.8rem;
            position: relative;
        }
        .list-item:hover {
            background-color: rgba(128, 128, 128, 0.1);
        }
        .list-item-delete-btn {
            position: absolute;
            top: -0.5rem;
            left: -0.5rem;
            width: 1.5rem;
            height: 1.5rem;
            background-color: #ef4444;
            color: white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            cursor: pointer;
            z-index: 10;
            animation: popIn 0.2s ease-out;
        }
        .deletable:hover .list-item-delete-btn {
            display: flex;
        }
        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }


        .form-input, .form-textarea, .form-select { width: 100%; padding: 0.5rem; border-radius: 0.5rem; border: 1px solid transparent; }
        .dark-mode .form-input, .dark-mode .form-textarea, .dark-mode .form-select { background-color: #2c2c2c; color: #ffffff; }
        .light-mode .form-input, .light-mode .form-textarea, .light-mode .form-select { background-color: #ffffff; color: #1f2937; border: 1px solid #e5e7eb; }

        /* 为form-select添加下拉选项的夜间模式样式 */
        .dark-mode .form-select option {
            background-color: #2c2c2c !important;
            color: #ffffff !important;
        }
        
        .light-mode .form-select option {
            background-color: #ffffff !important;
            color: #1f2937 !important;
        }
        
        /* 确保form-select在夜间模式下文字可见 */
        .dark-mode .form-select {
            color: #ffffff !important;
        }
        
        .light-mode .form-select {
            color: #1f2937 !important;
        }
        
        /* 针对不同浏览器的兼容性处理 */
        .dark-mode .form-select::-ms-expand {
            filter: invert(1);
        }
        
        .light-mode .form-select::-ms-expand {
            filter: invert(0);
        }
        
        /* Select元素在夜间模式下的特殊处理 - 自定义下拉箭头 */
        .dark-mode .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        
        .light-mode .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%231f2937' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        
        /* API输入框样式 - 支持日间夜间模式 */
        .api-input {
            width: 100%;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid transparent;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }
        
        /* 夜间模式API输入框 */
        .dark-mode .api-input {
            background-color: rgba(44, 44, 44, 0.9);
            color: #ffffff;
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        /* 日间模式API输入框 */
        .light-mode .api-input {
            background-color: rgba(255, 255, 255, 0.95);
            color: #1f2937;
            border-color: rgba(0, 0, 0, 0.15);
        }
        
        /* 夜间模式焦点状态 */
        .dark-mode .api-input:focus {
            outline: none;
            border-color: rgba(59, 130, 246, 0.8);
            background-color: rgba(44, 44, 44, 1);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        /* 日间模式焦点状态 */
        .light-mode .api-input:focus {
            outline: none;
            border-color: #3b82f6;
            background-color: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        
        /* 夜间模式占位符 */
        .dark-mode .api-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        /* 日间模式占位符 */
        .light-mode .api-input::placeholder {
            color: rgba(0, 0, 0, 0.5);
        }

        /* Select 元素特殊样式 - 确保选项文字可见 */
        .dark-mode select.api-input option {
            background-color: #2c2c2c !important;
            color: #ffffff !important;
        }

        .light-mode select.api-input option {
            background-color: #ffffff !important;
            color: #1f2937 !important;
        }

        /* 确保select元素在夜間模式下文字可見 */
        .dark-mode select.api-input {
            color: #ffffff !important;
        }

        .light-mode select.api-input {
            color: #1f2937 !important;
        }

        /* 針對不同瀏覽器的兼容性處理 */
        .dark-mode select.api-input::-ms-expand {
            filter: invert(1);
        }

        .light-mode select.api-input::-ms-expand {
            filter: invert(0);
        }

        /* Select 元素在夜間模式下的特殊處理 */
        .dark-mode select.api-input {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }

        .light-mode select.api-input {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%231f2937' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }

        /* 剧场主题设置模态框样式 */
        #scenario-theme-modal {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            background: rgba(0, 0, 0, 0.7) !important;
            display: none !important;
            justify-content: center !important;
            align-items: center !important;
            padding: 20px !important;
            box-sizing: border-box !important;
        }
        
        #scenario-theme-modal.visible {
            display: flex !important;
        }
        
        #scenario-theme-modal .modal-content {
            max-width: 450px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            margin: 0;
            position: relative;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        #scenario-theme-modal.visible .modal-content {
            transform: scale(1);
            opacity: 1;
        }

        #scenario-theme-modal .color-picker-input {
            border: 2px solid rgba(128, 128, 128, 0.3);
            transition: border-color 0.2s ease;
        }

        #scenario-theme-modal .color-picker-input:hover {
            border-color: rgba(59, 130, 246, 0.6);
        }

        /* 日夜间模式下的主题设置对话框 */
        .dark-mode #scenario-theme-modal .modal-content {
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .light-mode #scenario-theme-modal .modal-content {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1f2937;
        }

        .dark-mode #scenario-theme-modal .modal-content h3,
        .dark-mode #scenario-theme-modal .modal-content label {
            color: #ffffff;
        }

        .light-mode #scenario-theme-modal .modal-content h3,
        .light-mode #scenario-theme-modal .modal-content label {
            color: #1f2937;
        }

        .dark-mode #scenario-theme-modal .text-gray-600 {
            color: #d1d5db !important;
        }

        .light-mode #scenario-theme-modal .text-gray-600 {
            color: #6b7280 !important;
        }
        .wb-checkbox-label { display: flex; align-items: center; padding: 0.5rem; border-radius: 0.5rem; cursor: pointer; }
        .wb-checkbox-label:hover { background-color: rgba(255, 255, 255, 0.1); }
        .wb-checkbox-label input { margin-right: 0.75rem; }

        /* 世界书多选选项容器夜间模式样式 */
        .dark-mode #cb-worldbook-select {
            background-color: rgba(44, 44, 44, 0.8);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }
        
        .light-mode #cb-worldbook-select {
            background-color: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.15);
            color: #1f2937;
        }
        
        /* 世界书多选选项标签夜间模式样式 */
        .dark-mode .wb-checkbox-label {
            color: #ffffff;
        }
        
        .dark-mode .wb-checkbox-label:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .light-mode .wb-checkbox-label {
            color: #1f2937;
        }
        
        .light-mode .wb-checkbox-label:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .wechat-tab-bar { display: flex; border-top-width: 1px; }
        .wechat-tab-item { 
            flex: 1; 
            text-align: center; 
            padding: 0.5rem 0; 
            cursor: pointer; 
            color: #9ca3af; 
            position: relative; /* 为红点定位提供基准 */
        }
        .wechat-tab-item.active {
            font-weight: 600;
        }
        .dark-mode .wechat-tab-item.active {
            color: #ffffff;
        }
        .light-mode .wechat-tab-item.active {
            color: #1f2937;
        }
        .wechat-tab-item i { font-size: 1.25em; }
        .wechat-tab-item span { display: block; font-size: 0.75em; }

        /* --- 新增：底部菜单栏红点提示样式 --- */
        .notification-dot {
            position: absolute;
            top: 2px; /* 距离顶部2px */
            right: 25%; /* 位于右侧约1/4处，可根据视觉效果微调 */
            width: 8px;
            height: 8px;
            background-color: #ef4444; /* 红色 */
            border-radius: 50%;
            border: 1px solid white; /* 白色描边，使其更突出 */
            box-shadow: 0 0 3px rgba(239, 68, 68, 0.5);
        }

        .notification-dot.hidden {
            display: none; /* 用于隐藏红点 */
        }

        .wechat-list-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }
        .wechat-list-item .last-message {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .user-avatar-in-chat {
            cursor: pointer;
        }

        /* 第三层：#phone-screen 作为所有应用内容的直接容器 */
        .app-screen-view {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex; /* 让它能撑满容器 */
            flex-direction: column; /* 让内部元素纵向排列 */
            flex: 1; /* 占据所有可用空间 */
            overflow: hidden; /* 默认所有视图都不能滚动 */
            padding-top: 2rem; /* <-- 保持原有的 2rem 内边距 */
        }

        /* 替换您原来的 #home-screen 规则 */
        #home-screen {
            overflow-y: auto; /* 只给主屏幕添加Y轴滚动许可 */
            -webkit-overflow-scrolling: touch; /* 开启流畅滚动 */
            padding-bottom: 7rem;
        }


        .font-size-btn.active {
            font-weight: 600;
        }
        .dark-mode .font-size-btn.active { background-color: #52525b; }
        .light-mode .font-size-btn.active { background-color: #d4d4d8; }
        .dark-mode #font-size-selector { background-color: #3f3f46; }
        .light-mode #font-size-selector { background-color: #e4e4e7; }

        #confirm-delete-modal .modal-content {
            padding: 1.5rem;
        }
        
        #wechat-chat-screen .app-header {
            position: relative;
            z-index: 2;
        }
        #wechat-content-chat {
            position: relative;
            z-index: 1;
            overflow-y: auto; /* 允许聊天记录滚动 */
            -webkit-overflow-scrolling: touch; /* 开启流畅滚动 */
            flex: 1;
        }
        #chat-footer {
            position: relative;
            z-index: 2;
        }
        
        #chat-quick-actions-bar {
            background: transparent;
            padding: 0.25rem 1rem;
            display: flex;
            justify-content: flex-start;
            gap: 1rem;
        }
        .quick-action-btn {
            font-size: 1.25rem;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .quick-action-btn:hover {
            opacity: 1;
        }
        
        #chat-footer {
            position: relative;
        }

        #chat-input-bar {
            padding: 0.5rem 0.25rem;
        }
        #chat-input-bar .chat-input-btn {
            font-size: 1.25rem;
            padding: 0.5rem;
            flex-shrink: 0;
        }
        #emoji-btn {
            margin-left: -0.25rem;
        }

        #more-features-panel {
            background: #2c2c2e;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            /* 【【V8.3 修复】】添加滚动支持，确保小屏幕能访问所有功能 */
            max-height: 240px; /* 约2.5行的高度，确保小手机能显示 */
            overflow-y: auto;
        }
        .light-mode #more-features-panel {
            background: #f8f8f8;
            border-top-color: rgba(0, 0, 0, 0.1);
        }
        
        /* 【【V8.3 修复】】更多功能面板滚动条美化 */
        #more-features-panel::-webkit-scrollbar {
            width: 6px;
        }
        #more-features-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        #more-features-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        #more-features-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        .light-mode #more-features-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        .light-mode #more-features-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }
        .light-mode #more-features-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.5);
        }
        .features-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }
        .feature-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        .feature-icon-wrapper {
            width: 56px;
            height: 56px;
            border-radius: 1rem;
            background-color: #3a3a3c;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 0.5rem;
            transition: background-color 0.2s;
        }
        .light-mode .feature-icon-wrapper {
            background-color: #ffffff;
        }
        .feature-item:hover .feature-icon-wrapper {
            background-color: #555;
        }
        .light-mode .feature-item:hover .feature-icon-wrapper {
            background-color: #e5e5e5;
        }
        .feature-icon-wrapper i {
            font-size: 1.5rem;
        }
        .feature-item span {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .call-screen {
            position: absolute;
            inset: 0;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            background-color: #111;
            color: white;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .call-screen.visible {
            opacity: 1;
            visibility: visible;
        }
        .call-background {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            filter: blur(4px) brightness(0.6);
            transform: scale(1.1);
        }
        .call-content {
            position: relative;
            z-index: 1;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 3.5rem 1rem 1rem;
        }
        #voice-call-avatar {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.5);
            object-fit: cover;
            box-shadow: 0 0 30px rgba(255,255,255,0.3);
            margin-top: 2rem;
        }
        #user-video-preview {
            position: absolute;
            top: 3.5rem;
            right: 1rem;
            width: 90px;
            height: 120px;
            background-color: #333;
            border-radius: 1rem;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #user-video-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .call-status-box {
            margin-top: 1rem;
            background: rgba(0, 0, 0, 0.25); 
            backdrop-filter: blur(12px);     
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); 
            border-radius: 1rem;
            padding: 1rem;
            max-height: 25vh;
            overflow-y: auto;
            color: #e5e7eb;
            flex-shrink: 0;
        }
        .call-input-area {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 0;
        }
        .call-input-area textarea {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 1.5rem;
            padding: 0.6rem 1rem;
            color: white;
            resize: none;
            max-height: 80px; /* 设定一个大约三行文字的最大高度 */
            line-height: 1.5;
            overflow-y: hidden; /* 初始时隐藏滚动条 */
        }
        .call-input-area button {
            background-color: #374151;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        .call-input-area button:hover {
            background-color: #4b5563;
        }
        .call-controls {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 1rem 0;
        }
        .call-control-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
        }
        .hangup-btn { 
            background-color: #ef4444; 
        }

        #incoming-call-alert {
            position: fixed;
            top: 3.5rem;
            left: 0.5rem;
            right: 0.5rem;
            z-index: 9500;
            background: rgba(30, 30, 30, 0.8);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            transform: translateY(-200%);
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            opacity: 0;
            visibility: hidden;
        }
        #incoming-call-alert.visible {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }
        #incoming-call-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 1rem;
        }
        #incoming-call-info {
            flex-grow: 1;
        }
        .call-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 1.25rem;
            margin-left: 0.75rem;
        }

        #answer-call-btn { background-color: #22c55e; }
        #decline-call-btn { background-color: #ef4444; }

        /* 红包/转账高级UI样式 */
        .payment-modal-overlay {
            position: absolute;
            inset: 0;
            z-index: 12000;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .payment-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .payment-modal-content {
            background-color: #1a1a1a;
            color: #C0C0C0;
            width: 90%;
            max-width: 280px; /* 缩小了宽度 */
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s;
        }
        .payment-modal-overlay.visible .payment-modal-content {
             transform: scale(1);
             opacity: 1;
        }
        .payment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
        }
        .payment-header .close-btn { font-size: 1.5rem; cursor: pointer; }
        .payment-header .title { font-size: 1.125rem; font-weight: 600; }
        .payment-content {
            padding: 1rem 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .amount-input-wrapper {
            display: flex;
            align-items: center;
            border-bottom: 2px solid #444;
            padding-bottom: 0.5rem;
            width: 100%;
        }
        .currency-symbol {
            font-size: 2.5rem;
            font-weight: 300;
            margin-right: 1rem;
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .amount-input {
            background: transparent;
            border: none;
            outline: none;
            font-size: 3rem;
            font-weight: 700;
            width: 100%;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        /* 隐藏数字输入框的箭头 */
        .amount-input::-webkit-outer-spin-button,
        .amount-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .amount-input[type=number] {
            -webkit-appearance: textfield;
            -moz-appearance: textfield;
            appearance: textfield;
        }
        .message-input {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(220, 20, 60, 0.3);
            border-radius: 1rem;
            width: 100%;
            padding: 1rem;
            margin-top: 1.5rem;
            color: #ffffff;
            outline: none;
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .message-input:focus {
            border-color: #DC143C;
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 20px rgba(220, 20, 60, 0.2);
            transform: translateY(-2px);
        }
        .message-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }
        .send-payment-btn {
            margin-top: 1.5rem;
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #DC143C, #B22222);
            color: #ffffff;
            font-size: 1.125rem;
            font-weight: 700;
            border-radius: 1rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(220, 20, 60, 0.3);
            position: relative;
            overflow: hidden;
        }
        .send-payment-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        .send-payment-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(220, 20, 60, 0.4);
        }
        .send-payment-btn:hover::before {
            left: 100%;
        }
        .send-payment-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        /* 红包/转账气泡样式 - 已修改 */
        .chat-message.red-packet-message, .chat-message.transfer-message {
            padding: 0;
            width: 200px;
            border-radius: 0.75rem;
            overflow: hidden;
            border: none;
            position: relative;
            z-index: 10; /* 确保在背景层之上 */
        }
        .chat-message.red-packet-message {
            background: linear-gradient(135deg, #8B0000, #DC143C, #B22222); /* 使用不透明背景 */
            border: 2px solid rgba(220, 20, 60, 0.3);
            box-shadow: 0 4px 12px rgba(220, 20, 60, 0.3);
        }
        .chat-message.transfer-message {
            background: linear-gradient(135deg, #2D3748, #4A5568, #374151); /* 使用不透明背景 */
            border: 2px solid rgba(229, 231, 235, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .payment-bubble-header {
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
            color: #FFFFFF; /* 确保文字在深色背景下可见 */
            font-weight: 500;
        }
        .payment-bubble-header i {
            font-size: 1.5rem;
            margin-right: 0.5rem;
        }
        .red-packet-message .payment-bubble-header i { color: #FF4444; } /* 红色图标 */
        .transfer-message .payment-bubble-header i { color: #E5E7EB; }

        .payment-bubble-body {
            padding: 0.125rem 0.75rem; /* 减小白色区域高度 */
            background-color: rgba(255, 255, 255, 0.95); /* 增加不透明度 */
            color: #374151;
            font-size: 0.65rem;
            backdrop-filter: blur(5px); /* 添加背景模糊效果 */
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .payment-bubble-amount {
            font-size: 1.125rem;
            font-weight: 700;
            margin-bottom: 0.125rem;
        }
        .payment-bubble-message {
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .red-packet-message .payment-bubble-message {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        .transfer-message .payment-bubble-amount,
        .transfer-message .payment-bubble-message {
            background: linear-gradient(90deg, #E5E7EB, #B0B0B0, #E5E7EB);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* 表情面板 (美化版) - V2.1 最终定位修复 */
        #sticker-panel {
            position: absolute; /* 保持 absolute，确保在手机框内 */
            bottom: 0;
            left: 50%;          /* 【【恢复】】使用 left: 50% 来定位中点 */
            width: 100%;        /* 【【修改】】宽度设为100%以适应手机框 */
            transform: translateX(-50%) translateY(100%); /* 【【核心】】同时保留水平居中(X)和垂直隐藏(Y) */
            
            /* 其他样式保持不变 */
            background: linear-gradient(135deg, rgba(44, 44, 46, 0.95), rgba(60, 60, 65, 0.95));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px 20px 0 0;
            z-index: 50;
            transition: transform 0.3s ease-out;
            max-height: 50%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
        }
        
        /* 确保表情面板的父容器有相对定位 */
        #wechat-chat-screen {
            position: relative;
        }
        
        .light-mode #sticker-panel {
            background: linear-gradient(135deg, rgba(248, 248, 248, 0.95), rgba(255, 255, 255, 0.95));
            border-top-color: rgba(0, 0, 0, 0.15);
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.1);
        }
        
        #sticker-panel.visible {
            transform: translateX(-50%) translateY(0); /* 【【核心】】显示时，只改变Y轴，保持X轴的居中 */
        }
        
        /* 表情面板标题栏 */
        #sticker-panel::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
        
        .light-mode #sticker-panel::before {
            background: rgba(0, 0, 0, 0.2);
        }
        
        #sticker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
            padding: 20px 16px 16px 16px;
            overflow-y: auto;
            flex-grow: 1;
            margin-top: 8px;
        }
        
        /* 自定义滚动条 */
        #sticker-grid::-webkit-scrollbar {
            width: 6px;
        }
        
        #sticker-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        #sticker-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .light-mode #sticker-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode #sticker-grid::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .sticker-item, .add-sticker-btn {
            width: 60px;
            height: 60px;
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 8px;
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            position: relative;
            overflow: hidden;
        }
        
        .sticker-item:hover, .add-sticker-btn:hover {
            transform: translateY(-4px) scale(1.05);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.15));
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .light-mode .sticker-item, .light-mode .add-sticker-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8), rgba(240, 240, 240, 0.6));
            border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode .sticker-item:hover, .light-mode .add-sticker-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(250, 250, 250, 0.8));
            border-color: rgba(0, 0, 0, 0.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        /* 淺色模式下的刪除按鈕樣式 */
        .light-mode .sticker-delete-btn {
            background: rgba(239, 68, 68, 0.8);
            border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-mode .sticker-delete-btn:hover {
            background: rgba(239, 68, 68, 1);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }
        
        .light-mode .sticker-delete-btn.active {
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
        }
        
        /* 淺色模式下的刪除確認彈窗樣式 */
        .light-mode .delete-confirm-modal {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
        }
        
        .light-mode .delete-confirm-modal h3 {
            color: #1f2937;
        }
        
        .light-mode .delete-confirm-modal p {
            color: #4b5563;
        }
        
        .light-mode .delete-confirm-btn.cancel {
            background: rgba(0, 0, 0, 0.05);
            color: #374151;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .light-mode .delete-confirm-btn.cancel:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        
        /* 浅色模式红包/转账样式 */
        .light-mode .chat-message.red-packet-message {
            background: linear-gradient(135deg, #FFE4E1, #FFC0CB, #FFB6C1); /* 浅色红包背景 */
            border: 2px solid rgba(220, 20, 60, 0.4);
            color: #8B0000;
        }
        
        .light-mode .chat-message.transfer-message {
            background: linear-gradient(135deg, #F7FAFC, #EDF2F7, #E2E8F0); /* 浅色转账背景 */
            border: 2px solid rgba(113, 128, 150, 0.4);
            color: #2D3748;
        }
        
        .light-mode .red-packet-message .payment-bubble-header,
        .light-mode .transfer-message .payment-bubble-header {
            color: #2D3748; /* 浅色模式下使用深色文字 */
        }
        
        .light-mode .red-packet-message .payment-bubble-header i {
            color: #DC143C;
        }
        
        .light-mode .transfer-message .payment-bubble-header i {
            color: #4A5568;
        }
        
        /* 夜间模式下红包图标样式 */
        .dark-mode .red-packet-message .payment-bubble-header i {
            color: #FF6B6B; /* 夜间模式红包图标 - 亮红色 */
        }
        
        .light-mode .red-packet-message .payment-bubble-message {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* 浅色模式红包/转账界面样式 */
        .light-mode .payment-modal-content {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            color: #374151;
            border: 1px solid rgba(220, 20, 60, 0.2);
        }
        
        .light-mode .currency-symbol {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .light-mode .amount-input {
            background: linear-gradient(90deg, #DC143C, #B22222, #8B0000);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .light-mode .message-input {
            background: rgba(220, 20, 60, 0.05);
            border: 2px solid rgba(220, 20, 60, 0.2);
            color: #374151;
        }
        
        .light-mode .message-input:focus {
            border-color: #DC143C;
            background: rgba(220, 20, 60, 0.08);
            box-shadow: 0 0 20px rgba(220, 20, 60, 0.15);
        }
        
        .light-mode .message-input::placeholder {
            color: rgba(55, 65, 81, 0.6);
        }
        
        .light-mode .send-payment-btn {
            background: linear-gradient(135deg, #DC143C, #B22222);
            box-shadow: 0 4px 15px rgba(220, 20, 60, 0.2);
        }
        
        .light-mode .send-payment-btn:hover {
            box-shadow: 0 8px 25px rgba(220, 20, 60, 0.3);
        }

        /* ====== 红包/转账已收取状态样式 ====== */
        
        /* 已收取的红包样式 */
        .red-packet-message.claimed {
            opacity: 0.6;
            background: linear-gradient(135deg, rgba(220, 20, 60, 0.1), rgba(139, 0, 0, 0.1));
            border: 1px solid rgba(220, 20, 60, 0.3);
            cursor: not-allowed;
        }
        
        .red-packet-message.claimed .payment-bubble-body {
            background: rgba(139, 0, 0, 0.1);
            color: rgba(220, 20, 60, 0.7);
        }
        
        .red-packet-message.claimed .payment-bubble-body::after {
            content: " (已领取)";
            font-size: 0.75rem;
            color: rgba(220, 20, 60, 0.6);
        }
        
        /* 已收取的转账样式 */
        .transfer-message.claimed {
            opacity: 0.6;
            background: linear-gradient(135deg, rgba(75, 85, 99, 0.1), rgba(55, 65, 81, 0.1));
            border: 1px solid rgba(75, 85, 99, 0.3);
            cursor: not-allowed;
        }
        
        .transfer-message.claimed .payment-bubble-body {
            background: rgba(75, 85, 99, 0.1);
            color: rgba(75, 85, 99, 0.7);
        }
        
        .transfer-message.claimed .payment-bubble-body::after {
            content: " (已接收)";
            font-size: 0.75rem;
            color: rgba(75, 85, 99, 0.6);
        }
        
        /* 浅色模式下的已收取状态样式 */
        .light-mode .red-packet-message.claimed {
            background: linear-gradient(135deg, rgba(220, 20, 60, 0.05), rgba(248, 249, 250, 0.9));
            border: 1px solid rgba(220, 20, 60, 0.2);
        }
        
        .light-mode .red-packet-message.claimed .payment-bubble-body {
            background: rgba(220, 20, 60, 0.05);
            color: rgba(139, 0, 0, 0.7);
        }
        
        .light-mode .transfer-message.claimed {
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.05), rgba(248, 249, 250, 0.9));
            border: 1px solid rgba(55, 65, 81, 0.2);
        }
        
        .light-mode .transfer-message.claimed .payment-bubble-body {
            background: rgba(55, 65, 81, 0.05);
            color: rgba(55, 65, 81, 0.7);
        }
        
        .sticker-item img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            transition: transform 0.3s ease;
        }
        
        .sticker-item:hover img {
            transform: scale(1.1);
        }
        
        .add-sticker-btn {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(147, 197, 253, 0.1));
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        .add-sticker-btn:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(147, 197, 253, 0.2));
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        .add-sticker-btn i {
            font-size: 2rem;
            color: #3b82f6;
            transition: all 0.3s ease;
        }
        
        .add-sticker-btn:hover i {
            transform: rotate(90deg) scale(1.1);
            color: #1d4ed8;
        }
        
        /* 表情包面板动画效果 */
        @keyframes stickerFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .sticker-item {
            animation: stickerFadeIn 0.4s ease-out;
        }
        
        .sticker-item:nth-child(1) { animation-delay: 0.1s; }
        .sticker-item:nth-child(2) { animation-delay: 0.15s; }
        .sticker-item:nth-child(3) { animation-delay: 0.2s; }
        .sticker-item:nth-child(4) { animation-delay: 0.25s; }
        .sticker-item:nth-child(5) { animation-delay: 0.3s; }
        .sticker-item:nth-child(6) { animation-delay: 0.35s; }
        
        /* 表情包面板显示/隐藏动画 */
        #sticker-panel.visible {
            transform: translateX(-50%) translateY(0);
        }
        
        /* 刪除按鈕樣式 */
        .sticker-delete-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            background: rgba(239, 68, 68, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .sticker-delete-btn:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }
        
        .sticker-delete-btn i {
            color: white;
            font-size: 16px;
        }
        
        .sticker-delete-btn.active {
            background: rgba(239, 68, 68, 1);
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.3);
        }
        
        /* 刪除模式下的表情包樣式 */
        .sticker-item.delete-mode {
            position: relative;
        }
        
        .sticker-item.delete-mode::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(239, 68, 68, 0.2);
            border-radius: 16px;
            z-index: 1;
        }
        
        .sticker-item.delete-mode.selected::before {
            background: rgba(239, 68, 68, 0.6);
            border: 2px solid rgba(239, 68, 68, 0.8);
        }
        
        .sticker-item.delete-mode .sticker-checkbox {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: white;
            border: 2px solid rgba(239, 68, 68, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .sticker-item.delete-mode .sticker-checkbox.checked {
            background: rgba(239, 68, 68, 0.9);
            border-color: rgba(239, 68, 68, 1);
        }
        
        .sticker-item.delete-mode .sticker-checkbox.checked::after {
            content: '✓';
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* 刪除確認彈窗樣式 */
        .delete-confirm-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 24px;
            z-index: 10000;
            display: none;
            flex-direction: column;
            align-items: center;
            min-width: 280px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .delete-confirm-modal.visible {
            display: flex;
        }
        
        .delete-confirm-modal h3 {
            color: white;
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 600;
        }
        
        .delete-confirm-modal p {
            color: rgba(255, 255, 255, 0.8);
            margin: 0 0 24px 0;
            text-align: center;
            line-height: 1.5;
        }
        
        .delete-confirm-buttons {
            display: flex;
            gap: 12px;
            width: 100%;
        }
        
        .delete-confirm-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .delete-confirm-btn.cancel {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .delete-confirm-btn.cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .delete-confirm-btn.confirm {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .delete-confirm-btn.confirm:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
        }
        
        /* 响应式设计 */
        @media (max-width: 480px) {
            #sticker-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                gap: 10px;
                padding: 16px 12px 12px 12px;
            }
            
            .sticker-item, .add-sticker-btn {
                width: 70px;
                height: 70px;
            }
        }

        /* V7.0 新增样式 */
        .wechat-content-view {
            padding: 0.5rem;
            height: 100%;
            overflow-y: auto;
        }
        /* 动态 (Moments) */
        .moment-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            animation: fadeIn 0.5s ease-out;
        }
        .light-mode .moment-card {
            background-color: #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .moment-image {
            width: 100%;
            height: 200px;
            border-radius: 0.75rem;
            background-color: rgba(255,255,255,0.1);
            background-size: cover;
            background-position: center;
            margin-top: 0.75rem;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .moment-image:hover {
            border-color: rgba(59, 130, 246, 0.5);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }
        
        .moment-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }
        
        .moment-image:hover::before {
            transform: translateX(100%);
        }
        .moment-actions {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 0.75rem;
            padding-top: 0.5rem;
        }
        .light-mode .moment-actions { border-color: rgba(0,0,0,0.08); }
        .moment-action-btn {
            transition: color 0.2s, transform 0.2s;
        }
        .moment-action-btn:active {
            transform: scale(1.2);
        }
        .moment-action-btn.liked {
            color: #ef4444;
        }

        /* 日记 (Diary) */
        #wechat-diary-container {
            background-image: url('https://www.transparenttextures.com/patterns/45-degree-fabric-dark.png');
            background-color: #fffcfc;
            color: #4a4a4a;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Noto Serif SC', serif;
        }
        .dark-mode #wechat-diary-container {
             background-image: url('https://www.transparenttextures.com/patterns/45-degree-fabric-dark.png');
             background-color: #292929;
             color: #d1d5db;
        }
        .diary-entry {
            padding: 1.5rem;
            border-bottom: 1px dashed #c7c1b6;
            animation: fadeIn 0.5s ease-out;
        }
        .dark-mode .diary-entry {
            border-bottom-color: #4a4a4a;
        }
        .diary-date {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        .diary-content {
            line-height: 1.8;
        }




        


        /* 計劃 (Plan) - 高级磨砂质感暗黑风格 */
        .plan-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 1.5rem 1.25rem;
            margin-bottom: 1.25rem;
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.95) 0%, 
                rgba(30, 41, 59, 0.9) 50%, 
                rgba(15, 23, 42, 0.95) 100%);
            backdrop-filter: blur(25px) saturate(1.2);
            border: 1px solid rgba(59, 130, 246, 0.15);
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 4px 16px rgba(15, 23, 42, 0.3),
                inset 0 1px 0 rgba(59, 130, 246, 0.1),
                inset 0 -1px 0 rgba(15, 23, 42, 0.8);
            animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .plan-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.6) 20%, 
                rgba(59, 130, 246, 0.8) 50%, 
                rgba(59, 130, 246, 0.6) 80%, 
                transparent 100%);
            opacity: 0.7;
            transition: opacity 0.4s ease;
        }
        
        .plan-item::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(
                circle at 50% 0%, 
                rgba(59, 130, 246, 0.03) 0%, 
                transparent 70%
            );
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
        }
        
        .plan-item.expanded::after {
            opacity: 1;
        }
        

        
        .plan-item:hover {
            transform: translateY(-6px) scale(1.02);
            border-color: rgba(59, 130, 246, 0.25);
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.5),
                0 8px 24px rgba(15, 23, 42, 0.4),
                inset 0 1px 0 rgba(59, 130, 246, 0.2),
                inset 0 -1px 0 rgba(15, 23, 42, 0.9);
        }
        
        .plan-item:hover::after {
            opacity: 1;
        }
        
        .light-mode .plan-item {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.95) 0%, 
                rgba(241, 245, 249, 0.9) 50%, 
                rgba(248, 250, 252, 0.95) 100%);
            border: 1px solid rgba(59, 130, 246, 0.2);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.1),
                0 4px 16px rgba(15, 23, 42, 0.05);
        }
        
        .light-mode .plan-item:hover {
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.15),
                0 8px 24px rgba(15, 23, 42, 0.08);
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        .light-mode .plan-item::before {
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.5) 20%, 
                rgba(59, 130, 246, 0.7) 50%, 
                rgba(59, 130, 246, 0.5) 80%, 
                transparent 100%);
        }
        
        .light-mode .plan-item::after {
            background: radial-gradient(
                circle at 50% 0%, 
                rgba(59, 130, 246, 0.05) 0%, 
                transparent 70%
            );
        }
        
        .light-mode .plan-item.expanded::after {
            opacity: 1;
        }
        
        /* 浅色模式下的展开状态 */
        .light-mode .plan-item.expanded {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.98) 0%, 
                rgba(241, 245, 249, 0.95) 50%, 
                rgba(248, 250, 252, 0.98) 100%);
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow: 
                0 24px 64px rgba(0, 0, 0, 0.15),
                0 12px 32px rgba(15, 23, 42, 0.08);
        }
        
        .light-mode .plan-item.expanded::before {
            opacity: 1;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.8) 20%, 
                rgba(59, 130, 246, 1) 50%, 
                rgba(59, 130, 246, 0.8) 80%, 
                transparent 100%);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.4);
        }
        
        /* ======================================================== */
        /* ====== "创建新约定"模态框 V2.0 (风格统一) ====== */
        /* ======================================================== */

        /* 模态框遮罩层 (复用现有样式，确保存在) */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: none; /* JS控制显示 */
            align-items: center;
            justify-content: center;
            z-index: 9000;
            padding: 1rem;
        }
        .modal-overlay.visible {
            display: flex;
        }

        /* 模态框内容区域 (全新样式) */
        #plan-modal .modal-content {
            position: relative;
            width: 100%;
            max-width: 360px;
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1.5rem;
            padding: 2rem 1.5rem 1.5rem 1.5rem;
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            overflow: hidden;
            color: #f3f4f6; /* 默认文字颜色 */
            font-family: 'Noto Serif SC', serif;
        }

        /* 装饰性元素 */
        #plan-modal .modal-content::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(220, 38, 38, 0.5), transparent);
        }
        #plan-modal .modal-content::after {
            content: '🎴';
            position: absolute;
            top: 1rem; right: 1.5rem;
            font-size: 2.5rem;
            color: rgba(255,255,255,0.05);
            transform: rotate(15deg);
        }

        /* 头部 */
        #plan-modal .modal-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        #plan-modal .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f3f4f6;
            letter-spacing: 0.05em;
        }

        /* 表单组 */
        #plan-modal .form-group {
            margin-bottom: 1.5rem;
        }
        #plan-modal .form-label {
            display: flex;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: rgba(255,255,255,0.6);
            margin-bottom: 0.75rem;
        }
        #plan-modal .form-label i {
            margin-right: 0.5rem;
            color: #dc2626; /* 统一的红色图标 */
        }

        /* 输入框、选择框、文本域 */
        #plan-modal .form-input, 
        #plan-modal .form-select, 
        #plan-modal .form-textarea {
            width: 100%;
            background-color: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            color: #f3f4f6;
            font-size: 0.9rem;
            transition: all 0.2s ease-in-out;
        }
        #plan-modal .form-input::placeholder, 
        #plan-modal .form-textarea::placeholder {
            color: rgba(255,255,255,0.3);
        }
        #plan-modal .form-input:focus, 
        #plan-modal .form-select:focus, 
        #plan-modal .form-textarea:focus {
            outline: none;
            border-color: rgba(220, 38, 38, 0.5);
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.15);
            background-color: rgba(0,0,0,0.2);
        }
        #plan-modal .form-textarea {
            resize: none;
            height: 80px;
        }

        /* 自定义下拉箭头 */
        #plan-modal .form-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.75rem center;
            background-repeat: no-repeat;
            background-size: 1.25em 1.25em;
        }

        /* 底部按钮 */
        #plan-modal .modal-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 1rem;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        #plan-modal .btn {
            padding: 0.6rem 1.25rem;
            border-radius: 0.75rem;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease-in-out;
            border: none;
            cursor: pointer;
        }
        #plan-modal .btn-ghost {
            background: transparent;
            color: rgba(255,255,255,0.6);
        }
        #plan-modal .btn-ghost:hover {
            color: #fff;
            background-color: rgba(255,255,255,0.05);
        }
        #plan-modal .btn-primary {
            background: linear-gradient(135deg, #b91c1c, #dc2626);
            color: #fff;
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.2);
            display: flex;
            align-items: center;
        }
        #plan-modal .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(220, 38, 38, 0.3);
        }
        #plan-modal .btn-primary i {
            margin-right: 0.5rem;
        }

        .plan-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-size: 1.25rem;
        }
        /* 状态标签美化 - 更精致的样式 */
        .plan-item .status-tag {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            letter-spacing: 0.3px;
            font-size: 0.75rem;
            padding: 0.375rem 0.75rem;
            border-radius: 20px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .plan-item .status-tag:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.4);
        }
        
        /* 状态标签图标和文字优化 */
        .plan-item .status-tag i {
            font-size: 0.75rem;
            opacity: 0.9;
        }
        
        .plan-item .status-tag span {
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.2px;
        }
        
        /* 展开状态的卡片样式 */
        .plan-item.expanded {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.98) 0%, 
                rgba(30, 41, 59, 0.95) 50%, 
                rgba(15, 23, 42, 0.98) 100%);
            border-color: rgba(59, 130, 246, 0.3);
            transform: translateY(-8px) scale(1.03);
            box-shadow: 
                0 24px 64px rgba(0, 0, 0, 0.6),
                0 12px 32px rgba(15, 23, 42, 0.5),
                inset 0 1px 0 rgba(59, 130, 246, 0.25),
                inset 0 -1px 0 rgba(15, 23, 42, 0.95);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .plan-item.expanded::before {
            opacity: 1;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.8) 20%, 
                rgba(59, 130, 246, 1) 50%, 
                rgba(59, 130, 246, 0.8) 80%, 
                transparent 100%);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.4);
        }
        
        .plan-item.expanded::after {
            opacity: 1;
            background: radial-gradient(
                circle at 50% 0%, 
                rgba(59, 130, 246, 0.08) 0%, 
                transparent 70%
            );
        }
        
        /* 展开详情区域的动画 */
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .plan-status-agreed { background-color: #3b82f6; color: white; }
        .plan-status-inprogress { background-color: #f59e0b; color: white; }
        .plan-status-completed { background-color: #10b981; color: white; }
        

        

        
        .plan-details {
            max-height: 0;
            overflow: hidden;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.6) 0%, 
                rgba(30, 41, 59, 0.4) 100%);
            border-radius: 0 0 16px 16px;
            margin: 0 -1.25rem -1.5rem -1.25rem;
            padding: 0;
            border-top: 1px solid rgba(59, 130, 246, 0.15);
            backdrop-filter: blur(20px);
            position: relative;
            box-shadow: inset 0 4px 20px rgba(15, 23, 42, 0.3);
            transform-origin: top center;
        }
        
        .plan-item.expanded .plan-details {
            max-height: 800px;
            padding: 2.5rem 1.5rem 2rem 1.5rem;
            transform: scaleY(1);
        }
        
        .plan-details::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.6) 20%, 
                rgba(59, 130, 246, 0.8) 50%, 
                rgba(59, 130, 246, 0.6) 80%, 
                transparent 100%);
            border-radius: 0.5px;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
        }
        
        .light-mode .plan-details {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.6) 0%, 
                rgba(241, 245, 249, 0.4) 100%);
            border-top: 1px solid rgba(59, 130, 246, 0.2);
            box-shadow: inset 0 4px 20px rgba(15, 23, 42, 0.1);
        }
        
        .light-mode .plan-details::before {
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(59, 130, 246, 0.4) 20%, 
                rgba(59, 130, 246, 0.6) 50%, 
                rgba(59, 130, 246, 0.4) 80%, 
                transparent 100%);
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.2);
        }
        

        
        /* 约定卡片字体优化 */
        .plan-item .plan-title {
            font-size: 0.875rem;
            font-weight: 500;
            line-height: 1.4;
            letter-spacing: 0.2px;
        }
        
        .plan-item .plan-character {
            font-size: 0.75rem;
            font-weight: 500;
            line-height: 1.3;
            letter-spacing: 0.3px;
        }
        
        .plan-item .plan-date {
            font-size: 0.75rem;
            font-weight: 400;
            line-height: 1.3;
            letter-spacing: 0.2px;
        }
        
        .plan-item .plan-details-text {
            font-size: 0.75rem;
            font-weight: 400;
            line-height: 1.5;
            letter-spacing: 0.1px;
        }
        
        /* 时间信息区域 - 更精致的样式 */
        .time-info-section {
            margin-bottom: 2rem;
        }
        
        .info-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(59, 130, 246, 0.1);
            transition: all 0.3s ease;
        }
        
        .info-row:last-child {
            border-bottom: none;
        }
        
        .info-row:hover {
            background: rgba(59, 130, 246, 0.05);
            border-radius: 8px;
            padding-left: 0.75rem;
            padding-right: 0.75rem;
            margin-left: -0.75rem;
            margin-right: -0.75rem;
        }
        
        .info-label {
            display: flex;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: rgba(148, 163, 184, 0.9);
            letter-spacing: 0.3px;
        }
        
        .info-value {
            font-size: 0.875rem;
            font-weight: 400;
            color: rgba(226, 232, 240, 0.9);
            letter-spacing: 0.2px;
        }
        
        .status-badge {
            padding: 0.375rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.3px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.2);
            color: rgba(148, 163, 184, 0.9);
            backdrop-filter: blur(10px);
        }
        
        .info-label i {
            font-size: 1rem;
            opacity: 0.7;
            margin-right: 0.5rem;
        }
        
        .info-value {
            font-size: 0.875rem;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.9);
            text-align: right;
            max-width: 60%;
        }
        
        .status-badge {
            padding: 0.375rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        /* 操作按钮区域 - 更高级的样式 */
        .action-buttons-section {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(59, 130, 246, 0.1);
        }
        
        /* 高级按钮样式 - 磨砂质感 */
        .luxury-btn {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.9) 0%, 
                rgba(30, 41, 59, 0.8) 100%);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            color: rgba(226, 232, 240, 0.9);
            font-size: 0.875rem;
            font-weight: 500;
            letter-spacing: 0.3px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            overflow: hidden;
            min-width: 120px;
        }
        
        .luxury-btn:hover {
            transform: translateY(-2px);
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(59, 130, 246, 0.1);
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.95) 0%, 
                rgba(30, 41, 59, 0.9) 100%);
        }
        
        .luxury-btn:active {
            transform: translateY(0);
        }
        
        .luxury-btn .btn-content {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            z-index: 2;
            position: relative;
        }
        
        .luxury-btn .btn-glow {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(59, 130, 246, 0.1) 0%, 
                transparent 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 12px;
        }
        
        .luxury-btn:hover .btn-glow {
            opacity: 1;
        }
        
        /* 编辑按钮特殊样式 */
        .edit-plan-btn {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.9) 0%, 
                rgba(30, 41, 59, 0.8) 100%);
            border-color: rgba(59, 130, 246, 0.25);
        }
        
        .edit-plan-btn:hover {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.95) 0%, 
                rgba(30, 41, 59, 0.9) 100%);
            border-color: rgba(59, 130, 246, 0.4);
        }
        
        /* 删除按钮特殊样式 */
        .delete-plan-btn {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.9) 0%, 
                rgba(30, 41, 59, 0.8) 100%);
            border-color: rgba(239, 68, 68, 0.25);
        }
        
        .delete-plan-btn:hover {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.95) 0%, 
                rgba(30, 41, 59, 0.9) 100%);
            border-color: rgba(239, 68, 68, 0.4);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(239, 68, 68, 0.1);
        }
        
        /* 浅色模式适配 */
        .light-mode .info-label {
            color: rgba(71, 85, 105, 0.8);
        }
        
        .light-mode .info-value {
            color: rgba(15, 23, 42, 0.9);
        }
        
        .light-mode .status-badge {
            background: rgba(248, 250, 252, 0.8);
            border-color: rgba(59, 130, 246, 0.3);
            color: rgba(71, 85, 105, 0.8);
        }
        
        .light-mode .luxury-btn {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.9) 0%, 
                rgba(241, 245, 249, 0.8) 100%);
            border-color: rgba(59, 130, 246, 0.25);
            color: rgba(15, 23, 42, 0.9);
        }
        
        .light-mode .luxury-btn:hover {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.95) 0%, 
                rgba(241, 245, 249, 0.9) 100%);
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.1),
                0 4px 12px rgba(59, 130, 246, 0.08);
        }
        
        .light-mode .edit-plan-btn {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.9) 0%, 
                rgba(241, 245, 249, 0.8) 100%);
            border-color: rgba(59, 130, 246, 0.25);
        }
        
        .light-mode .delete-plan-btn {
            background: linear-gradient(135deg, 
                rgba(248, 250, 252, 0.9) 0%, 
                rgba(241, 245, 249, 0.8) 100%);
            border-color: rgba(239, 68, 68, 0.25);
        }
        
        /* ============================================= */
        /* V7.1 UI 升级样式 (动态 & 日记) */
        /* ============================================= */

        /* --- 新增：动态 (Moments) 整体 UI --- */
        #moments-header {
            transition: transform 0.3s ease;
        }
        #moments-header:hover {
            transform: scale(1.02);
        }

        /* 朋友圈背景图片样式 */
        #moments-cover {
            z-index: 25; /* 提高z-index，确保在渐变遮罩之上 */
            position: relative;
            min-height: 192px; /* 确保有足够的高度 */
            width: 100%; /* 确保宽度填满 */
        }

        /* 渐变遮罩样式 */
        #moments-header .bg-gradient-to-t {
            z-index: 20;
            pointer-events: none; /* 让渐变遮罩不阻挡点击事件 */
        }

        #moments-user-name {
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            color: white;
            font-weight: bold;
        }

        #moments-user-avatar {
            background-color: #4a4a4a;
            transition: transform 0.3s ease;
            z-index: 30; /* 确保头像在背景之上 */
        }
        #moments-user-avatar:hover {
            transform: scale(1.05);
        }
        
        /* 头像信息容器样式 */
        #moments-user-info {
            position: absolute;
            z-index: 30; /* 确保头像信息在背景之上 */
        }

        /* 朋友圈背景图片样式 - 确保不被日夜间模式覆盖 */
        #moments-cover {
            background-image: var(--moments-cover-image, url('https://placehold.co/375x192/333/fff?text=Cover'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 确保日夜间模式切换后背景图片仍然显示 */
        .dark-mode #moments-cover,
        .light-mode #moments-cover {
            background-image: var(--moments-cover-image, url('https://placehold.co/375x192/333/fff?text=Cover'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 强制设置默认背景图片，确保始终有图片显示 */
        #moments-cover:not([style*="background-image"]) {
            background-image: url('https://placehold.co/375x192/333/fff?text=Cover');
        }

        /* 朋友圈头像样式 - 确保不被日夜间模式覆盖 */
        #moments-user-avatar {
            background-image: var(--moments-avatar-image, url('https://placehold.co/128x128/777/FFF?text=Me'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 确保日夜间模式切换后头像仍然显示 */
        .dark-mode #moments-user-avatar,
        .light-mode #moments-user-avatar {
            background-image: var(--moments-avatar-image, url('https://placehold.co/128x128/777/FFF?text=Me'));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 动态卡片(新) */
        .moment-card {
            border: none;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            padding: 0.75rem; /* 内边距统一 */
        }


        
        /* 朋友圈头像点击样式 */
        .moment-card .w-10.h-10 {
            transition: transform 0.2s;
        }
        .moment-card .w-10.h-10:hover {
            transform: scale(1.1);
        }
        .light-mode .moment-card {
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
        }
        .moment-card .flex.items-start .font-bold {
            font-size: 1.05em; /* 名字稍大一些 */
        }
        .moment-card .whitespace-pre-wrap {
            font-size: 1em;
            line-height: 1.6;
        }

        /* 点赞和评论样式 */
        .moment-action-btn {
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .moment-action-btn:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        .moment-action-btn.text-blue-500 {
            color: #3b82f6;
        }
        
        .moment-action-btn.text-blue-500:hover {
            background-color: rgba(59, 130, 246, 0.15);
        }
        
        /* 评论样式 - 支持日间夜间模式 */
        .comment-bubble {
            background-color: rgba(249, 250, 251, 0.8);
            border: 1px solid rgba(229, 231, 235, 0.5);
            transition: all 0.2s ease;
            position: relative;
        }
        
        .comment-bubble:hover {
            background-color: rgba(243, 244, 246, 0.9);
            border-color: rgba(209, 213, 219, 0.7);
        }
        
        .comment-text {
            color: #374151;
        }
        
        /* 日间模式评论样式 */
        .light-mode .comment-bubble {
            background-color: rgba(249, 250, 251, 0.9);
            border: 1px solid rgba(229, 231, 235, 0.7);
        }
        
        .light-mode .comment-bubble:hover {
            background-color: rgba(243, 244, 246, 1);
            border-color: rgba(209, 213, 219, 0.8);
        }
        
        .light-mode .comment-text {
            color: #374151;
        }
        
        /* 夜间模式评论样式 */
        .dark-mode .comment-bubble {
            background-color: rgba(55, 65, 81, 0.3);
            border: 1px solid rgba(75, 85, 99, 0.4);
        }
        
        .dark-mode .comment-bubble:hover {
            background-color: rgba(55, 65, 81, 0.5);
            border-color: rgba(75, 85, 99, 0.6);
        }
        
        .dark-mode .comment-text {
            color: #e5e7eb;
        }

        /* 评论按钮容器 - 浮动在右上角 */
        .comment-buttons {
            position: absolute !important;
            top: 0.25rem !important;
            right: 0.25rem !important;
            background: rgba(0, 0, 0, 0.7) !important;
            border-radius: 0.375rem !important;
            padding: 0.25rem !important;
            backdrop-filter: blur(4px) !important;
            z-index: 10 !important;
            margin: 0 !important;
        }
        
        /* 日间模式按钮容器背景 */
        .light-mode .comment-buttons {
            background: rgba(255, 255, 255, 0.9) !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
        }

        /* 评论编辑和删除按钮样式 */
        .comment-edit-btn,
        .comment-delete-btn {
            opacity: 0;
            transition: all 0.2s ease;
            padding: 0.25rem !important;
            border-radius: 0.25rem !important;
        }

        .comment-bubble.show-buttons .comment-buttons {
            opacity: 1 !important;
        }
        
        .comment-bubble.show-buttons .comment-edit-btn,
        .comment-bubble.show-buttons .comment-delete-btn {
            opacity: 1 !important;
        }

        .comment-edit-btn:hover {
            background-color: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
        }

        .comment-delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }

        /* 夜间模式下的按钮悬停效果 */
        .dark-mode .comment-edit-btn:hover {
            background-color: rgba(59, 130, 246, 0.2);
        }

        .dark-mode .comment-delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.2);
        }

        /* --- 新增：日记 (Diary) "书架" UI - 优化质感 --- */
        #diary-bookshelf .diary-book-item {
            aspect-ratio: 3 / 4;
            border-radius: 0.75rem 1rem 1rem 0.75rem;
            padding: 1.2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            color: white;
            cursor: pointer;
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* 日间模式日记书架项目样式 */
        .light-mode #diary-bookshelf .diary-book-item {
            color: #2c2c2c;
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.15),
                0 4px 12px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .light-mode #diary-bookshelf .diary-book-item::before {
            background: 
                linear-gradient(135deg, 
                    rgba(0, 0, 0, 0.05) 0%, 
                    rgba(0, 0, 0, 0.15) 50%, 
                    rgba(0, 0, 0, 0.25) 100%);
        }

        #diary-bookshelf .diary-book-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(135deg, 
                    rgba(0, 0, 0, 0.1) 0%, 
                    rgba(0, 0, 0, 0.3) 50%, 
                    rgba(0, 0, 0, 0.5) 100%);
            pointer-events: none;
            z-index: 1;
        }

        #diary-bookshelf .diary-book-item:hover {
            transform: translateY(-12px) rotate(3deg) scale(1.02);
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.4),
                0 8px 20px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        /* 日间模式日记书架项目悬停效果 */
        .light-mode #diary-bookshelf .diary-book-item:hover {
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.2),
                0 8px 20px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(0, 0, 0, 0.08);
        }

        .diary-book-item-title {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            font-size: 1.3rem;
            font-weight: 600;
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 1px 2px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 2;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* 日间模式日记书架标题样式 */
        .light-mode .diary-book-item-title {
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .diary-book-item-title:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.02);
        }

        /* 日间模式日记书架标题悬停效果 */
        .light-mode .diary-book-item-title:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .diary-book-item-title.editing {
            background: rgba(255, 255, 255, 0.15);
            outline: 2px solid rgba(255, 255, 255, 0.3);
            outline-offset: 2px;
        }

        /* 日间模式日记书架标题编辑状态 */
        .light-mode .diary-book-item-title.editing {
            background: rgba(0, 0, 0, 0.15);
            outline: 2px solid rgba(0, 0, 0, 0.3);
        }

        .diary-book-item-title input {
            background: transparent;
            border: none;
            color: inherit;
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            text-align: center;
            width: 100%;
            outline: none;
            text-shadow: inherit;
        }

        .diary-book-item-author {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            font-size: 0.85rem;
            align-self: flex-end;
            font-style: italic;
            text-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.8),
                0 1px 2px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 2;
            opacity: 0.9;
        }

        /* 日间模式日记书架作者样式 */
        .light-mode .diary-book-item-author {
            text-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* --- 新增：日记本"翻页书" UI --- */
        .book-container {
            position: relative;
            width: 90vw;
            height: 70vh;
            perspective: 2500px;
        }
        .book {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(10deg) rotateY(0deg);
            transition: transform 1s ease;
        }
        .book:hover {
            transform: rotateX(0deg) rotateY(0deg);
        }

        /* 旧的展开书本样式已删除 */

        /* 旧的展开书本样式已删除 */

        /* 旧的展开书本样式已删除 */
        
        /* 日记本封面编辑按钮样式 - 优化质感 */
        .diary-cover-edit-btn {
            position: absolute;
            top: 0.8rem;
            right: 0.8rem;
            width: 1.76rem;
            height: 1.76rem;
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.7) 0%, 
                rgba(0, 0, 0, 0.8) 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
            backdrop-filter: blur(8px);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .diary-book-item:hover .diary-cover-edit-btn {
            opacity: 1;
            transform: scale(1.05);
        }

        .diary-cover-edit-btn:hover {
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.8) 0%, 
                rgba(0, 0, 0, 0.9) 100%);
            transform: scale(1.1);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .diary-cover-edit-btn i {
            font-size: 1.1rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 日记本内页横幅更换按钮样式 - 始终可见 */
        #change-diary-banner-btn {
            opacity: 1 !important;
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.8) 0%, 
                rgba(0, 0, 0, 0.9) 100%);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #change-diary-banner-btn:hover {
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.9) 0%, 
                rgba(0, 0, 0, 1) 100%);
            transform: scale(1.1);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* 单页日记本样式 - 优化为纸张质感 */
        .diary-single-page-container {
            width: 90vw;
            max-width: 400px;
            height: 80vh;
            max-height: 600px;
        }

        .diary-single-page {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            border-radius: 16px;
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.25),
                0 4px 12px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* 封面样式 - 支持日夜间模式 */
        .diary-cover {
            background: linear-gradient(145deg, 
                #2c2c2c 0%, 
                #404040 25%, 
                #505050 50%, 
                #404040 75%, 
                #2c2c2c 100%);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 图片裁剪模态框样式 */
        #image-cropper-modal {
            z-index: 16000;
        }

        #cropper-container {
            position: relative;
            min-height: 300px;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cropper-image {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
        }

        #crop-box {
            position: absolute;
            border: 2px solid #007bff;
            background: rgba(0, 123, 255, 0.1);
            cursor: move;
            z-index: 10;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
        }

        #crop-box:hover {
            border-color: #0056b3;
            background: rgba(0, 123, 255, 0.2);
        }

        .diary-cover {
            color: #f0f0f0;
            padding: 2.5rem 2rem;
            text-align: center;
            border-radius: 16px 16px 0 0;
            position: relative;
            z-index: 2;
            box-shadow: 
                inset 0 2px 4px rgba(255, 255, 255, 0.1),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        /* 日间模式封面样式 */
        .light-mode .diary-cover {
            background: linear-gradient(145deg, 
                #f8f9fa 0%, 
                #e9ecef 25%, 
                #404040 50%, 
                #e9ecef 75%, 
                #f8f9fa 100%);
            color: #2c2c2c;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.05),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            border-bottom: 2px solid rgba(0, 0, 0, 0.1);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .light-mode .diary-cover::before {
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 0, 0, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 0, 0, 0.02) 0%, transparent 50%);
        }

        .diary-cover::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        .diary-cover h2 {
            font-size: 1.6rem;
            margin-bottom: 0.8rem;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 0.5px;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            transition: text-shadow 0.3s ease;
        }

        .diary-cover p {
            font-size: 1rem;
            opacity: 0.9;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            transition: text-shadow 0.3s ease;
        }

        /* 日间模式文字阴影 */
        .light-mode .diary-cover h2 {
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .light-mode .diary-cover p {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        }

        /* 编辑状态样式 */
        .diary-cover h2.editing,
        .diary-cover p.editing {
            cursor: text;
        }

        .diary-cover h2:hover,
        .diary-cover p:hover {
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        .cover-title-edit-input,
        .cover-author-edit-input {
            background: rgba(255, 255, 255, 0.95) !important;
            color: #333 !important;
            border: 2px solid #4ecdc4 !important;
            border-radius: 6px !important;
            padding: 8px 12px !important;
            font-size: inherit !important;
            font-weight: inherit !important;
            text-align: center !important;
            width: 90% !important;
            outline: none !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            transition: all 0.3s ease !important;
        }

        /* 日间模式编辑输入框样式 */
        .light-mode .cover-title-edit-input,
        .light-mode .cover-author-edit-input {
            background: rgba(255, 255, 255, 0.98) !important;
            color: #2c2c2c !important;
            border: 2px solid #4ecdc4 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
        }

        .cover-title-edit-input {
            font-size: 1.6rem !important;
            font-weight: 600 !important;
            padding: 8px 12px !important;
        }

        .cover-author-edit-input {
            font-size: 1rem !important;
            font-weight: 500 !important;
            padding: 6px 10px !important;
            width: 80% !important;
        }

        /* 内页样式 - 真实纸张质感 */
        .diary-pages {
            flex: 1;
            background: 
                linear-gradient(135deg, #fefefe 0%, #f8f8f8 100%);
            padding: 2.5rem;
            overflow-y: auto;
            position: relative;
            z-index: 1;
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.05),
                inset 0 -1px 2px rgba(0, 0, 0, 0.02);
            transition: all 0.3s ease;
        }

        /* 夜间模式内页样式 - 保持白底黑字 */
        .dark-mode .diary-pages {
            background: 
                linear-gradient(135deg, #fefefe 0%, #f8f8f8 100%);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.05),
                inset 0 -1px 2px rgba(0, 0, 0, 0.02);
        }

        .dark-mode .diary-pages::before {
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.03) 1px, transparent 0);
        }

        /* 纸张纹理效果 */
        .diary-pages::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(0, 0, 0, 0.02) 1px, transparent 0);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: -1;
        }

        /* 日记页面内容样式 - 优化字体和排版 */
        .diary-page-content {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Kaiti', 'STKaiti', 'Georgia', 'Times New Roman', serif;
            line-height: 1.9;
            position: relative;
            z-index: 2;
            color: #2c2c2c;
            transition: color 0.3s ease;
        }

        /* 夜间模式页面内容样式 - 保持黑色文字 */
        .dark-mode .diary-page-content {
            color: #2c2c2c;
        }
        
        /* 确保所有日记相关文字都使用思源宋体 */
        .diary-book-item,
        .diary-book-item h3,
        .diary-book-item p,
        .diary-entry,
        .diary-entry h3,
        .diary-entry p {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
        }

        .diary-page-date {
            font-weight: 600;
            margin-bottom: 2rem;
            color: #2c2c2c;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 0.8rem;
            font-size: 1.1rem;
            letter-spacing: 0.5px;
            position: relative;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            transition: all 0.3s ease;
        }

        .diary-page-date::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 60px;
            height: 2px;
            background: linear-gradient(90deg, #505050, transparent);
            transition: background 0.3s ease;
        }

        /* 夜间模式日期样式 - 保持黑色文字 */
        .dark-mode .diary-page-date {
            color: #2c2c2c;
            border-bottom-color: #e0e0e0;
        }

        .dark-mode .diary-page-date::after {
            background: linear-gradient(90deg, #505050, transparent);
        }

        /* 日记页面头部样式 */
        .diary-page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        /* 删除按钮样式 */
        .diary-delete-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .diary-delete-btn:hover {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        /* 页码样式 */
        .diary-page-number {
            position: relative;
            text-align: right;
            margin-top: 2rem;
            font-size: 0.8rem;
            color: #999;
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            background: rgba(255, 255, 255, 0.8);
            padding: 0.3rem 0.6rem;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            /* 移除 display: inline-block，因為 float: right 會強制轉換為 block */
            float: right;
        }

        .diary-page-text {
            font-size: 1rem;
            text-align: justify;
            white-space: pre-wrap;
            color: #2a2a2a;
            line-height: 2;
            text-shadow: 0 0.5px 1px rgba(255, 255, 255, 0.8);
            padding: 1rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            cursor: text;
        }

        .diary-page-text[contenteditable="true"]:hover {
            background: rgba(0, 0, 0, 0.02);
        }

        .diary-page-text[contenteditable="true"]:focus {
            outline: none;
            background: rgba(0, 0, 0, 0.03);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.08),
                0 0 0 2px rgba(80, 80, 80, 0.1);
        }

        /* 滚动条样式优化 */
        .diary-pages::-webkit-scrollbar {
            width: 6px;
        }

        .diary-pages::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
        }

        .diary-pages::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .diary-pages::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        /* 日记编辑区域样式 - 纸张质感 */
        .diary-page-editable {
            width: 100%;
            min-height: 200px;
            padding: 1.5rem;
            border: none;
            background: 
                linear-gradient(135deg, #fefefe 0%, #fafafa 100%);
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', serif;
            font-size: 1rem;
            line-height: 1.9;
            color: #2a2a2a;
            resize: vertical;
            border-radius: 8px;
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.08),
                inset 0 -1px 2px rgba(0, 0, 0, 0.02);
            transition: all 0.3s ease;
        }

        .diary-page-editable:focus {
            outline: none;
            background: 
                linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%);
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.12),
                inset 0 -1px 2px rgba(0, 0, 0, 0.05),
                0 0 0 3px rgba(80, 80, 80, 0.1);
        }

        .diary-page-editable::placeholder {
            color: #999;
            font-style: italic;
            opacity: 0.7;
        }

        /* 新日记页面样式 */
        .diary-page-new {
            background: 
                linear-gradient(135deg, #f8f8f8 0%, #f0f0f0 100%);
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            color: #666;
            transition: all 0.3s ease;
        }

        .diary-page-new:hover {
            border-color: #999;
            background: 
                linear-gradient(135deg, #f0f0f0 0%, #e8e8e8 100%);
        }

        .diary-page-new h3 {
            margin-bottom: 1rem;
            color: #505050;
            font-size: 1.2rem;
        }

        .diary-page-new p {
            color: #888;
            line-height: 1.6;
        }

        /* 日记本控制按钮样式 - 黑白灰质感 */
        #close-diary-book-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #close-diary-book-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #prev-page-btn,
        #next-page-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            box-shadow: 
                0 3px 10px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #prev-page-btn:hover,
        #next-page-btn:hover {
            background: rgba(0, 0, 0, 0.75);
            transform: scale(1.1);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #add-page-btn {
            background: linear-gradient(145deg, #404040, #505050);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #add-page-btn:hover {
            background: linear-gradient(145deg, #505050, #606060);
            transform: scale(1.05);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        /* 按钮图标样式 */
        #close-diary-book-btn i,
        #prev-page-btn i,
        #next-page-btn i,
        #add-page-btn i {
            color: #f0f0f0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 日记页面占位符样式 */
        .diary-page-placeholder {
            display: none;
        }

        /* 笔记本项目样式 */
        .notebook-item {
            position: relative;
        }

        .notebook-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .notebook-item:hover .notebook-actions {
            opacity: 1;
        }

        .notebook-edit-btn,
        .notebook-delete-btn {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
        }

        .notebook-edit-btn:hover {
            background: rgba(59, 130, 246, 0.8);
            transform: scale(1.1);
        }

        .notebook-delete-btn:hover {
            background: rgba(239, 68, 68, 0.8);
            transform: scale(1.1);
        }

        /* 新笔记本模态框样式 */
        #new-notebook-modal .modal-content {
            max-width: 400px;
        }

        /* 基础表单样式 - 支持日间夜间模式 */
        .form-input,
        .form-select {
            border-radius: 8px;
            padding: 0.75rem;
            width: 100%;
            transition: all 0.3s ease;
        }

        /* 夜间模式样式 */
        .dark-mode .form-input,
        .dark-mode .form-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
        }

        /* 日间模式样式 */
        .light-mode .form-input,
        .light-mode .form-select {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #1f2937;
        }

        /* 焦点状态 - 夜间模式 */
        .dark-mode .form-input:focus,
        .dark-mode .form-select:focus {
            outline: none;
            border-color: rgba(59, 130, 246, 0.6);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* 焦点状态 - 日间模式 */
        .light-mode .form-input:focus,
        .light-mode .form-select:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* 占位符样式 - 夜间模式 */
        .dark-mode .form-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        /* 占位符样式 - 日间模式 */
        .light-mode .form-input::placeholder {
            color: rgba(0, 0, 0, 0.6);
        }
    /* ====== 动态监控 App (Refined UI) - 已修复标题遮挡问题 ====== */
    #monitoring-screen {
        color: #662034;
        position: relative;
        max-width: 100%;
        width: 100%;
        /* 新增：为顶部的状态栏留出 3.5rem 的空间，解决标题栏被覆盖的问题 */
        padding-top: 3.5rem; 
    }

    /* 科技感背景 - 日间模式 */
    #monitoring-screen::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, #C8AABD, #BE3255, #B6C9D4, #CEA9BC);
        z-index: 1;
        animation: backgroundShimmer 8s ease-in-out infinite;
        opacity: 1;
        filter: saturate(1.2) brightness(1.1);
        box-shadow: inset 0 0 50px rgba(190, 50, 85, 0.3);
    }

    /* 科技感背景 - 夜间模式 */
    .dark-mode #monitoring-screen::before {
        background: linear-gradient(135deg, #202127, #662034, #568897, #195B9A);
        z-index: 1;
        animation: backgroundShimmerDark 8s ease-in-out infinite;
        opacity: 1;
        filter: saturate(1.1) brightness(1.05);
        box-shadow: inset 0 0 50px rgba(102, 32, 52, 0.4);
    }

    /* 屏幕下方闪烁效果 - 日间模式 */
    #monitoring-screen::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            #C8AABD 20%, 
            #BE3255 40%, 
            #C0C9B6 60%, 
            #CEA9BC 80%, 
            transparent 100%);
        z-index: 1;
        animation: bottomFlash 2s ease-in-out infinite;
    }

    /* 屏幕下方闪烁效果 - 夜间模式 */
    .dark-mode #monitoring-screen::after {
        background: linear-gradient(90deg, 
            transparent 0%, 
            #202127 20%, 
            #662034 40%, 
            #568897 60%, 
            #195B9A 80%, 
            transparent 100%);
        animation: bottomFlashDark 2s ease-in-out infinite;
    }

    /* 背景闪烁装饰元素 */
    #monitoring-screen .bg-glow-1 {
        content: '';
        position: absolute;
        top: 10%;
        left: 5%;
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, rgba(200, 170, 189, 0.3) 0%, transparent 70%);
        border-radius: 50%;
        animation: backgroundGlow 6s ease-in-out infinite;
        z-index: 2;
        pointer-events: none;
    }

    #monitoring-screen .bg-glow-2 {
        content: '';
        position: absolute;
        top: 60%;
        right: 10%;
        width: 80px;
        height: 80px;
        background: radial-gradient(circle, rgba(190, 50, 85, 0.2) 0%, transparent 70%);
        border-radius: 50%;
        animation: backgroundGlow 8s ease-in-out infinite reverse;
        z-index: 2;
        pointer-events: none;
    }

    .dark-mode #monitoring-screen .bg-glow-1 {
        background: radial-gradient(circle, rgba(86, 136, 151, 0.3) 0%, transparent 70%);
        animation: backgroundGlowDark 6s ease-in-out infinite;
    }

    .dark-mode #monitoring-screen .bg-glow-2 {
        background: radial-gradient(circle, rgba(102, 32, 52, 0.2) 0%, transparent 70%);
        animation: backgroundGlowDark 8s ease-in-out infinite reverse;
    }

    /* 夜间模式文本颜色 */
    .dark-mode #monitoring-screen {
        color: #568897;
    }

    /* 日间模式身份信息文本颜色 */
    #monitoring-name {
        color: #BE3255 !important;
    }

    #monitoring-mood {
        color: #BE3255 !important;
    }

    #monitoring-status-text {
        color: #C8AABD;
    }

    /* 科技感装饰元素 - 名片区域 */
    
    /* 新增：电子颗粒效果 */
    .electronic-particles {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 15;
        overflow: hidden;
    }

    .particle {
        position: absolute;
        width: 2px;
        height: 2px;
        background: linear-gradient(45deg, #C8AABD, #BE3255);
        border-radius: 50%;
        opacity: 0;
        animation: particleFloat 8s linear infinite;
    }

    .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
    .particle:nth-child(2) { left: 20%; animation-delay: 1s; }
    .particle:nth-child(3) { left: 30%; animation-delay: 2s; }
    .particle:nth-child(4) { left: 40%; animation-delay: 3s; }
    .particle:nth-child(5) { left: 50%; animation-delay: 4s; }
    .particle:nth-child(6) { left: 60%; animation-delay: 5s; }
    .particle:nth-child(7) { left: 70%; animation-delay: 6s; }
    .particle:nth-child(8) { left: 80%; animation-delay: 7s; }

    /* 新增：X射线扫描线效果 */
    .xray-scan-line {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.8) 20%, 
            rgba(190, 50, 85, 1) 50%, 
            rgba(200, 170, 189, 0.8) 80%, 
            transparent 100%);
        box-shadow: 0 0 10px rgba(190, 50, 85, 0.6);
        z-index: 16;
        animation: xrayScan 4s ease-in-out infinite;
    }

    /* 新增：赛博朋克网格效果 */
    .cyber-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
            linear-gradient(rgba(200, 170, 189, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(200, 170, 189, 0.1) 1px, transparent 1px);
        background-size: 20px 20px;
        z-index: 14;
        opacity: 0.3;
        animation: gridPulse 6s ease-in-out infinite;
    }

    /* 新增：数据流动效果 */
    .data-flow-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 13;
        overflow: hidden;
    }

    .data-stream {
        position: absolute;
        width: 1px;
        height: 100%;
        background: linear-gradient(to bottom, 
            transparent 0%, 
            rgba(200, 170, 189, 0.6) 20%, 
            rgba(190, 50, 85, 0.8) 50%, 
            rgba(200, 170, 189, 0.6) 80%, 
            transparent 100%);
        animation: dataStream 3s linear infinite;
    }

    .data-stream:nth-child(1) { left: 15%; animation-delay: 0s; }
    .data-stream:nth-child(2) { left: 35%; animation-delay: 1s; }
    .data-stream:nth-child(3) { left: 55%; animation-delay: 2s; }
    .data-stream:nth-child(4) { left: 75%; animation-delay: 0.5s; }

    /* 新增：能量波纹效果 */
    .energy-ripple {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border: 1px solid rgba(200, 170, 189, 0.4);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 12;
        animation: energyRipple 4s ease-out infinite;
    }

    .energy-ripple:nth-child(2) { animation-delay: 1s; }
    .energy-ripple:nth-child(3) { animation-delay: 2s; }

    /* 新增：角落科技装饰 */
    .tech-corner {
        position: absolute;
        width: 20px;
        height: 20px;
        border: 1px solid rgba(200, 170, 189, 0.6);
        z-index: 17;
    }

    .tech-corner.top-left {
        top: 10px;
        left: 10px;
        border-right: none;
        border-bottom: none;
        border-radius: 8px 0 0 0;
    }

    .tech-corner.top-right {
        top: 10px;
        right: 10px;
        border-left: none;
        border-bottom: none;
        border-radius: 0 8px 0 0;
    }

    .tech-corner.bottom-left {
        bottom: 10px;
        left: 10px;
        border-right: none;
        border-top: none;
        border-radius: 0 0 0 8px;
    }

    .tech-corner.bottom-right {
        bottom: 10px;
        right: 10px;
        border-left: none;
        border-top: none;
        border-radius: 0 0 8px 0;
    }

    /* 新增：状态指示器 */
    .status-indicator {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 8px;
        height: 8px;
        background: linear-gradient(45deg, #C8AABD, #BE3255);
        border-radius: 50%;
        z-index: 18;
        animation: statusPulse 2s ease-in-out infinite;
    }

    /* 夜间模式适配 */
    .dark-mode .particle {
        background: linear-gradient(45deg, #568897, #662034);
    }

    .dark-mode .xray-scan-line {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(86, 136, 151, 0.8) 20%, 
            rgba(102, 32, 52, 1) 50%, 
            rgba(86, 136, 151, 0.8) 80%, 
            transparent 100%);
        box-shadow: 0 0 10px rgba(102, 32, 52, 0.6);
    }

    .dark-mode .cyber-grid {
        background-image: 
            linear-gradient(rgba(86, 136, 151, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(86, 136, 151, 0.1) 1px, transparent 1px);
    }

    .dark-mode .data-stream {
        background: linear-gradient(to bottom, 
            transparent 0%, 
            rgba(86, 136, 151, 0.6) 20%, 
            rgba(102, 32, 52, 0.8) 50%, 
            rgba(86, 136, 151, 0.6) 80%, 
            transparent 100%);
    }

    .dark-mode .energy-ripple {
        border-color: rgba(86, 136, 151, 0.4);
    }

    .dark-mode .tech-corner {
        border-color: rgba(86, 136, 151, 0.6);
    }

    .dark-mode .status-indicator {
        background: linear-gradient(45deg, #568897, #662034);
    }

    /* 新增：按钮区域科技感装饰 */
    .button-tech-lines {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }

    .button-line-left {
        position: absolute;
        top: 50%;
        left: 10%;
        width: 60px;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.6) 100%);
        transform: translateY(-50%);
        animation: buttonLineLeft 3s ease-in-out infinite;
    }

    .button-line-right {
        position: absolute;
        top: 50%;
        right: 10%;
        width: 60px;
        height: 1px;
        background: linear-gradient(90deg, 
            rgba(190, 50, 85, 0.6) 0%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: buttonLineRight 3s ease-in-out infinite 1.5s;
    }

    .button-center-dot {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 3px;
        height: 3px;
        background: linear-gradient(45deg, #C8AABD, #BE3255);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 6px rgba(200, 170, 189, 0.6);
        animation: buttonCenterPulse 2s ease-in-out infinite;
    }

    /* 夜间模式按钮装饰 */
    .dark-mode .button-line-left {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(86, 136, 151, 0.6) 100%);
    }

    .dark-mode .button-line-right {
        background: linear-gradient(90deg, 
            rgba(102, 32, 52, 0.6) 0%, 
            transparent 100%);
    }

    .dark-mode .button-center-dot {
        background: linear-gradient(45deg, #568897, #662034);
        box-shadow: 0 0 6px rgba(86, 136, 151, 0.6);
    }

    /* 新增：悬停和交互效果 */
    .monitoring-card:hover .tech-corner {
        animation: techCornerHover 0.3s ease-out forwards;
    }

    .monitoring-card:hover .status-indicator {
        animation: statusIndicatorHover 0.3s ease-out forwards;
    }

    .monitoring-capsule-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(200, 170, 189, 0.3);
        transition: all 0.3s ease;
    }

    .monitoring-capsule-btn:hover .button-tech-lines {
        opacity: 1;
    }

    /* 新增：数据流动画增强 */
    .data-stream:hover {
        animation-duration: 1.5s;
        box-shadow: 0 0 8px rgba(200, 170, 189, 0.4);
    }

    /* 新增：X射线扫描线悬停效果 */
    .xray-scan-line:hover {
        animation-duration: 2s;
        box-shadow: 0 0 15px rgba(190, 50, 85, 0.8);
    }

    /* 文本框下方的科技感线性装饰 */
    .tech-lines-container {
        height: 20px;
        overflow: hidden;
    }

    .tech-line-main {
        position: absolute;
        top: 50%;
        left: 20%;
        right: 20%;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.3) 20%, 
            rgba(200, 170, 189, 0.8) 50%, 
            rgba(190, 50, 85, 0.8) 80%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: techLinePulse 3s ease-in-out infinite;
    }

    .tech-line-left {
        position: absolute;
        top: 50%;
        left: 15%;
        width: 30px;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.6) 100%);
        transform: translateY(-50%);
        animation: techLineLeft 2.5s ease-in-out infinite;
    }

    .tech-line-left-2 {
        position: absolute;
        top: 50%;
        left: 12%;
        width: 20px;
        height: 1px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(200, 170, 189, 0.4) 100%);
        transform: translateY(-50%);
        animation: techLineLeft 2.5s ease-in-out infinite 0.8s;
    }

    .tech-line-right {
        position: absolute;
        top: 50%;
        right: 15%;
        width: 30px;
        height: 1px;
        background: linear-gradient(90deg, 
            rgba(190, 50, 85, 0.6) 0%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: techLineRight 2.5s ease-in-out infinite 0.5s;
    }

    .tech-line-right-2 {
        position: absolute;
        top: 50%;
        right: 12%;
        width: 20px;
        height: 1px;
        background: linear-gradient(90deg, 
            rgba(190, 50, 85, 0.4) 0%, 
            transparent 100%);
        transform: translateY(-50%);
        animation: techLineRight 2.5s ease-in-out infinite 1.2s;
    }

    .tech-center-dot {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 2px;
        height: 2px;
        background: linear-gradient(45deg, #C8AABD, #BE3255);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 4px rgba(200, 170, 189, 0.6);
        animation: techCenterPulse 2s ease-in-out infinite;
    }

    .tech-center-dot-2 {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 4px;
        background: transparent;
        border: 1px solid rgba(200, 170, 189, 0.3);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        animation: techCenterPulse 2s ease-in-out infinite 0.5s;
    }

    /* 夜间模式线性装饰 */
    .dark-mode .tech-line-main {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(32, 33, 39, 0.3) 20%, 
            rgba(32, 33, 39, 0.8) 50%, 
            rgba(102, 32, 52, 0.8) 80%, 
            transparent 100%);
    }

    .dark-mode .tech-line-left,
    .dark-mode .tech-line-left-2 {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(86, 136, 151, 0.6) 100%);
    }

    .dark-mode .tech-line-left-2 {
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(86, 136, 151, 0.4) 100%);
    }

    .dark-mode .tech-line-right,
    .dark-mode .tech-line-right-2 {
        background: linear-gradient(90deg, 
            rgba(102, 32, 52, 0.6) 0%, 
            transparent 100%);
    }

    .dark-mode .tech-line-right-2 {
        background: linear-gradient(90deg, 
            rgba(102, 32, 52, 0.4) 0%, 
            transparent 100%);
    }

    .dark-mode .tech-center-dot {
        background: linear-gradient(45deg, #202127, #662034);
        box-shadow: 0 0 4px rgba(32, 33, 39, 0.6);
    }

    .dark-mode .tech-center-dot-2 {
        border-color: rgba(32, 33, 39, 0.3);
    }



    /* 科技感装饰元素动画 */
    @keyframes techPulse {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.8;
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.3);
        }
        50% { 
            transform: scale(1.1);
            opacity: 1;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.6);
        }
    }

    @keyframes techGlow {
        0%, 100% { 
            opacity: 0.8;
            box-shadow: 0 0 5px rgba(192, 201, 182, 0.5);
        }
        50% { 
            opacity: 1;
            box-shadow: 0 0 15px rgba(192, 201, 182, 0.8);
        }
    }

    @keyframes techFloat {
        0%, 100% { 
            transform: translateY(0px);
            opacity: 0.7;
        }
        50% { 
            transform: translateY(-3px);
            opacity: 1;
        }
    }

    @keyframes techFade {
        0%, 100% { 
            opacity: 0.4;
            transform: scale(0.8);
        }
        50% { 
            opacity: 1;
            transform: scale(1.1);
        }
    }

    @keyframes techScale {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.6;
            box-shadow: 0 0 4px rgba(200, 170, 189, 0.3);
        }
        50% { 
            transform: scale(1.15);
            opacity: 1;
            box-shadow: 0 0 10px rgba(200, 170, 189, 0.6);
        }
    }

    /* 线性装饰动画 */
    @keyframes techLinePulse {
        0%, 100% { 
            opacity: 0.4;
            transform: translateY(-50%) scaleX(0.8);
        }
        50% { 
            opacity: 1;
            transform: translateY(-50%) scaleX(1.1);
        }
    }

    @keyframes techLineLeft {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) translateX(0px);
            box-shadow: 0 0 2px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 0.8;
            transform: translateY(-50%) translateX(-1px);
            box-shadow: 0 0 6px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes techLineRight {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) translateX(0px);
            box-shadow: 0 0 2px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 0.8;
            transform: translateY(-50%) translateX(1px);
            box-shadow: 0 0 6px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes techCenterPulse {
        0%, 100% { 
            opacity: 0.4;
            transform: translate(-50%, -50%) scale(0.9);
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.5);
        }
    }

    /* 科技感曲线动画 */
    @keyframes techCurveGlow {
        0%, 100% { 
            opacity: 0.4;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.4);
        }
        50% { 
            opacity: 0.7;
            box-shadow: 0 0 20px rgba(200, 170, 189, 0.7);
        }
    }

    @keyframes techCurvePulse {
        0%, 100% { 
            opacity: 0.4;
            transform: rotate(0deg) scale(0.9);
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 1;
            transform: rotate(0deg) scale(1.05);
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.5);
        }
    }

    /* 新增静态光效装饰 */
    .monitoring-card .static-glow {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
        background: 
            radial-gradient(circle at 20% 20%, rgba(200, 170, 189, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(190, 50, 85, 0.08) 0%, transparent 50%),
            radial-gradient(circle at 40% 60%, rgba(192, 201, 182, 0.06) 0%, transparent 50%);
        border-radius: 16px;
    }

    .dark-mode .monitoring-card .static-glow {
        background: 
            radial-gradient(circle at 20% 20%, rgba(86, 136, 151, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(102, 32, 52, 0.08) 0%, transparent 50%),
            radial-gradient(circle at 40% 60%, rgba(25, 91, 154, 0.06) 0%, transparent 50%);
    }

    /* 科技感光点装饰 */
    .monitoring-card .tech-light-dots {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .tech-light-dots::before,
    .monitoring-card .tech-light-dots::after {
        content: '';
        position: absolute;
        width: 2px;
        height: 2px;
        background: rgba(200, 170, 189, 0.6);
        border-radius: 50%;
        box-shadow: 0 0 4px rgba(200, 170, 189, 0.4);
    }

    .monitoring-card .tech-light-dots::before {
        top: 25%;
        left: 15%;
        animation: lightDotGlow 3s ease-in-out infinite;
    }

    .monitoring-card .tech-light-dots::after {
        bottom: 30%;
        right: 20%;
        animation: lightDotGlow 3s ease-in-out infinite 1.5s;
    }

    .dark-mode .monitoring-card .tech-light-dots::before,
    .dark-mode .monitoring-card .tech-light-dots::after {
        background: rgba(86, 136, 151, 0.6);
        box-shadow: 0 0 4px rgba(86, 136, 151, 0.4);
    }

    /* 光点闪烁动画 */
    @keyframes lightDotGlow {
        0%, 100% { 
            opacity: 0.6;
            box-shadow: 0 0 4px rgba(200, 170, 189, 0.4);
        }
        50% { 
            opacity: 1;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.8);
        }
    }

    /* 深色模式光点样式 */
    .dark-mode .monitoring-card .tech-light-dots::before,
    .dark-mode .monitoring-card .tech-light-dots::after {
        background: rgba(86, 136, 151, 0.6);
        box-shadow: 0 0 4px rgba(86, 136, 151, 0.4);
    }

    /* 新增角落光效装饰 */
    .monitoring-card .corner-glow {
        position: absolute;
        width: 20px;
        height: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .corner-glow.top-left {
        top: 8px;
        left: 8px;
        background: radial-gradient(circle, rgba(200, 170, 189, 0.4) 0%, transparent 70%);
        border-radius: 50%;
        animation: cornerGlow 4s ease-in-out infinite;
    }

    .monitoring-card .corner-glow.top-right {
        top: 8px;
        right: 8px;
        background: radial-gradient(circle, rgba(190, 50, 85, 0.4) 0%, transparent 70%);
        border-radius: 50%;
        animation: cornerGlow 4s ease-in-out infinite 1s;
    }

    .monitoring-card .corner-glow.bottom-left {
        bottom: 8px;
        left: 8px;
        background: radial-gradient(circle, rgba(192, 201, 182, 0.4) 0%, transparent 70%);
        border-radius: 50%;
        animation: cornerGlow 4s ease-in-out infinite 2s;
    }

    .monitoring-card .corner-glow.bottom-right {
        bottom: 8px;
        right: 8px;
        background: radial-gradient(circle, rgba(206, 169, 188, 0.4) 0%, transparent 70%);
        border-radius: 50%;
        animation: cornerGlow 4s ease-in-out infinite 3s;
    }

    .dark-mode .monitoring-card .corner-glow.top-left {
        background: radial-gradient(circle, rgba(86, 136, 151, 0.4) 0%, transparent 70%);
    }

    .dark-mode .monitoring-card .corner-glow.top-right {
        background: radial-gradient(circle, rgba(102, 32, 52, 0.4) 0%, transparent 70%);
    }

    .dark-mode .monitoring-card .corner-glow.bottom-left {
        background: radial-gradient(circle, rgba(25, 91, 154, 0.4) 0%, transparent 70%);
    }

    .dark-mode .monitoring-card .corner-glow.bottom-right {
        background: radial-gradient(circle, rgba(86, 136, 151, 0.4) 0%, transparent 70%);
    }

    /* 角落光效动画 */
    @keyframes cornerGlow {
        0%, 100% { 
            opacity: 0.4;
            transform: scale(1);
        }
        50% { 
            opacity: 0.8;
            transform: scale(1.2);
        }
    }

    /* 新增静态扫描线效果 */
    .monitoring-card .scan-lines {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
        background: repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(200, 170, 189, 0.03) 2px,
            rgba(200, 170, 189, 0.03) 4px
        );
        border-radius: 16px;
        animation: scanLineGlow 6s ease-in-out infinite;
    }

    .dark-mode .monitoring-card .scan-lines {
        background: repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(86, 136, 151, 0.03) 2px,
            rgba(86, 136, 151, 0.03) 4px
        );
    }

    /* 扫描线光效动画 */
    @keyframes scanLineGlow {
        0%, 100% { 
            opacity: 0.03;
        }
        50% { 
            opacity: 0.08;
        }
    }

    /* 噪波纹理效果 */
    #monitoring-screen::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: 
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 2px,
                rgba(200, 170, 189, 0.1) 2px,
                rgba(200, 170, 189, 0.1) 4px
            ),
            repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 2px,
                rgba(200, 170, 189, 0.1) 2px,
                rgba(200, 170, 189, 0.1) 4px
            );
        z-index: 0;
        pointer-events: none;
    }

    .dark-mode #monitoring-screen::after {
        background-image: 
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 2px,
                rgba(86, 136, 151, 0.2) 2px,
                rgba(86, 136, 151, 0.2) 4px
            ),
            repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 2px,
                rgba(86, 136, 151, 0.2) 2px,
                rgba(86, 136, 151, 0.2) 4px
            );
    }

    /* 动态监控卡片样式 */
    .monitoring-card {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(200, 170, 189, 0.5));
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(200, 170, 189, 0.3);
        border-radius: 16px;
        position: relative;
        overflow: hidden;
        transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        box-shadow: 
            0 8px 32px rgba(200, 170, 189, 0.3),
            0 4px 16px rgba(190, 50, 85, 0.15),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .dark-mode .monitoring-card {
        background: rgba(32, 33, 39, 0.3);
        border-color: rgba(102, 32, 52, 0.3);
        box-shadow: 
            0 8px 32px rgba(32, 33, 39, 0.2),
            0 4px 16px rgba(102, 32, 52, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    /* 卡片光效边框 */
    .monitoring-card::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, 
            rgba(200, 170, 189, 0.5), 
            rgba(190, 50, 85, 0.6), 
            rgba(192, 201, 182, 0.5), 
            rgba(206, 169, 188, 0.5));
        background-size: 400% 400%;
        border-radius: 18px;
        z-index: -1;
        animation: borderGlow 4s ease-in-out infinite;
        opacity: 0.6;
    }

    .dark-mode .monitoring-card::before {
        background: linear-gradient(45deg, 
            rgba(32, 33, 39, 0.8), 
            rgba(102, 32, 52, 0.8), 
            rgba(86, 136, 151, 0.6), 
            rgba(25, 91, 154, 0.8));
    }

    /* 卡片悬停效果 */
    .monitoring-card:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 
            0 16px 48px rgba(200, 170, 189, 0.2),
            0 8px 24px rgba(190, 50, 85, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .dark-mode .monitoring-card:hover {
        box-shadow: 
            0 16px 48px rgba(32, 33, 39, 0.4),
            0 8px 24px rgba(102, 32, 52, 0.4),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    /* 动态监控标题栏美化 */
    #monitoring-screen .app-header {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(200, 170, 189, 0.5));
        backdrop-filter: blur(25px);
        -webkit-backdrop-filter: blur(25px);
        border-bottom: 1px solid rgba(200, 170, 189, 0.3);
        position: relative;
        overflow: hidden;
    }

    .dark-mode #monitoring-screen .app-header {
        background: rgba(32, 33, 39, 0.4);
        border-bottom-color: rgba(102, 32, 52, 0.4);
    }

    /* 标题栏光效 - 改为静态光效 */
    #monitoring-screen .app-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            radial-gradient(ellipse at 20% 50%, rgba(200, 170, 189, 0.1) 0%, transparent 50%),
            radial-gradient(ellipse at 80% 50%, rgba(190, 50, 85, 0.08) 0%, transparent 50%);
        animation: headerGlow 5s ease-in-out infinite;
    }

    .dark-mode #monitoring-screen .app-header::before {
        background: 
            radial-gradient(ellipse at 20% 50%, rgba(86, 136, 151, 0.1) 0%, transparent 50%),
            radial-gradient(ellipse at 80% 50%, rgba(102, 32, 52, 0.08) 0%, transparent 50%);
    }

    /* 标题文字效果 */
    #monitoring-screen .app-header-title {
        background: linear-gradient(45deg, #C8AABD, #BE3255, #C0C9B6, #CEA9BC);
        background-size: 200% 200%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: titleGlow 3s ease-in-out infinite;
        text-shadow: 0 0 20px rgba(190, 50, 85, 0.5);
        /* 确保文字在渐变不兼容时仍然可见 */
        color: #BE3255;
    }

    .dark-mode #monitoring-screen .app-header-title {
        /* 夜间模式使用纯色确保文字可见 */
        background: none;
        -webkit-background-clip: unset;
        -webkit-text-fill-color: unset;
        background-clip: unset;
        color: #568897;
        text-shadow: 0 0 20px rgba(86, 136, 151, 0.5);
    }

    /* 副标题效果 */
    #monitoring-screen .app-header .text-xs {
        color: #C8AABD;
        text-shadow: 0 0 10px rgba(200, 170, 189, 0.5);
    }

    .dark-mode #monitoring-screen .app-header .text-xs {
        color: #568897;
        text-shadow: 0 0 10px rgba(86, 136, 151, 0.5);
    }

    /* 标题栏光效动画 */
    @keyframes headerGlow {
        0%, 100% { 
            opacity: 0.1;
        }
        50% { 
            opacity: 0.2;
        }
    }

    /* 返回按钮美化 */
    #monitoring-back-button {
        background: rgba(200, 170, 189, 0.2);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(200, 170, 189, 0.3);
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        color: #BE3255;
    }

    .dark-mode #monitoring-back-button {
        background: rgba(32, 33, 39, 0.4);
        border-color: rgba(102, 32, 52, 0.4);
        color: #568897;
    }

    #monitoring-back-button:hover {
        background: rgba(200, 170, 189, 0.3);
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(200, 170, 189, 0.4);
        color: #BE3255;
    }

    .dark-mode #monitoring-back-button:hover {
        background: rgba(102, 32, 52, 0.5);
        box-shadow: 0 0 20px rgba(102, 32, 52, 0.4);
    }

    /* 身份信息块美化 */
    #monitoring-identity-block {
        position: relative;
        overflow: hidden;
    }





    /* 头像美化 */
    #monitoring-avatar {
        border: 2px solid rgba(200, 170, 189, 0.6);
        box-shadow: 0 0 20px rgba(200, 170, 189, 0.3);
        transition: all 0.3s ease;
    }

    .dark-mode #monitoring-avatar {
        border-color: rgba(86, 136, 151, 0.6);
        box-shadow: 0 0 20px rgba(86, 136, 151, 0.3);
    }

    #monitoring-avatar:hover {
        transform: scale(1.05);
        box-shadow: 0 0 30px rgba(200, 170, 189, 0.5);
    }

    .dark-mode #monitoring-avatar:hover {
        box-shadow: 0 0 30px rgba(86, 136, 151, 0.5);
    }

    /* 状态文本容器美化 */
    #monitoring-text-container {
        /* 防止滚动冲突 */
        overscroll-behavior: contain;
        /* 添加滚动提示 */
        position: relative;
        /* 让容器在页面中居中，但文本保持自然段落格式 */
        max-width: 800px;
        margin: 0 auto;
        /* 设置合适的左右边距，为滚动条留出空间 */
        padding-left: 2rem;
        padding-right: 3rem;
        /* 触摸优化 */
        -webkit-overflow-scrolling: touch;
        touch-action: pan-y;
        /* 确保在手机上可以正常滚动 */
        overflow-y: auto;
        /* 触摸滚动性能优化 */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        /* 设置合适的高度，避免滚动条过长 */
        height: 300px !important;
        min-height: 200px !important;
        max-height: 550px !important;
        /* 确保滚动条不会超出容器边界 */
        box-sizing: border-box;
    }

    /* 自定义滚动条样式 - 赛博朋克风格 */
    #monitoring-text-container::-webkit-scrollbar {
        width: 12px;
        background: rgba(20, 20, 30, 0.9);
        border-radius: 6px;
        border: 1px solid rgba(190, 50, 85, 0.5);
        /* 确保滚动条在容器内部 */
        margin-right: 0;
        /* 确保滚动条在最上层 */
        z-index: 9999;
    }

    #monitoring-text-container::-webkit-scrollbar-track {
        background: rgba(20, 20, 30, 0.4);
        border-radius: 6px;
        border: 1px solid rgba(190, 50, 85, 0.3);
        /* 确保滚动条轨道在最上层 */
        z-index: 9999;
    }

    /* Firefox 滚动条样式 */
    #monitoring-text-container {
        scrollbar-width: thin;
        scrollbar-color: rgba(190, 50, 85, 0.9) rgba(20, 20, 30, 0.4);
        /* 确保滚动条可见 */
        overflow-y: auto !important;
        /* 确保滚动条在容器内部 */
        overflow-x: hidden !important;
        /* 确保容器在最上层 */
        position: relative;
        z-index: 9999;
    }



    #monitoring-text-container::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, 
            rgba(190, 50, 85, 0.9) 0%, 
            rgba(120, 30, 60, 0.9) 50%, 
            rgba(190, 50, 85, 0.9) 100%);
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 
            inset 0 1px 0 rgba(255, 255, 255, 0.3),
            0 0 8px rgba(190, 50, 85, 0.5);
        transition: all 0.3s ease;
        /* 限制滚动条滑块的最小高度，避免过长 */
        min-height: 20px;
        /* 确保滚动条滑块在最上层 */
        z-index: 9999;
    }

    #monitoring-text-container::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, 
            rgba(220, 70, 105, 0.9) 0%, 
            rgba(150, 50, 80, 0.9) 50%, 
            rgba(220, 70, 105, 0.9) 100%);
        box-shadow: 
            inset 0 1px 0 rgba(255, 255, 255, 0.4),
            0 0 12px rgba(220, 70, 105, 0.7);
        /* 确保hover状态也在最上层 */
        z-index: 9999;
    }

    #monitoring-text-container::-webkit-scrollbar-thumb:active {
        background: linear-gradient(135deg, 
            rgba(255, 90, 125, 0.9) 0%, 
            rgba(180, 70, 90, 0.9) 50%, 
            rgba(255, 90, 125, 0.9) 100%);
        box-shadow: 
            inset 0 1px 0 rgba(255, 255, 255, 0.5),
            0 0 16px rgba(255, 90, 125, 0.8);
        /* 确保active状态也在最上层 */
        z-index: 9999;
    }

    /* 状态文本美化 */
    #monitoring-status-text {
        color: #365FAF;
        text-shadow: 0 0 10px rgba(200, 170, 189, 0.3);
        line-height: 1.8;
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
        /* 保持文本的自然段落格式 */
        text-align: left;
    }

    .dark-mode #monitoring-status-text {
        color: #568897;
        text-shadow: 0 0 10px rgba(86, 136, 151, 0.3);
    }

    /* 时间戳美化 */
    #monitoring-timestamp {
        color: #BE3255;
        font-weight: 500;
        text-shadow: 0 0 8px rgba(190, 50, 85, 0.4);
    }

    .dark-mode #monitoring-timestamp {
        color: #568897;
        text-shadow: 0 0 8px rgba(86, 136, 151, 0.4);
    }

    /* 胶囊按钮美化 */
    .monitoring-capsule-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.375rem;
        height: 2.5rem;
        padding-left: 1.25rem;
        padding-right: 1.25rem;
        border-radius: 9999px;
        background: linear-gradient(135deg, rgba(200, 170, 189, 0.3), rgba(190, 50, 85, 0.4));
        color: #BE3255;
        font-size: 0.875rem;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        border: 1px solid rgba(200, 170, 189, 0.4);
        box-shadow: 
            0 4px 15px rgba(200, 170, 189, 0.2),
            0 2px 8px rgba(190, 50, 85, 0.2);
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
    }

    .dark-mode .monitoring-capsule-btn {
        background: linear-gradient(135deg, rgba(32, 33, 39, 0.5), rgba(102, 32, 52, 0.5));
        border-color: rgba(102, 32, 52, 0.5);
        box-shadow: 
            0 4px 15px rgba(32, 33, 39, 0.3),
            0 2px 8px rgba(102, 32, 52, 0.3);
    }

    /* 按钮光效 */
    .monitoring-capsule-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255, 255, 255, 0.2), 
            transparent);
        transition: left 0.6s ease;
    }

    .monitoring-capsule-btn:hover::before {
        left: 100%;
    }

    .monitoring-capsule-btn:hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 
            0 8px 25px rgba(200, 170, 189, 0.4),
            0 4px 15px rgba(190, 50, 85, 0.4);
        background: linear-gradient(135deg, rgba(200, 170, 189, 0.5), rgba(190, 50, 85, 0.6));
    }

    .dark-mode .monitoring-capsule-btn:hover {
        box-shadow: 
            0 8px 25px rgba(32, 33, 39, 0.5),
            0 4px 15px rgba(102, 32, 52, 0.5);
        background: linear-gradient(135deg, rgba(32, 33, 39, 0.7), rgba(102, 32, 52, 0.7));
    }

    .monitoring-capsule-btn:active {
        transform: translateY(-1px) scale(0.98);
    }

    .monitoring-capsule-btn i {
        font-size: 1.125rem;
        transition: transform 0.3s ease;
    }

    .monitoring-capsule-btn:hover i {
        transform: rotate(15deg);
    }

    /* 刷新按钮旋转动画 */
    .refresh-rotating {
        animation: refreshRotate 1s linear infinite;
    }

    @keyframes refreshRotate {
        from {
            transform: rotate(0deg);
        }
        to {
            transform: rotate(360deg);
        }
    }

    /* 持续监控按钮增强闪烁光效 */
    .monitoring-pulse {
        animation: monitoringPulse 1.5s ease-in-out infinite;
        position: relative;
    }

    .monitoring-pulse::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        background: radial-gradient(circle, rgba(190, 50, 85, 0.8) 0%, transparent 70%);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        animation: monitoringPulseRing 1.5s ease-in-out infinite;
        pointer-events: none;
    }

    @keyframes monitoringPulse {
        0%, 100% {
            opacity: 1;
            transform: scale(1);
            box-shadow: 
                0 0 0 0 rgba(190, 50, 85, 0.7),
                0 0 0 0 rgba(200, 170, 189, 0.5);
        }
        50% {
            opacity: 0.8;
            transform: scale(1.05);
            box-shadow: 
                0 0 0 8px rgba(190, 50, 85, 0.3),
                0 0 0 12px rgba(200, 170, 189, 0.2);
        }
    }

    @keyframes monitoringPulseRing {
        0% {
            width: 0;
            height: 0;
            opacity: 1;
        }
        100% {
            width: 60px;
            height: 60px;
            opacity: 0;
        }
    }

    .dark-mode .monitoring-pulse::after {
        background: radial-gradient(circle, rgba(102, 32, 52, 0.8) 0%, transparent 70%);
    }

    .dark-mode .monitoring-pulse {
        animation: monitoringPulseDark 1.5s ease-in-out infinite;
    }

    @keyframes monitoringPulseDark {
        0%, 100% {
            opacity: 1;
            transform: scale(1);
            box-shadow: 
                0 0 0 0 rgba(102, 32, 52, 0.7),
                0 0 0 0 rgba(32, 33, 39, 0.5);
        }
        50% {
            opacity: 0.8;
            transform: scale(1.05);
            box-shadow: 
                0 0 0 8px rgba(102, 32, 52, 0.3),
                0 0 0 12px rgba(32, 33, 39, 0.2);
        }
    }

    /* 动画定义 */
    @keyframes particleFloat {
        0%, 100% { 
            transform: translateY(0px) rotate(0deg);
            opacity: 0.3;
        }
        25% { 
            transform: translateY(-10px) rotate(90deg);
            opacity: 0.7;
        }
        50% { 
            transform: translateY(-5px) rotate(180deg);
            opacity: 0.5;
        }
        75% { 
            transform: translateY(-15px) rotate(270deg);
            opacity: 0.8;
        }
    }

    @keyframes borderGlow {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
    }

    @keyframes headerShine {
        0% { left: -100%; }
        50% { left: 100%; }
        100% { left: 100%; }
    }

    @keyframes titleGlow {
        0%, 100% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
    }

    @keyframes cardGlow {
        0%, 100% { opacity: 0.5; }
        50% { opacity: 1; }
    }

    /* 响应式设计 */
    @media (max-width: 480px) {
        .monitoring-capsule-btn {
            height: 2.25rem;
            padding-left: 1rem;
            padding-right: 1rem;
            font-size: 0.8rem;
        }
        
        .monitoring-card {
            padding: 0.75rem;
        }
        
        #monitoring-avatar {
            width: 2.5rem;
            height: 2.5rem;
        }
    }

    /* ====== 新增科技化元素 START ====== */
    
    /* 1. 科技感扫描线效果 */
    .monitoring-card::after {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        height: 2px;
        background: linear-gradient(90deg, 
            transparent 0%, 
            #C8AABD 20%, 
            #BE3255 40%, 
            #C0C9B6 60%, 
            #CEA9BC 80%, 
            transparent 100%);
        animation: scanLine 3s linear infinite;
        z-index: 0;
        opacity: 0.8;
    }

    .dark-mode .monitoring-card::after {
        background: linear-gradient(90deg, 
            transparent 0%, 
            #202127 20%, 
            #662034 40%, 
            #568897 60%, 
            #195B9A 80%, 
            transparent 100%);
    }

    /* 2. 科技感数据流效果 */
    .monitoring-card .data-stream {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        pointer-events: none;
        z-index: 0;
    }

    /* 2.5. 米白色-粉色渐变透明背景 */
    .monitoring-card .cream-pink-bg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(255, 248, 240, 0.15) 0%, rgba(255, 228, 225, 0.2) 50%, rgba(255, 228, 225, 0.2) 50%, rgba(255, 248, 240, 0.15) 100%);
        border-radius: 15px;
        z-index: 0;
    }

    .monitoring-card .data-stream::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
            90deg,
            transparent,
            transparent 20px,
            rgba(200, 170, 189, 0.1) 20px,
            rgba(200, 170, 189, 0.1) 22px
        );
        animation: dataGlow 3s ease-in-out infinite;
    }

    .dark-mode .monitoring-card .data-stream::before {
        background: repeating-linear-gradient(
            90deg,
            transparent,
            transparent 20px,
            rgba(32, 33, 39, 0.2) 20px,
            rgba(32, 33, 39, 0.2) 22px
        );
        animation: dataGlow 3s ease-in-out infinite;
    }

    /* 3. 科技感能量环 */
    .monitoring-card .energy-ring {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 380px;
        height: 380px;
        transform: translate(-50%, -50%);
        border: 2px solid transparent;
        border-top: 2px solid #E8D5E0;
        border-right: 2px solid #D14A6B;
        border-bottom: 2px solid #D0E5F0;
        border-left: 2px solid #E6C5D8;
        border-radius: 50%;
        animation: energyGlow 4s ease-in-out infinite;
        opacity: 0.4;
        z-index: 0;
    }

    .dark-mode .monitoring-card .energy-ring {
        border-top-color: #2A2D35;
        border-right-color: #7A2A4A;
        border-bottom-color: #4A7A8A;
        border-left-color: #2A5A7A;
    }

    .monitoring-card .energy-ring::before {
        content: '';
        position: absolute;
        top: -6px;
        left: -6px;
        right: -6px;
        bottom: -6px;
        border: 1px solid transparent;
        border-top: 1px solid #E8D5E0;
        border-right: 1px solid #D14A6B;
        border-bottom: 1px solid #D0E5F0;
        border-left: 1px solid #E6C5D8;
        border-radius: 50%;
        animation: energyGlow 4s ease-in-out infinite 0.5s;
        opacity: 0.3;
    }

    .dark-mode .monitoring-card .energy-ring::before {
        border-top-color: #2A2D35;
        border-right-color: #7A2A4A;
        border-bottom-color: #4A7A8A;
        border-left-color: #2A5A7A;
    }

    /* 4. 科技感脉冲点阵 */
    .monitoring-card .pulse-grid {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .pulse-grid .pulse-dot {
        position: absolute;
        width: 3px;
        height: 3px;
        border-radius: 50%;
        animation: pulseGrid 2s ease-in-out infinite;
    }

    .monitoring-card .pulse-grid .pulse-dot:nth-child(1) {
        top: 15%;
        left: 10%;
        background: #C8AABD;
        animation-delay: 0s;
    }

    .monitoring-card .pulse-grid .pulse-dot:nth-child(2) {
        top: 25%;
        right: 15%;
        background: #BE3255;
        animation-delay: 0.3s;
    }

    .monitoring-card .pulse-grid .pulse-dot:nth-child(3) {
        bottom: 20%;
        left: 20%;
        background: #C0C9B6;
        animation-delay: 0.6s;
    }

    .monitoring-card .pulse-grid .pulse-dot:nth-child(4) {
        bottom: 30%;
        right: 25%;
        background: #CEA9BC;
        animation-delay: 0.9s;
    }

    .dark-mode .monitoring-card .pulse-grid .pulse-dot:nth-child(1) {
        background: #202127;
    }

    .dark-mode .monitoring-card .pulse-grid .pulse-dot:nth-child(2) {
        background: #662034;
    }

    .dark-mode .monitoring-card .pulse-grid .pulse-dot:nth-child(3) {
        background: #568897;
    }

    .dark-mode .monitoring-card .pulse-grid .pulse-dot:nth-child(4) {
        background: #195B9A;
    }

    /* 5. 科技感连接线 */
    .monitoring-card .connection-lines {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .connection-lines .line {
        position: absolute;
        height: 1px;
        background: linear-gradient(90deg, #C8AABD, #BE3255);
        animation: connectionFlow 3s ease-in-out infinite;
    }

    .monitoring-card .connection-lines .line:nth-child(1) {
        top: 20%;
        left: 5%;
        width: 40px;
        animation-delay: 0s;
    }

    .monitoring-card .connection-lines .line:nth-child(2) {
        top: 60%;
        right: 5%;
        width: 35px;
        background: linear-gradient(90deg, #C0C9B6, #CEA9BC);
        animation-delay: 1s;
    }

    .dark-mode .monitoring-card .connection-lines .line {
        background: linear-gradient(90deg, #202127, #662034);
    }

    .dark-mode .monitoring-card .connection-lines .line:nth-child(2) {
        background: linear-gradient(90deg, #568897, #195B9A);
    }

    /* 6. 科技感状态指示器 */
    .monitoring-card .status-indicator {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #C8AABD;
        box-shadow: 0 0 8px #C8AABD;
        animation: statusPulse 2s ease-in-out infinite;
        z-index: 0;
    }

    .dark-mode .monitoring-card .status-indicator {
        background: #202127;
        box-shadow: 0 0 8px #202127;
    }

    .monitoring-card .status-indicator::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        border: 1px solid #C8AABD;
        border-radius: 50%;
        animation: statusRing 2s ease-in-out infinite;
        opacity: 0.6;
    }

    .dark-mode .monitoring-card .status-indicator::before {
        border-color: #202127;
    }

    /* 7. 科技感角落装饰 */
    .monitoring-card .corner-decoration {
        position: absolute;
        width: 20px;
        height: 20px;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .corner-decoration.top-left {
        top: 8px;
        left: 8px;
        border-top: 2px solid #C8AABD;
        border-left: 2px solid #C8AABD;
        border-top-left-radius: 8px;
    }

    .monitoring-card .corner-decoration.top-right {
        top: 8px;
        right: 8px;
        border-top: 2px solid #BE3255;
        border-right: 2px solid #BE3255;
        border-top-right-radius: 8px;
    }

    .monitoring-card .corner-decoration.bottom-left {
        bottom: 8px;
        left: 8px;
        border-bottom: 2px solid #C0C9B6;
        border-left: 2px solid #C0C9B6;
        border-bottom-left-radius: 8px;
    }

    .monitoring-card .corner-decoration.bottom-right {
        bottom: 8px;
        right: 8px;
        border-bottom: 2px solid #CEA9BC;
        border-right: 2px solid #CEA9BC;
        border-bottom-right-radius: 8px;
    }

    .dark-mode .monitoring-card .corner-decoration.top-left {
        border-color: #202127;
    }

    .dark-mode .monitoring-card .corner-decoration.top-right {
        border-color: #662034;
    }

    .dark-mode .monitoring-card .corner-decoration.bottom-left {
        border-color: #568897;
    }

    .dark-mode .monitoring-card .corner-decoration.bottom-right {
        border-color: #195B9A;
    }

    /* 8. 科技感背景网格 */
    .monitoring-card .grid-background {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: 
            linear-gradient(rgba(200, 170, 189, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(200, 170, 189, 0.1) 1px, transparent 1px);
        background-size: 20px 20px;
        opacity: 0.3;
        pointer-events: none;
        z-index: 0;
    }

    .dark-mode .monitoring-card .grid-background {
        background-image: 
            linear-gradient(rgba(32, 33, 39, 0.2) 1px, transparent 1px),
            linear-gradient(90deg, rgba(32, 33, 39, 0.2) 1px, transparent 1px);
    }

    /* 9. 科技感浮动粒子 */
    .monitoring-card .floating-particles {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 0;
    }

    .monitoring-card .floating-particles .particle {
        position: absolute;
        width: 2px;
        height: 2px;
        border-radius: 50%;
        animation: floatParticle 6s ease-in-out infinite;
    }

    .monitoring-card .floating-particles .particle:nth-child(1) {
        top: 20%;
        left: 15%;
        background: #C8AABD;
        animation-delay: 0s;
    }

    .monitoring-card .floating-particles .particle:nth-child(2) {
        top: 40%;
        right: 20%;
        background: #BE3255;
        animation-delay: 2s;
    }

    .monitoring-card .floating-particles .particle:nth-child(3) {
        bottom: 25%;
        left: 30%;
        background: #C0C9B6;
        animation-delay: 4s;
    }

    .dark-mode .monitoring-card .floating-particles .particle:nth-child(1) {
        background: #202127;
    }

    .dark-mode .monitoring-card .floating-particles .particle:nth-child(2) {
        background: #662034;
    }

    .dark-mode .monitoring-card .floating-particles .particle:nth-child(3) {
        background: #568897;
    }

    /* 10. 新增动画定义 */
    @keyframes bottomFlash {
        0%, 100% { 
            opacity: 0.3;
            box-shadow: 0 0 10px rgba(200, 170, 189, 0.4);
        }
        50% { 
            opacity: 1;
            box-shadow: 0 0 20px rgba(200, 170, 189, 0.8);
        }
    }

    @keyframes bottomFlashDark {
        0%, 100% { 
            opacity: 0.4;
            box-shadow: 0 0 15px rgba(86, 136, 151, 0.5);
        }
        50% { 
            opacity: 1;
            box-shadow: 0 0 25px rgba(86, 136, 151, 0.9);
        }
    }

    @keyframes backgroundShimmer {
        0%, 100% { 
            opacity: 0.8;
            filter: brightness(1) saturate(1);
        }
        25% { 
            opacity: 1;
            filter: brightness(1.1) saturate(1.2);
        }
        50% { 
            opacity: 0.9;
            filter: brightness(1.05) saturate(1.1);
        }
        75% { 
            opacity: 1;
            filter: brightness(1.15) saturate(1.3);
        }
    }

    @keyframes backgroundShimmerDark {
        0%, 100% { 
            opacity: 0.7;
            filter: brightness(1) saturate(1);
        }
        25% { 
            opacity: 1;
            filter: brightness(1.2) saturate(1.3);
        }
        50% { 
            opacity: 0.8;
            filter: brightness(1.1) saturate(1.2);
        }
        75% { 
            opacity: 1;
            filter: brightness(1.25) saturate(1.4);
        }
    }

    @keyframes backgroundGlow {
        0%, 100% { 
            opacity: 0.2;
            transform: scale(1);
        }
        50% { 
            opacity: 0.6;
            transform: scale(1.2);
        }
    }

    @keyframes backgroundGlowDark {
        0%, 100% { 
            opacity: 0.3;
            transform: scale(1);
        }
        50% { 
            opacity: 0.7;
            transform: scale(1.3);
        }
    }

    @keyframes scanLine {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }

    @keyframes dataFlow {
        0% { transform: translateY(-100%); }
        100% { transform: translateY(100%); }
    }

    @keyframes energyGlow {
        0%, 100% { 
            opacity: 0.4;
            box-shadow: 0 0 20px rgba(200, 170, 189, 0.3);
        }
        50% { 
            opacity: 0.7;
            box-shadow: 0 0 30px rgba(200, 170, 189, 0.6);
        }
    }

    @keyframes dataGlow {
        0%, 100% { 
            opacity: 0.1;
        }
        50% { 
            opacity: 0.3;
        }
    }

    @keyframes pulseGrid {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.6;
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.3);
        }
        50% { 
            transform: scale(1.1);
            opacity: 1;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.6);
        }
    }

    @keyframes connectionFlow {
        0%, 100% { 
            opacity: 0.3;
            transform: scaleX(0.9);
            box-shadow: 0 0 2px rgba(200, 170, 189, 0.2);
        }
        50% { 
            opacity: 0.8;
            transform: scaleX(1.1);
            box-shadow: 0 0 6px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes statusPulse {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.8;
            box-shadow: 0 0 4px rgba(200, 170, 189, 0.3);
        }
        50% { 
            transform: scale(1.15);
            opacity: 1;
            box-shadow: 0 0 12px rgba(200, 170, 189, 0.6);
        }
    }

    /* 新增：科技感动画定义 */
    @keyframes xrayScan {
        0% { 
            transform: translateY(-100%);
            opacity: 0;
        }
        20% { 
            opacity: 1;
        }
        80% { 
            opacity: 1;
        }
        100% { 
            transform: translateY(100vh);
            opacity: 0;
        }
    }

    @keyframes gridPulse {
        0%, 100% { 
            opacity: 0.2;
            transform: scale(1);
        }
        50% { 
            opacity: 0.4;
            transform: scale(1.05);
        }
    }

    @keyframes dataStream {
        0% { 
            transform: translateY(-100%);
            opacity: 0;
        }
        20% { 
            opacity: 0.8;
        }
        80% { 
            opacity: 0.8;
        }
        100% { 
            transform: translateY(100vh);
            opacity: 0;
        }
    }

    @keyframes energyRipple {
        0% { 
            width: 0;
            height: 0;
            opacity: 1;
            border-width: 1px;
        }
        100% { 
            width: 200px;
            height: 200px;
            opacity: 0;
            border-width: 0.5px;
        }
    }

    @keyframes particleFloat {
        0% { 
            transform: translateY(100vh) scale(0);
            opacity: 0;
        }
        10% { 
            opacity: 1;
            transform: translateY(90vh) scale(1);
        }
        90% { 
            opacity: 1;
            transform: translateY(10vh) scale(1);
        }
        100% { 
            transform: translateY(0) scale(0);
            opacity: 0;
        }
    }

    /* 新增：按钮装饰动画 */
    @keyframes buttonLineLeft {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) scaleX(0.8);
        }
        50% { 
            opacity: 1;
            transform: translateY(-50%) scaleX(1.2);
        }
    }

    @keyframes buttonLineRight {
        0%, 100% { 
            opacity: 0.3;
            transform: translateY(-50%) scaleX(0.8);
        }
        50% { 
            opacity: 1;
            transform: translateY(-50%) scaleX(1.2);
        }
    }

    @keyframes buttonCenterPulse {
        0%, 100% { 
            transform: translate(-50%, -50%) scale(1);
            opacity: 0.6;
        }
        50% { 
            transform: translate(-50%, -50%) scale(1.3);
            opacity: 1;
        }
    }

    /* 新增：悬停效果动画 */
    @keyframes techCornerHover {
        0% { 
            transform: scale(1);
            opacity: 0.6;
        }
        100% { 
            transform: scale(1.2);
            opacity: 1;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes statusIndicatorHover {
        0% { 
            transform: scale(1);
            opacity: 0.8;
        }
        100% { 
            transform: scale(1.3);
            opacity: 1;
            box-shadow: 0 0 12px rgba(200, 170, 189, 0.6);
        }
    }

    @keyframes statusRing {
        0%, 100% { 
            transform: scale(1);
            opacity: 0.6;
            box-shadow: 0 0 3px rgba(200, 170, 189, 0.2);
        }
        50% { 
            transform: scale(1.2);
            opacity: 0.3;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.4);
        }
    }

    @keyframes floatParticle {
        0%, 100% { 
            transform: translateY(0px) translateX(0px);
            opacity: 0.4;
            box-shadow: 0 0 2px rgba(200, 170, 189, 0.2);
        }
        25% { 
            transform: translateY(-3px) translateX(2px);
            opacity: 0.8;
            box-shadow: 0 0 6px rgba(200, 170, 189, 0.4);
        }
        50% { 
            transform: translateY(-2px) translateX(-1px);
            opacity: 0.6;
            box-shadow: 0 0 4px rgba(200, 170, 189, 0.3);
        }
        75% { 
            transform: translateY(-4px) translateX(3px);
            opacity: 0.9;
            box-shadow: 0 0 8px rgba(200, 170, 189, 0.5);
        }
    }

    /* ====== 新增科技化元素 END ====== */

    /* V18.0 新增：表情包与HTML内容专属样式 */
    .chat-message.html-content-bubble, /* <-- 在这里添加新类名 */
    .chat-message.sticker-message.sticker-bubble,
    .chat-message.sticker-message {
        background: transparent !important; /* 让气泡背景变透明 */
        background-color: transparent !important; /* 兼容性 */
        background-image: none !important; /* 移除渐变背景 */
        padding: 0 !important; /* 移除内边距 */
        box-shadow: none !important; /* 移除阴影 */
        border: none !important; /* 移除边框 */
        backdrop-filter: none !important; /* 移除毛玻璃效果 */
        -webkit-backdrop-filter: none !important; /* Safari兼容 */
    }

    .sticker-image {
        max-width: 120px; /* 限制表情包最大宽度 */
        max-height: 120px; /* 限制表情包最大高度 */
        display: block; /* 确保它是个块级元素 */
    }

    /* V33.0 新增：日记本更新辉光效果 */
    @keyframes diary-glow-pulse {
        0% {
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 0 0 0 rgba(253, 124, 159, 0.3); /* 粉红色光晕 #FD7C9F */
            transform: translateY(0) rotate(0) scale(1);
        }
        50% {
            box-shadow: 
                0 12px 35px rgba(0, 0, 0, 0.4),
                0 0 10px 4px rgba(253, 124, 159, 0.5); /* 光晕扩大 */
            transform: translateY(-2px) rotate(0.5deg) scale(1.01); /* 轻微浮动 */
        }
        100% {
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 0 0 0 rgba(253, 124, 159, 0.3);
            transform: translateY(0) rotate(0) scale(1);
        }
    }

    .diary-book-item.new-entry {
        animation: diary-glow-pulse 2.5s infinite ease-in-out;
        border-color: rgba(253, 124, 159, 0.4); /* 边框也带上微光 */
    }

    /* 日间模式下的辉光适配 */
    .light-mode .diary-book-item.new-entry {
         animation: diary-glow-pulse-light 2.5s infinite ease-in-out;
         border-color: rgba(187, 44, 87, 0.4); /* 粉红色光晕 */
    }

    @keyframes diary-glow-pulse-light {
        0% {
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.15),
                0 0 0 0 rgba(187, 44, 87, 0.2);
        }
        50% {
            box-shadow: 
                0 12px 35px rgba(0, 0, 0, 0.2),
                0 0 10px 4px rgba(187, 44, 87, 0.3);
        }
        100% {
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.15),
                0 0 0 0 rgba(187, 44, 87, 0.2);
        }
    }

    /* V36.2 终极版：强制保护所有图标，确保万无一失 */
    .fab, .fa-brands,
    i.fab, i.fa-brands {
        font-family: "Font Awesome 6 Brands" !important;
        font-weight: 400 !important;
    }
    .fas, .fa-solid,
    i.fas, i.fa-solid {
        font-family: "Font Awesome 6 Free" !important;
        font-weight: 900 !important;
    }
    .far, .fa-regular,
    i.far, i.fa-regular {
        font-family: "Font Awesome 6 Free" !important;
        font-weight: 400 !important;
    }
    [class^="ri-"], [class*=" ri-"],
    i[class^="ri-"], i[class*=" ri-"] {
        font-family: "RemixIcon" !important;
        font-weight: normal !important;
    }
    /* 所有fa-开头的类 */
    [class^="fa-"], [class*=" fa-"] {
        font-family: "Font Awesome 6 Free" !important;
        font-weight: 900 !important;
    }

        /* ====== 记忆胶囊App - 时光回廊 V2.0 ====== */

        #timeline-container {
            background: #1a1a1a;
        }
        .light-mode #timeline-container {
            background: #f3f4f6;
        }

        #timeline-core {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #timeline-core::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0));
            z-index: 1;
        }
        .light-mode #timeline-core::before {
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0));
        }

        .timeline-item {
            position: relative;
            width: 60%;
            padding: 0 2.5rem;
            margin-bottom: 1.5rem;
            box-sizing: border-box;
        }

        .timeline-node {
            position: absolute;
            top: 1.25rem;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            z-index: 10;
            transition: all 0.3s ease;
        }
        .dark-mode .timeline-node {
            background: #1a1a1a;
            border: 3px solid #9ca3af;
        }
        .light-mode .timeline-node {
            background: #f3f4f6;
            border: 3px solid #6b7280;
        }
        .timeline-item:hover .timeline-node {
            background: #fff;
            box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5);
        }
        .light-mode .timeline-item:hover .timeline-node {
            background: #1f2937;
            box-shadow: 0 0 10px 2px rgba(0, 0, 0, 0.3);
        }


        .timeline-item:nth-child(odd) { align-self: flex-start; }
        .timeline-item:nth-child(odd) .timeline-node { right: -1px; }
        .timeline-item:nth-child(odd) .memory-card-timeline { text-align: right; }

        .timeline-item:nth-child(even) { align-self: flex-end; }
        .timeline-item:nth-child(even) .timeline-node { left: -1px; }

        .memory-card-timeline {
            padding: 1rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background 0.3s, transform 0.3s, box-shadow 0.3s;
        }
        .dark-mode .memory-card-timeline {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .light-mode .memory-card-timeline {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
        }

        .memory-card-timeline:hover {
            transform: translateY(-5px);
        }
        .dark-mode .memory-card-timeline:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .light-mode .memory-card-timeline:hover {
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.07);
        }


        .card-title-timeline {
            font-family: 'Playfair Display', serif;
            font-weight: 600;
            margin-bottom: 0.25rem;
            font-size: 1.1rem;
        }
        .dark-mode .card-title-timeline { color: #fff; }
        .light-mode .card-title-timeline { color: #111827; }

        .card-timestamp-timeline {
            font-size: 0.6rem;
            margin-bottom: 0.75rem;
        }
        .dark-mode .card-timestamp-timeline { color: #9ca3af; }
        .light-mode .card-timestamp-timeline { color: #6b7280; }

        .card-content-preview-timeline {
            font-size: 0.85rem;
            opacity: 0.9;
            line-height: 1.6;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        .dark-mode .card-content-preview-timeline { color: #d1d5db; }
        .light-mode .card-content-preview-timeline { color: #374151; }

        .card-feeling-preview-timeline {
            font-size: 0.8rem;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 0.5rem;
        }
        .dark-mode .card-feeling-preview-timeline { color: #9ca3af; }
        .light-mode .card-feeling-preview-timeline { color: #6b7280; }

        .card-actions-timeline {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            justify-content: flex-end;
        }

        .add-feeling-btn-timeline,
        .delete-memory-btn-timeline {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-size: 0.7rem;
        }

        .add-feeling-btn-timeline {
            background: #3b82f6;
            color: white;
        }
        .add-feeling-btn-timeline:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .delete-memory-btn-timeline {
            background: #ef4444;
            color: white;
        }
        .delete-memory-btn-timeline:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        .character-select-item {
            transition: all 0.3s ease;
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            color: #1f2937;
        }
        
        .dark-mode .character-select-item {
            background-color: #000000;
            border: 1px solid #374151;
            color: #f9fafb;
        }
        
        .character-select-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .dark-mode .character-select-item:hover {
            box-shadow: 0 8px 25px rgba(255,255,255,0.1);
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
        }
        .dark-mode .empty-state { color: #6b7280; }
        .light-mode .empty-state { color: #9ca3af; }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }




        /* ====== 解决方案：修复iOS全屏模式下的状态栏重叠和拉伸问题 ====== */

        /* 仅在全屏模式下生效 */
        body.fullscreen-active {
            margin: 0;
            overflow: hidden; /* 防止意外的滚动 */
            background-color: transparent; /* 新增：让body背景透明 */
        }

        /* 当进入全屏模式时，覆盖桌面端的样式 */
        .fullscreen-active .phone-frame {
            max-width: none;
            max-height: none;
            border-radius: 0;
            box-shadow: none;
            margin: 0;
            
            /* 保持标准视口尺寸，但底部稍微增加安全区域高度 */
            width: 100vw;
            height: calc(100dvh + env(safe-area-inset-bottom)); /* 核心修改：vh -> dvh */
            
            /* 核心修复：添加安全区域内边距，这将在顶部和底部创建出您想要的"黑色遮挡条" */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            
            /* 确保内容区域能够充分利用增加的空间 */
            box-sizing: border-box;
        }

        /* 仅在全屏模式下，精确调整Dock栏的位置 */
        .fullscreen-active .dock {
            /* 在您原有的 1rem 基础上，增加底部安全区域的高度 */
            bottom: calc(1rem + env(safe-area-inset-bottom)); 
            
            /* （可选）让Dock栏在全屏下稍微变宽，视觉效果更好 */
            width: 95%;
            max-width: 600px;
        }
        
        /* 新增：确保在真正的移动设备上标题栏始终可见 */
        @media (max-width: 768px) and (pointer: coarse) {
            body:not(.fullscreen-active) .app-header {
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
                position: relative !important;
                z-index: 20 !important;
                min-height: 4.5rem !important;
                overflow: visible !important;
            }
            
            body:not(.fullscreen-active) .app-header-title {
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
        }
        
        /* 新增：精确调整所有App顶栏在全屏下的位置 */
        .fullscreen-active .app-header {
            /* 在全屏模式下保持标题栏显示 */
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        /* 高优先级：确保全屏模式下标题栏正常显示，不受任何媒体查询影响 */
        @media all {
            .fullscreen-active .app-header {
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .fullscreen-active .app-header-title {
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
        }

        /* ====== 【【新增】】剧场 App 样式 ====== */
        
        /* 剧场主题自定义CSS变量 */
        :root {
            --scenario-bg-color: #4d3a2a;
            --scenario-header-color: #4d3a2a;
            --scenario-title-color: #f5f2ed;
            --scenario-content-color: #3e2723;
            --scenario-content-bg-color: #f5f2ed;
            --scenario-input-border-color: #8b6559;
            --scenario-refresh-btn-color: #8b6559;
            --scenario-send-btn-color: #6d4c41;
            --scenario-send-btn-border-color: #5d4037;
            --scenario-bg-image: none;
            --scenario-bg-opacity: 0.7;
            --scenario-bg-blur: 2px;
        }

        /* 剧场主题背景图片样式 */
        #theater-screen {
            position: relative;
            overflow: hidden;
        }

        #theater-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: var(--scenario-bg-image);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: local;
            opacity: var(--scenario-bg-opacity);
            filter: blur(var(--scenario-bg-blur));
            z-index: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        #theater-screen > * {
            position: relative;
            z-index: 10;
        }

        /* 确保剧场内容在背景图片之上 */
        #theater-screen .scenario-header,
        #theater-screen .scenario-content,
        #theater-screen .scenario-input-area {
            position: relative;
            z-index: 20;
        }

        .script-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            position: relative; /* 让按钮可以相对于卡片定位 */
        }
        .light-mode .script-card {
            background: #ffffff;
            border-color: #e5e7eb;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .script-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            border-color: rgba(147, 197, 253, 0.4);
        }
        .script-card-title {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 0.5rem;
        }
        .script-card-summary {
            font-size: 0.7rem;
            opacity: 0.7;
            line-height: 1.5;
        }
        .script-delete-btn {
            width: 1.5rem;
            height: 1.5rem;
            background: none; /* 无背景 */
            color: #9ca3af; /* 更浅的灰色 */
            border: none; /* 无边框 */
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7; /* 半透明，更低调 */
            transition: all 0.2s ease;
        }
        .script-delete-btn:hover {
            color: #ef4444; /* 悬停时变红色 */
            opacity: 1; /* 悬停时完全不透明 */
            transform: scale(1.1); /* 稍微放大 */
        }

        .script-card-actions {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            display: flex;
            gap: 0.25rem;
            z-index: 10;
        }

        .script-edit-btn {
            width: 1.5rem;
            height: 1.5rem;
            background: none;
            color: #9ca3af;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            transition: all 0.2s ease;
        }

        .script-edit-btn:hover {
            color: #3b82f6; /* 悬停时变蓝色 */
            opacity: 1;
            transform: scale(1.1);
        }

        /* 剧场界面 - 质感阅读体验 (V2.0 皮质效果) */
        #scenario-interaction-view {
            /* 使用CSS变量创建可自定义的背景 */
            background: var(--scenario-bg-color);
            position: relative;
            z-index: 1;
            /* 添加内阴影增加深度感 */
            box-shadow: 
                inset 0 0 80px rgba(0,0,0,0.4),
                inset 0 0 40px rgba(0,0,0,0.2);
        }

        /* 当有背景图片时，让scenario-interaction-view透明 */
        .has-bg-image #scenario-interaction-view {
            background: transparent !important;
            box-shadow: none !important;
        }

        /* 当有背景图片时，隐藏背景纹理层 */
        .has-bg-image #scenario-interaction-view::before {
            display: none !important;
        }

        /* 背景纹理层 */
        #scenario-interaction-view::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.02) 0%, transparent 50%),
                radial-gradient(circle at 50% 80%, rgba(255, 255, 255, 0.015) 0%, transparent 50%),
                linear-gradient(45deg, rgba(255, 255, 255, 0.01) 25%, transparent 25%),
                linear-gradient(-45deg, rgba(255, 255, 255, 0.01) 25%, transparent 25%);
            background-size: 120px 120px, 80px 80px, 150px 150px, 20px 20px, 20px 20px;
            pointer-events: none;
            z-index: -1;
        }

        /* 剧本界面标题栏美化 - 可自定义风格 */
        #scenario-interaction-view .app-header {
            padding-top: 1.2rem;
            padding-bottom: 0.4rem;
            /* 使用CSS变量的背景 */
            background: var(--scenario-header-color);
            /* 边框和阴影效果 */
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            /* 增加质感 */
            position: relative;
            overflow: hidden;
            z-index: 2;
            /* 修改布局以确保标题居中，按钮靠右 */
            display: flex;
            align-items: center;
            justify-content: flex-start;
        }

        /* 标题栏顶部光泽效果 */
        #scenario-interaction-view .app-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, 
                rgba(139, 101, 89, 0.15) 0%, 
                transparent 100%);
            pointer-events: none;
            z-index: 1;
        }

        #scenario-interaction-view .app-header-title {
            transform: translateY(8px); /* 调整标题下移，与按钮对齐 */
            color: var(--scenario-title-color) !important; /* 使用CSS变量 */
            text-shadow: 
                0 1px 2px rgba(0, 0, 0, 0.5),
                0 0 8px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 3;
            font-weight: 600;
            letter-spacing: 0.5px;
            /* 让标题在容器中居中，不被边距影响 */
            margin: 0 auto;
            text-align: center;
        }

        #scenario-interaction-view .app-header .text-xs {
            color: var(--scenario-title-color) !important; /* 使用CSS变量 */
            opacity: 0.8;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
            position: relative;
            z-index: 3;
            transform: translateY(6px);
        }

        #scenario-interaction-view .app-header-btn {
            color: var(--scenario-title-color) !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 3;
            transition: all 0.3s ease;
            border-radius: 6px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(2px);
            min-width: 36px;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #scenario-interaction-view .app-header-btn:hover {
            background: rgba(0, 0, 0, 0.35);
            color: var(--scenario-title-color) !important;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
            opacity: 0.9;
        }

        /* hover状态的特殊处理 */
        #scenario-interaction-view #scenario-theme-btn:hover,
        #scenario-interaction-view #scenario-settings-btn:hover {
            transform: translateY(-18%); /* hover时在原位置基础上稍微向上移动 */
        }
        
        /* 返回按钮的hover状态 - 无背景 */
        #scenario-interaction-view #scenario-back-btn:hover {
            transform: translateY(-18%); /* hover时在原位置基础上稍微向上移动 */
            background: transparent !important; /* hover时也保持透明 */
            opacity: 0.8; /* 通过透明度变化提供hover反馈 */
        }

        /* 右侧按钮组样式 */
        #scenario-interaction-view .app-header-btn.ml-1 {
            margin-left: 0.25rem; /* 减少按钮间距 */
        }

        /* 确保按钮组位于右侧 */
        #scenario-interaction-view #scenario-theme-btn {
            position: absolute;
            right: 4rem; /* 美化按钮位置 */
            top: 50%;
            transform: translateY(-16%); /* 垂直居中对齐 */
        }

        #scenario-interaction-view #scenario-settings-btn {
            position: absolute;
            right: 1rem; /* 设置按钮位置 */
            top: 50%;
            transform: translateY(-16%); /* 垂直居中对齐 */
        }

        /* 确保返回按钮保持在左侧 */
        #scenario-interaction-view #scenario-back-btn {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-16%); /* 垂直居中对齐 */
            min-width: 44px !important; /* 增大点击区域 */
            min-height: 44px !important; /* 增大点击区域 */
            padding: 12px !important; /* 增加内边距 */
            z-index: 10 !important; /* 确保在最上层 */
            pointer-events: auto !important; /* 确保可以点击 */
            background: transparent !important; /* 透明背景 */
            backdrop-filter: none !important; /* 移除模糊效果 */
        }

        #scenario-content-container {
            font-family: 'Noto Serif SC', serif;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            margin: 15px;
            padding: 15px 20px;
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.2),
                0 4px 16px rgba(139, 101, 89, 0.1);
            position: relative;
            z-index: 2;
            transition: all 0.3s ease;
        }

        #scenario-content-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(139, 101, 89, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 80% 70%, rgba(139, 101, 89, 0.02) 1px, transparent 1px),
                radial-gradient(circle at 40% 80%, rgba(139, 101, 89, 0.025) 1px, transparent 1px);
            background-size: 60px 60px, 80px 80px, 100px 100px;
            border-radius: 20px;
            pointer-events: none;
            opacity: 0.6;
        }

        .scenario-turn {
            padding: 0.8rem 1rem;
            border-radius: 8px;
            line-height: 1.6;
            margin-bottom: 1rem;
            position: relative;
        }

        .turn-actions {
            display: none;
            position: absolute;
            bottom: 0.5rem;
            left: 0.5rem;
            gap: 0.5rem;
            font-size: 0.75rem;
        }

        .scenario-turn:hover .turn-actions {
            display: flex;
        }

        .turn-action-btn {
            border: none;
            color: #333;
            cursor: pointer;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 3px;
            transition: opacity 0.2s ease;
            margin-left: 4px;
        }

        .turn-action-btn.edit-btn {
            background: #fff;
        }

        .turn-action-btn.delete-btn {
            background: #ccc;
        }

        .turn-action-btn:hover {
            opacity: 0.8;
        }

        .edit-mode-actions {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.5rem;
            z-index: 10;
        }

        .edit-mode-btn {
            border: none;
            color: #333;
            cursor: pointer;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 3px;
            transition: opacity 0.2s ease;
            margin-left: 4px;
        }

        .edit-mode-btn.save-btn {
            background: #fff;
        }

        .edit-mode-btn.cancel-btn {
            background: #ccc;
        }

        .edit-mode-btn:hover {
            opacity: 0.8;
        }

        .turn-edit-textarea {
            width: 100%;
            min-height: 100px;
            background: #2a2a2a !important;
            color: #ffffff !important;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 10px;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
        }

        .ai-turn {
            background-color: var(--scenario-content-bg-color);
            color: var(--scenario-content-color);
            font-size: 0.85rem;
            font-weight: 400;
            position: relative;
            padding-left: 2rem;
            padding-right: 2rem;
            border-radius: 8px;
            padding: 1rem 2rem;
            margin: 0.5rem 0;
        }



        .user-turn {
            background: linear-gradient(135deg, var(--scenario-content-bg-color) 0%, rgba(255, 255, 255, 0.8) 100%);
            color: var(--scenario-content-color);
            font-size: 0.8rem;
            line-height: 1.5;
            font-style: italic;
            border-left: 3px solid var(--scenario-input-border-color);
            padding-left: 1.2rem;
            border-radius: 0 8px 8px 0;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .light-mode .user-turn {
            background: linear-gradient(135deg, var(--scenario-content-bg-color) 0%, rgba(255, 255, 255, 0.9) 100%);
            color: var(--scenario-content-color);
            border-left-color: var(--scenario-input-border-color);
        }
        /* 剧场界面输入栏美化 */
        #scenario-input-bar {
            background: var(--scenario-header-color);
            border-top: 2px solid var(--scenario-input-border-color);
            position: relative;
            z-index: 3;
        }

        #scenario-input {
            max-height: 120px;
            background: linear-gradient(145deg, var(--scenario-content-bg-color) 0%, rgba(255, 255, 255, 0.95) 100%);
            border: 2px solid var(--scenario-input-border-color);
            border-radius: 8px;
            color: var(--scenario-content-color);
            font-family: 'Noto Serif SC', serif;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #scenario-input:focus {
            outline: none;
            border-color: var(--scenario-input-border-color);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.1),
                0 0 0 3px rgba(0, 0, 0, 0.2);
        }

        /* 自定义按钮样式 */
        #retry-scenario-turn-btn {
            background: var(--scenario-refresh-btn-color);
            border: 2px solid var(--scenario-refresh-btn-color);
            border-radius: 8px;
            color: #ffffff;
            font-family: 'Noto Serif SC', serif;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        #send-scenario-turn-btn {
            background: var(--scenario-send-btn-color);
            border: 2px solid var(--scenario-send-btn-border-color);
            border-radius: 8px;
            color: #ffffff;
            font-family: 'Noto Serif SC', serif;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        #retry-scenario-turn-btn::before, #send-scenario-turn-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        #retry-scenario-turn-btn:hover, #send-scenario-turn-btn:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            border-color: #bcaaa4;
        }

        #retry-scenario-turn-btn:hover::before, #send-scenario-turn-btn:hover::before {
            left: 100%;
        }

        #retry-scenario-turn-btn:active, #send-scenario-turn-btn:active {
            transform: translateY(0);
            box-shadow: 
                0 2px 4px rgba(62, 39, 35, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #send-scenario-turn-btn {
            background: var(--scenario-send-btn-color);
        }

        /* ====== 栖木 App 样式 (文字卡片) - 栖木主题美化 ====== */

        /* ====== 【【新增】】行内评论框样式 ====== */
        .perch-inline-comment-box {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, rgba(107, 135, 112, 0.15), rgba(108, 169, 132, 0.08));
            border-radius: 0.5rem;
            border: 1px solid rgba(107, 135, 112, 0.3);
            animation: slideDown 0.3s ease-out;
            backdrop-filter: blur(10px);
        }
        .light-mode .perch-inline-comment-box {
            background: linear-gradient(135deg, rgba(192, 214, 149, 0.2), rgba(248, 247, 240, 0.8));
            border-color: rgba(107, 135, 112, 0.4);
        }
        .perch-inline-comment-box textarea {
            width: 100%;
            background: rgba(16, 139, 150, 0.1);
            color: #EDEDED;
            border: 1px solid rgba(107, 135, 112, 0.4);
            border-radius: 0.375rem;
            padding: 0.5rem;
            resize: vertical;
            min-height: 60px;
            font-size: 0.875rem;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .light-mode .perch-inline-comment-box textarea {
            background: rgba(248, 247, 240, 0.9);
            color: #70695D;
            border-color: rgba(107, 135, 112, 0.5);
        }
        .perch-inline-comment-box textarea:focus {
            border-color: #6CA984;
            box-shadow: 0 0 0 2px rgba(108, 169, 132, 0.3);
        }
        .perch-inline-comment-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .perch-inline-comment-actions button {
            padding: 0.35rem 0.8rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
        }
        .perch-inline-comment-actions .cancel-btn {
            background: rgba(112, 105, 93, 0.8);
            color: #EDEDED;
        }
        .light-mode .perch-inline-comment-actions .cancel-btn {
            background: rgba(107, 135, 112, 0.2);
            color: #70695D;
        }
        .perch-inline-comment-actions .post-btn {
            background: linear-gradient(135deg, #6CA984, #8ABCD1);
            color: #EDEDED;
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 栖木互动栏样式 - 树木栖息主题 */
        .perch-interaction-bar {
            display: flex; /* 【核心】将此容器设置为Flex布局 */
            justify-content: space-between; /* 【核心】让内部元素两端对齐 */
            align-items: center; /* 【核心】让内部元素垂直居中 */
            padding: 0.25rem 1rem;
            background: linear-gradient(135deg, rgba(16, 139, 150, 0.1), rgba(107, 135, 112, 0.08));
            border-bottom: 1px solid rgba(108, 169, 132, 0.3);
            backdrop-filter: blur(15px);
            box-shadow: 0 2px 10px rgba(107, 135, 112, 0.1);
        }

        .light-mode .perch-interaction-bar {
            background: linear-gradient(135deg, rgba(192, 214, 149, 0.15), rgba(248, 247, 240, 0.8));
            border-bottom: 1px solid rgba(107, 135, 112, 0.4);
            box-shadow: 0 2px 10px rgba(107, 135, 112, 0.15);
        }

        .perch-user-profile {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            cursor: pointer;
            /* 确保左侧部分不会过度伸展 */
            flex-shrink: 1; 
        }
        
        .perch-user-avatar {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background: linear-gradient(135deg, #6CA984 0%, #8ABCD1 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #EDEDED;
            font-size: 1.25rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(108, 169, 132, 0.4);
            overflow: hidden; /* 确保图片不会超出圆形边界 */
            box-shadow: 0 4px 15px rgba(107, 135, 112, 0.2);

            /* 【核心修正】在这里添加这三行，强制处理所有背景图 */
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
        }
        
        .light-mode .perch-user-avatar {
            border: 2px solid rgba(107, 135, 112, 0.5);
            background: linear-gradient(135deg, #C0D695 0%, #6CA984 100%);
            color: #70695D;
            box-shadow: 0 4px 15px rgba(107, 135, 112, 0.3);
        }
        
        .perch-user-avatar:hover {
            transform: scale(1.05);
            border-color: rgba(108, 169, 132, 0.7);
            box-shadow: 0 0 25px rgba(108, 169, 132, 0.5);
        }
        
        .light-mode .perch-user-avatar:hover {
            border-color: rgba(107, 135, 112, 0.8);
            box-shadow: 0 0 25px rgba(107, 135, 112, 0.4);
        }
        
        .perch-user-avatar.has-custom-image {
            background: none;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* 确保自定义头像图片能够正确显示 */
        .perch-user-avatar.has-custom-image[style*="background-image"] {
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .perch-user-name {
            font-size: 0.875rem;
            font-weight: 600;
            color: #EDEDED;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            background: transparent;
            border: none;
            backdrop-filter: none;
            box-shadow: none;
            text-shadow: 0 1px 3px rgba(16, 139, 150, 0.3);
        }
        
        .light-mode .perch-user-name {
            color: #70695D;
            background: transparent;
            border: none;
            box-shadow: none;
            text-shadow: 0 1px 2px rgba(107, 135, 112, 0.2);
        }
        
        .perch-user-name:hover {
            background: transparent;
            border-color: transparent;
            transform: none;
            box-shadow: none;
            opacity: 0.8;
        }
        
        .light-mode .perch-user-name:hover {
            background: transparent;
            border-color: transparent;
            box-shadow: none;
            opacity: 0.8;
        }
        
        .perch-action-buttons {
            display: flex;
            gap: 0.375rem;
            justify-content: flex-end;
            /* 防止按钮组被压缩 */
            flex-shrink: 0; 
        }
        
        .perch-action-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background: none;
            border: none;
            color: #EDEDED;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.125rem;
        }
        
        .light-mode .perch-action-btn {
            background: none;
            border: none;
            color: #70695D;
        }
        
        .perch-action-btn:hover {
            background: none;
            border: none;
            transform: scale(1.1);
            color: #6CA984;
            text-shadow: 0 0 10px rgba(108, 169, 132, 0.5);
        }
        
        .light-mode .perch-action-btn:hover {
            background: none;
            border: none;
            color: #6B8770;
            transform: scale(1.1);
            text-shadow: 0 0 8px rgba(107, 135, 112, 0.4);
        }
        
        .perch-action-btn:active {
            transform: scale(0.95);
        }
        
        /* 栖木弹窗样式 - 树木栖息主题 */
        #perch-avatar-modal .modal-content,
        #perch-name-modal .modal-content {
            background: linear-gradient(135deg, rgba(16, 139, 150, 0.15), rgba(107, 135, 112, 0.1));
            color: #EDEDED;
            border: 1px solid rgba(108, 169, 132, 0.3);
            backdrop-filter: blur(20px);
            box-shadow: 0 25px 50px rgba(107, 135, 112, 0.2);
        }
        
        .light-mode #perch-avatar-modal .modal-content,
        .light-mode #perch-name-modal .modal-content {
            background: linear-gradient(135deg, rgba(248, 247, 240, 0.95), rgba(192, 214, 149, 0.2));
            color: #70695D;
            border: 1px solid rgba(107, 135, 112, 0.4);
            box-shadow: 0 25px 50px rgba(107, 135, 112, 0.25);
        }
        
        #perch-avatar-modal h3,
        #perch-name-modal h3 {
            color: #6CA984;
            text-shadow: 0 2px 4px rgba(16, 139, 150, 0.3);
        }
        
        .light-mode #perch-avatar-modal h3,
        .light-mode #perch-name-modal h3 {
            color: #6B8770;
            text-shadow: 0 1px 2px rgba(107, 135, 112, 0.2);
        }
        
        #perch-avatar-modal input,
        #perch-name-modal input {
            background: rgba(16, 139, 150, 0.1);
            border: 1px solid rgba(108, 169, 132, 0.4);
            color: #EDEDED;
            backdrop-filter: blur(5px);
        }
        
        .light-mode #perch-avatar-modal input,
        .light-mode #perch-name-modal input {
            background: rgba(248, 247, 240, 0.8);
            border-color: rgba(107, 135, 112, 0.5);
            color: #70695D;
        }
        
        #perch-avatar-modal input:focus,
        #perch-name-modal input:focus,
        .light-mode #perch-avatar-modal input:focus,
        .light-mode #perch-name-modal input:focus {
            border-color: #6CA984;
            outline: none;
            box-shadow: 0 0 0 3px rgba(108, 169, 132, 0.2);
        }

        /* 栖木发布弹窗样式 */
        #new-perch-post-modal .modal-content,
        #perch-echo-modal .modal-content,
        #perch-forward-modal .modal-content,
        #perch-worldview-modal .modal-content,
        #perch-settings-modal .modal-content,
        #perch-custom-npc-modal .modal-content {
            background: linear-gradient(135deg, rgba(16, 139, 150, 0.15), rgba(107, 135, 112, 0.1));
            color: #EDEDED;
            border: 1px solid rgba(108, 169, 132, 0.3);
            backdrop-filter: blur(20px);
            box-shadow: 0 25px 50px rgba(107, 135, 112, 0.2);
        }
        
        .light-mode #new-perch-post-modal .modal-content,
        .light-mode #perch-echo-modal .modal-content,
        .light-mode #perch-forward-modal .modal-content,
        .light-mode #perch-worldview-modal .modal-content,
        .light-mode #perch-settings-modal .modal-content,
        .light-mode #perch-custom-npc-modal .modal-content {
            background: linear-gradient(135deg, rgba(248, 247, 240, 0.95), rgba(192, 214, 149, 0.2));
            color: #70695D;
            border: 1px solid rgba(107, 135, 112, 0.4);
            box-shadow: 0 25px 50px rgba(107, 135, 112, 0.25);
        }

        /* 栖木弹窗标题样式 */
        #new-perch-post-modal h3,
        #perch-echo-modal h3,
        #perch-forward-modal h3,
        #perch-worldview-modal h3,
        #perch-settings-modal h3,
        #perch-custom-npc-modal h3 {
            color: #6CA984;
            text-shadow: 0 2px 4px rgba(16, 139, 150, 0.3);
        }
        
        .light-mode #new-perch-post-modal h3,
        .light-mode #perch-echo-modal h3,
        .light-mode #perch-forward-modal h3,
        .light-mode #perch-worldview-modal h3,
        .light-mode #perch-settings-modal h3,
        .light-mode #perch-custom-npc-modal h3 {
            color: #6B8770;
            text-shadow: 0 1px 2px rgba(107, 135, 112, 0.2);
        }

        /* 栖木输入框样式 */
        #perch-content-input,
        #echo-content-input {
            background: rgba(16, 139, 150, 0.1);
            border: 1px solid rgba(108, 169, 132, 0.4);
            color: #EDEDED;
            backdrop-filter: blur(5px);
            border-radius: 0.5rem;
        }
        
        .light-mode #perch-content-input,
        .light-mode #echo-content-input {
            background: rgba(248, 247, 240, 0.8);
            border-color: rgba(107, 135, 112, 0.5);
            color: #70695D;
        }

        #perch-content-input:focus,
        #echo-content-input:focus {
            border-color: #6CA984;
            box-shadow: 0 0 0 3px rgba(108, 169, 132, 0.2);
            outline: none;
        }

        /* 栖木按钮样式 */
        #confirm-perch-post-btn,
        #confirm-echo-post-btn {
            background: linear-gradient(135deg, #6CA984, #8ABCD1);
            color: #EDEDED;
            border: none;
            transition: all 0.3s ease;
        }

        #confirm-perch-post-btn:hover,
        #confirm-echo-post-btn:hover {
            background: linear-gradient(135deg, #8ABCD1, #6CA984);
            transform: translateY(-1px);
            box-shadow: 0 8px 25px rgba(108, 169, 132, 0.3);
        }

        #cancel-perch-post-btn,
        #cancel-echo-post-btn {
            background: rgba(112, 105, 93, 0.8);
            color: #EDEDED;
            border: 1px solid rgba(112, 105, 93, 0.5);
            transition: all 0.3s ease;
        }

        .light-mode #cancel-perch-post-btn,
        .light-mode #cancel-echo-post-btn {
            background: rgba(107, 135, 112, 0.2);
            color: #70695D;
            border-color: rgba(107, 135, 112, 0.4);
        }

        #cancel-perch-post-btn:hover,
        #cancel-echo-post-btn:hover {
            background: rgba(112, 105, 93, 0.9);
            transform: translateY(-1px);
        }

        .light-mode #cancel-perch-post-btn:hover,
        .light-mode #cancel-echo-post-btn:hover {
            background: rgba(107, 135, 112, 0.3);
        }

        /* 栖木标题特殊样式 - 体现栖息树木的概念 */
        .perch-app-title {
            background: linear-gradient(135deg, #6CA984, #8ABCD1, #6CA984);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: perchTitleGlow 3s ease-in-out infinite;
            text-shadow: 0 0 20px rgba(108, 169, 132, 0.5);
            font-weight: 700;
            letter-spacing: 0.05em;
            position: relative;
        }
        
        .light-mode .perch-app-title {
            background: linear-gradient(135deg, #6B8770, #108B96, #6B8770);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 15px rgba(107, 135, 112, 0.3);
        }

        @keyframes perchTitleGlow {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        .perch-app-title::before {
            content: '🌳';
            position: absolute;
            left: -1.5em;
            opacity: 0.6;
            animation: perchTreeSway 4s ease-in-out infinite;
        }

        .perch-app-title::after {
            content: '🍃';
            position: absolute;
            right: -1.5em;
            opacity: 0.6;
            animation: perchLeafFloat 3s ease-in-out infinite;
        }

        @keyframes perchTreeSway {
            0%, 100% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
        }

        @keyframes perchLeafFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-3px) rotate(5deg); }
            66% { transform: translateY(1px) rotate(-3deg); }
        }
        
        #perch-feed-container {
            background: linear-gradient(135deg, rgba(16, 139, 150, 0.05), rgba(107, 135, 112, 0.03));
            backdrop-filter: blur(10px);
        }
        .light-mode #perch-feed-container {
            background: linear-gradient(135deg, rgba(248, 247, 240, 0.9), rgba(192, 214, 149, 0.1));
        }

        .perch-card {
            background: linear-gradient(135deg, rgba(16, 139, 150, 0.08), rgba(107, 135, 112, 0.05));
            border-radius: 0.75rem;
            padding: 1rem;
            border: 1px solid rgba(108, 169, 132, 0.2);
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(107, 135, 112, 0.1);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .perch-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(107, 135, 112, 0.2);
            border-color: rgba(108, 169, 132, 0.4);
        }
        
        .light-mode .perch-card {
            background: linear-gradient(135deg, rgba(248, 247, 240, 0.95), rgba(192, 214, 149, 0.15));
            border: 1px solid rgba(107, 135, 112, 0.3);
            box-shadow: 0 8px 32px rgba(107, 135, 112, 0.15);
        }
        

        
        .light-mode .perch-card:hover {
            box-shadow: 0 12px 40px rgba(107, 135, 112, 0.25);
            border-color: rgba(107, 135, 112, 0.5);
        }

        .perch-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.75rem;
            padding: 0;
        }
        .perch-avatar {
            width: 2.5rem; height: 2.5rem; border-radius: 50%;
            margin-right: 0.75rem; background: linear-gradient(135deg, #6CA984, #8ABCD1);
            background-position: center; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
            border: 2px solid rgba(108, 169, 132, 0.3);
            box-shadow: 0 4px 15px rgba(107, 135, 112, 0.2);
        }
        .perch-author-info { flex-grow: 1; }
        .perch-author-name { 
            font-weight: 700; 
            font-size: 0.875rem; 
            color: #EDEDED;
            text-shadow: 0 1px 3px rgba(16, 139, 150, 0.3);
        }
        .light-mode .perch-author-name {
            color: #70695D;
            text-shadow: 0 1px 2px rgba(107, 135, 112, 0.2);
        }
        .perch-author-handle { 
            font-size: 0.75rem; 
            color: rgba(138, 188, 209, 0.8);
        }
        .light-mode .perch-author-handle {
            color: rgba(107, 135, 112, 0.7);
        }
        .perch-header-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .perch-delete-btn {
            color: #ef4444;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: all 0.2s;
            font-size: 0.875rem;
        }
        .perch-delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
            color: #dc2626;
        }
        .light-mode .perch-delete-btn {
            color: #dc2626;
        }
        .light-mode .perch-delete-btn:hover {
            background-color: rgba(220, 38, 38, 0.1);
            color: #b91c1c;
        }
        
        /* 评论删除按钮样式 */
        .perch-comment-delete-btn {
            color: #ef4444;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.125rem;
            border-radius: 0.25rem;
            transition: all 0.2s;
            font-size: 0.875rem;
            opacity: 0.7;
        }
        .perch-comment-delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            opacity: 1;
        }
        .light-mode .perch-comment-delete-btn {
            color: #dc2626;
        }
        .light-mode .perch-comment-delete-btn:hover {
            background-color: rgba(220, 38, 38, 0.1);
            color: #b91c1c;
        }
        
        .perch-more-btn { color: #9ca3af; }

        .perch-content {
            white-space: pre-wrap;
            line-height: 1.6;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            color: #EDEDED;
            text-shadow: 0 1px 2px rgba(16, 139, 150, 0.2);
        }
        .light-mode .perch-content {
            color: #70695D;
            text-shadow: 0 1px 1px rgba(107, 135, 112, 0.1);
        }

        .perch-meta {
            font-size: 0.75rem;
            color: rgba(138, 188, 209, 0.7);
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(108, 169, 132, 0.2);
        }
        .light-mode .perch-meta {
            color: rgba(107, 135, 112, 0.6);
            border-color: rgba(107, 135, 112, 0.3);
        }

        .perch-stats {
            display: flex;
            gap: 1.5rem;
            padding: 0.75rem 0;
            font-size: 0.75rem;
            color: rgba(138, 188, 209, 0.7);
            border-bottom: 1px solid rgba(108, 169, 132, 0.2);
        }
        .light-mode .perch-stats {
            color: rgba(107, 135, 112, 0.6);
            border-color: rgba(107, 135, 112, 0.3);
        }
        .perch-stats strong {
            font-weight: 700;
            color: #6CA984;
        }
        .light-mode .perch-stats strong {
            color: #6B8770;
        }

        /* --- V12.2 互动栏高度最终修正 --- */
        .perch-actions {
            display: flex;
            justify-content: space-between; 
            align-items: center;
            font-size: 0.9rem;
            color: rgba(138, 188, 209, 0.8);
            /* 【核心修改】将上下内边距彻底设为 0 */
            padding: 0; 
            max-width: 280px; 
            margin: 0 auto;
            /* 【新增】为配合下方按钮的调整，增加一点上边距，与分割线分隔开 */
            margin-top: 0.25rem;
        }
        .light-mode .perch-actions {
            color: rgba(107, 135, 112, 0.7);
        }

        /* 【新增】精确控制按钮本身的上下间距 */
        .perch-actions button {
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            transition: color 0.2s;
            /* 将按钮的上下内边距设为非常小的值，几乎为零 */
            padding: 0.05rem 0.25rem;
        }
        .perch-actions button:hover {
            color: #6CA984;
            transform: scale(1.1);
        }
        .light-mode .perch-actions button:hover {
            color: #6B8770;
        }

        /* 新增：栖木转发功能样式 */
        .forward-char-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 0.75rem;
        }
        .dark-mode .forward-char-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .light-mode .forward-char-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .chat-message.perch-forward-bubble {
            padding: 0.75rem;
            max-width: 240px;
            border-radius: 0.75rem;
            border-width: 1px;
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.2), rgba(31, 41, 55, 0.15));
            border-color: rgba(75, 85, 99, 0.5);
            box-shadow: none;
        }
        .perch-forward-header {
            font-size: 0.625rem;
            color: #9ca3af;
            border-bottom: 1px solid rgba(75, 85, 99, 0.5);
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .perch-forward-author {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
        }
        .perch-forward-author img {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
        }
        .perch-forward-content {
            white-space: pre-wrap;
            font-size: 0.8rem;
            opacity: 0.9;
            max-height: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ===== 回响功能专用样式 ===== */
        
        /* 回响标识文字样式 */
        .perch-author-info .text-xs.text-gray-500 {
            font-size: 0.625rem;
            color: #9ca3af;
            margin-top: 0.125rem;
        }
        .light-mode .perch-author-info .text-xs.text-gray-500 {
            color: #6b7280;
        }

        /* 原帖预览框样式 */
        .perch-card .mt-2.p-3.border.border-gray-700.rounded-lg {
            background-color: rgba(55, 65, 81, 0.3);
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-top: 0.5rem;
        }
        .light-mode .perch-card .mt-2.p-3.border.border-gray-700.rounded-lg {
            background-color: rgba(229, 231, 235, 0.5);
            border-color: #d1d5db;
        }

        /* 原帖作者信息样式 */
        .perch-card .flex.items-center.mb-2 {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            gap: 0;
        }

        /* 原帖头像样式 */
        .perch-card .perch-avatar.w-6.h-6.mr-2 {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            margin-right: 0;
            background-color: #4b5563;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }
        .light-mode .perch-card .perch-avatar.w-6.h-6.mr-2 {
            background-color: #9ca3af;
        }

        /* 原帖作者名样式 */
        .perch-card .font-semibold.text-sm {
            font-weight: 600;
            font-size: 0.875rem;
            color: #f9fafb;
            margin-left: 0;
            padding-left: 0;
        }
        .light-mode .perch-card .font-semibold.text-sm {
            color: #1f2937;
        }

        /* 原帖内容样式 */
        .perch-card .text-sm.text-gray-300.whitespace-pre-wrap {
            font-size: 0.875rem;
            color: #d1d5db;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        .light-mode .perch-card .text-sm.text-gray-300.whitespace-pre-wrap {
            color: #4b5563;
        }

        /* 回响帖子的评论区样式 */
        .perch-card .perch-comments-container {
            margin-top: 0.5rem;
            border-top: 1px solid #374151;
            padding-top: 0.5rem;
            /* 默认隐藏 */
            display: none;
            /* 确保边框可见 */
            border-color: #374151;
            /* 添加过渡效果 */
            transition: all 0.3s ease;
        }
        .light-mode .perch-card .perch-comments-container {
            border-color: #e5e7eb !important;
        }
        
        /* 隐藏状态 */
        .perch-card .perch-comments-container.hidden {
            display: none !important;
        }
        
        /* 显示状态 - 当没有.hidden类时显示 */
        .perch-card .perch-comments-container:not(.hidden) {
            display: block !important;
        }

        /* 回响帖子的评论样式 */
        .perch-card .perch-comment {
            margin-top: 0.5rem;
            padding: 0.5rem;
            padding-right: 2.5rem; /* 为删除按钮留出空间 */
            border-radius: 0.375rem;
            border: 1px solid #374151;
            background-color: rgba(55, 65, 81, 0.2);
            position: relative; /* 为绝对定位的删除按钮提供定位上下文 */
        }
        
        /* 普通帖子的评论样式 */
        .perch-comment {
            margin-top: 0.5rem;
            padding: 0.5rem;
            padding-right: 2.5rem; /* 为删除按钮留出空间 */
            border-radius: 0.375rem;
            border: 1px solid #374151;
            background-color: rgba(55, 65, 81, 0.2);
            position: relative; /* 为绝对定位的删除按钮提供定位上下文 */
        }
        .light-mode .perch-card .perch-comment {
            border-color: #d1d5db;
            background-color: rgba(229, 231, 235, 0.3);
        }
        
        .light-mode .perch-comment {
            border-color: #d1d5db;
            background-color: rgba(229, 231, 235, 0.3);
        }

        /* 回响帖子的评论作者名样式 */
        .perch-card .perch-comment .font-semibold.text-sm.text-emerald-400 {
            font-weight: 600;
            font-size: 0.75rem;
            color: #34d399;
        }
        .light-mode .perch-card .perch-comment .font-semibold.text-sm.text-emerald-400 {
            color: #10b981;
        }

        /* 回响帖子的评论内容样式 */
        .perch-card .perch-comment .text-sm.ml-1 {
            font-size: 0.75rem;
            margin-left: 0.25rem;
            color: #d1d5db;
        }
        .light-mode .perch-card .perch-comment .text-sm.ml-1 {
            color: #4b5563;
        }
        
        /* 普通帖子的评论作者名样式 */
        .perch-comment .font-semibold.text-sm.text-emerald-400 {
            font-weight: 600;
            font-size: 0.75rem;
            color: #34d399;
        }
        .light-mode .perch-comment .font-semibold.text-sm.text-emerald-400 {
            color: #10b981;
        }
        
        /* 普通帖子的评论内容样式 */
        .perch-comment .text-sm.ml-1 {
            font-size: 0.75rem;
            margin-left: 0.25rem;
            color: #d1d5db;
        }
        .light-mode .perch-comment .text-sm.ml-1 {
            color: #4b5563;
        }

        /* 回响帖子的评论删除按钮样式 */
        .perch-card .perch-comment .perch-comment-delete-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            color: #ef4444;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.125rem;
            border-radius: 0.25rem;
            transition: all 0.2s;
            font-size: 0.75rem;
            opacity: 0.7;
        }
        .perch-card .perch-comment .perch-comment-delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            opacity: 1;
        }
        .light-mode .perch-card .perch-comment .perch-comment-delete-btn {
            color: #dc2626;
        }
        .light-mode .perch-card .perch-comment .perch-comment-delete-btn:hover {
            background-color: rgba(220, 38, 38, 0.1);
            color: #b91c1c;
        }
        
        /* 普通帖子的评论删除按钮样式 */
        .perch-comment .perch-comment-delete-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            color: #ef4444;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.125rem;
            border-radius: 0.25rem;
            transition: all 0.2s;
            font-size: 0.75rem;
            opacity: 0.7;
        }
        .perch-comment .perch-comment-delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            opacity: 1;
        }
        .light-mode .perch-comment .perch-comment-delete-btn {
            color: #dc2626;
        }
        .light-mode .perch-comment .perch-comment-delete-btn:hover {
            background-color: rgba(220, 38, 38, 0.1);
            color: #b91c1c;
        }

        /* 新评论输入按钮样式 */
        .perch-card .perch-comment-input .perch-add-comment-btn {
            background: none;
            border: 1px dashed #6b7280;
            color: #9ca3af;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
            opacity: 0.8;
        }
        .perch-card .perch-comment-input .perch-add-comment-btn:hover {
            border-color: #9ca3af;
            background-color: rgba(156, 163, 175, 0.1);
            color: #d1d5db;
            opacity: 1;
        }
        .light-mode .perch-card .perch-comment-input .perch-add-comment-btn {
            border-color: #d1d5db;
            color: #6b7280;
        }
        .light-mode .perch-card .perch-comment-input .perch-add-comment-btn:hover {
            border-color: #9ca3af;
            background-color: rgba(156, 163, 175, 0.1);
            color: #374151;
        }

        /* 回响帖子的操作按钮样式 */
        .perch-card .perch-actions button {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            transition: color 0.2s;
            padding: 0.25rem 0.375rem;
            border-radius: 0.25rem;
            font-size: 0.85rem;
        }
        .perch-card .perch-actions button:hover {
            color: #6CA984;
            background-color: rgba(108, 169, 132, 0.1);
        }
        .light-mode .perch-card .perch-actions button {
            color: #6b7280;
        }
        .light-mode .perch-card .perch-actions button:hover {
            color: #6B8770;
            background-color: rgba(107, 135, 112, 0.1);
        }

        /* 回响帖子的时间戳样式 */
        .perch-card .perch-meta.mt-2 {
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #9ca3af;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #374151;
        }
        .light-mode .perch-card .perch-meta.mt-2 {
            border-color: #e5e7eb;
        }

        /* ===== 回响弹窗日夜间模式样式 ===== */
        
        /* 回响弹窗中的原帖预览框样式 */
        #perch-echo-modal #original-post-preview {
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .light-mode #perch-echo-modal #original-post-preview {
            background-color: rgba(229, 231, 235, 0.5);
            border-color: #d1d5db;
        }

        /* 回响弹窗中的原帖作者名样式 */
        #perch-echo-modal #original-post-author {
            font-weight: 600;
            font-size: 0.875rem;
            color: #f9fafb;
        }
        
        .light-mode #perch-echo-modal #original-post-author {
            color: #1f2937;
        }

        /* 回响弹窗中的原帖内容样式 */
        #perch-echo-modal #original-post-content {
            font-size: 0.875rem;
            color: #d1d5db;
            line-height: 1.5;
        }
        
        .light-mode #perch-echo-modal #original-post-content {
            color: #4b5563;
        }

        /* 栖木评论切换按钮样式 */
        .perch-comments-toggle button {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            transition: all 0.2s;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin: 0 auto;
        }
        
        .perch-comments-toggle button:hover {
            color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        .light-mode .perch-comments-toggle button {
            color: #6b7280;
        }
        
        .light-mode .perch-comments-toggle button:hover {
            color: #2563eb;
            background-color: rgba(37, 99, 235, 0.1);
        }
        
        .perch-comments-toggle .toggle-icon {
            transition: transform 0.2s;
        }

        /* 回响弹窗中的取消按钮样式 */
        #perch-echo-modal #cancel-echo-post-btn {
            background-color: #6b7280;
            color: #f9fafb;
            border: 1px solid #4b5563;
        }
        
        .light-mode #perch-echo-modal #cancel-echo-post-btn {
            background-color: #e5e7eb;
            color: #374151;
            border-color: #d1d5db;
        }

        /* 回响弹窗中的发布按钮样式 */
        #perch-echo-modal #confirm-echo-post-btn {
            background-color: #3b82f6;
            color: #ffffff;
            border: 1px solid #2563eb;
        }
        
        .light-mode #perch-echo-modal #confirm-echo-post-btn {
            background-color: #2563eb;
            color: #ffffff;
            border-color: #1d4ed8;
        }

        /* 回响弹窗中的标题样式 */
        #perch-echo-modal h3 {
            color: #f9fafb;
        }
        
        .light-mode #perch-echo-modal h3 {
            color: #1f2937;
        }

        /* 回响弹窗中的输入框样式 */
        #perch-echo-modal #echo-content-input {
            background-color: rgba(31, 41, 55, 0.8);
            border: 1px solid #4b5563;
            color: #f9fafb;
        }
        
        .light-mode #perch-echo-modal #echo-content-input {
            background-color: rgba(255, 255, 255, 0.9);
            border-color: #d1d5db;
            color: #1f2937;
        }

        #perch-echo-modal #echo-content-input::placeholder {
            color: #9ca3af;
        }
        
        .light-mode #perch-echo-modal #echo-content-input::placeholder {
            color: #6b7280;
        }

        /* ====== 【【新增】通话记录弹窗样式】 ====== */
        .clickable-log {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .dark-mode .clickable-log:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .light-mode .clickable-log:hover {
            background-color: rgba(0, 0, 0, 0.2);
        }

        .call-log-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 15000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .call-log-content {
            background: #2c2c2e;
            color: #e5e7eb;
            border-radius: 1rem;
            width: 100%;
            max-width: 380px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .light-mode .call-log-content {
            background: #ffffff;
            color: #1f2937;
            border-color: rgba(0,0,0,0.1);
        }

        .call-log-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .light-mode .call-log-header {
            border-color: #e5e7eb;
        }

        .call-log-title {
            font-size: 1.125rem;
            font-weight: 600;
        }

        .call-log-close-btn {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 1.5rem;
            cursor: pointer;
        }
        .light-mode .call-log-close-btn {
            color: #6b7280;
        }

        .call-log-body {
            padding: 1.25rem;
            overflow-y: auto;
            flex: 1;
        }

        .transcript-line {
            margin-bottom: 0.75rem;
            line-height: 1.6;
        }
        .transcript-line i {
            color: #9ca3af;
            display: block; /* 让旁白独占一行，更有电影感 */
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .light-mode .transcript-line i {
            color: #6b7280;
        }

        .call-log-footer {
            padding: 1rem 1.25rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }
        .light-mode .call-log-footer {
            border-color: #e5e7eb;
        }

        .call-log-delete-btn {
            width: 100%;
            padding: 0.75rem;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .call-log-delete-btn:hover {
            background: #dc2626;
        }

        /* 修复：隐藏模型选择框可能出现的额外箭头 */
        #model_select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: none;
        }
        
        /* 确保没有额外的伪元素箭头 */
        #model_select::after,
        #model_select::before {
            display: none !important;
        }

        /* ====== 【新增】栖木通知系统样式 - 树木栖息主题 ====== */
        .notification-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 0.75rem;
            transition: all 0.3s ease;
            cursor: pointer;
            border: 1px solid transparent;
        }
        .dark-mode .notification-item:hover {
            background: linear-gradient(135deg, rgba(108, 169, 132, 0.1), rgba(138, 188, 209, 0.05));
            border-color: rgba(108, 169, 132, 0.2);
            transform: translateY(-1px);
        }
        .light-mode .notification-item:hover {
            background: linear-gradient(135deg, rgba(192, 214, 149, 0.15), rgba(248, 247, 240, 0.8));
            border-color: rgba(107, 135, 112, 0.3);
            transform: translateY(-1px);
        }

        .notification-item.unread {
            position: relative;
        }
        .dark-mode .notification-item.unread {
            background: linear-gradient(135deg, rgba(108, 169, 132, 0.15), rgba(16, 139, 150, 0.08));
            border: 1px solid rgba(108, 169, 132, 0.3);
            box-shadow: 0 4px 15px rgba(108, 169, 132, 0.1);
        }
        .light-mode .notification-item.unread {
            background: linear-gradient(135deg, rgba(192, 214, 149, 0.2), rgba(248, 247, 240, 0.9));
            border: 1px solid rgba(107, 135, 112, 0.4);
            box-shadow: 0 4px 15px rgba(107, 135, 112, 0.15);
        }

        .notification-avatar {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            border: 2px solid rgba(108, 169, 132, 0.3);
            box-shadow: 0 4px 15px rgba(107, 135, 112, 0.2);
        }
        .notification-content {
            flex-grow: 1;
            font-size: 0.875rem;
            color: #EDEDED;
        }
        .light-mode .notification-content {
            color: #70695D;
        }
        .notification-text strong {
            font-weight: 600;
        }
        .dark-mode .notification-text strong {
            color: #6CA984; /* 栖木绿色高亮 */
            text-shadow: 0 1px 2px rgba(16, 139, 150, 0.3);
        }
        .light-mode .notification-text strong {
            color: #6B8770;
            text-shadow: 0 1px 1px rgba(107, 135, 112, 0.2);
        }
        .notification-quote {
            margin-top: 0.25rem;
            padding-left: 0.5rem;
            border-left: 2px solid;
            font-style: italic;
            opacity: 0.8;
            background: rgba(108, 169, 132, 0.05);
            border-radius: 0 0.25rem 0.25rem 0;
        }
        .dark-mode .notification-quote {
            border-color: rgba(138, 188, 209, 0.6);
        }
        .light-mode .notification-quote {
            border-color: rgba(107, 135, 112, 0.6);
            background: rgba(192, 214, 149, 0.1);
        }
        .notification-timestamp {
            font-size: 0.75rem;
            margin-top: 0.25rem;
            opacity: 0.6;
        }

        /* ====== 【新增】引用回复功能样式 ====== */
        #reply-preview-bar {
            transition: all 0.2s ease-in-out;
        }
        .dark-mode #reply-preview-bar {
            background-color: rgba(55, 65, 81, 0.5);
            border-color: rgba(255, 255, 255, 0.1);
            color: #d1d5db;
        }
        .light-mode #reply-preview-bar {
            background-color: rgba(243, 244, 246, 0.8);
            border-color: rgba(0, 0, 0, 0.1);
            color: #4b5563;
        }
        #reply-preview-bar.visible {
            display: flex;
        }

        .quoted-message {
            margin-bottom: 0.375rem; /* 6px */
            padding: 0.5rem 0.75rem; /* 8px 12px */
            border-left-width: 2px;
            border-radius: 0.375rem; /* 6px */
            font-size: 0.8em;
            opacity: 0.8;
        }
        .dark-mode .quoted-message {
            background-color: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
        }
        .light-mode .quoted-message {
            background-color: rgba(0, 0, 0, 0.04);
            border-color: rgba(0, 0, 0, 0.1);
        }
        .quoted-author {
            font-weight: 600;
            margin-bottom: 0.125rem; /* 2px */
        }
        .dark-mode .quoted-author {
            color: #93c5fd; /* 浅蓝色 */
        }
        .light-mode .quoted-author {
            color: #3b82f6; /* 蓝色 */
        }
        .quoted-content {
            /* white-space: nowrap; */ /* 我们不再需要这行，可以删除或注释掉 */
            overflow: hidden;
            text-overflow: ellipsis;
            /* 新增下面四行，实现最多显示2行，超出部分显示省略号 */
            display: -webkit-box;
            -webkit-line-clamp: 2; /* 您可以修改这个数字来控制最多显示几行 */
            line-clamp: 2; /* 标准属性，提供更好的兼容性 */
            -webkit-box-orient: vertical;
        }

        /* ====== 【【新增】】礼物商城样式 ====== */
        .gift-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .light-mode .gift-item {
            background: #ffffff;
            border-color: #e5e7eb;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .gift-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            border-color: rgba(147, 197, 253, 0.4);
        }
        .light-mode .gift-item:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .gift-icon {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
            color: #93c5fd;
        }
        .light-mode .gift-icon { color: #3b82f6; }
        .gift-name {
            font-weight: 600;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        .gift-price {
            font-size: 0.75rem;
            color: #fBBF24; /* Amber 400 */
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        .gift-description {
            font-size: 0.7rem;
            opacity: 0.7;
            line-height: 1.5;
            flex-grow: 1; /* 让描述占据剩余空间 */
        }

        /* ====== 【【新增】】聊天中的礼物气泡样式 ====== */
        .chat-message.gift-bubble {
            padding: 0;
            width: 220px;
            border-radius: 0.75rem;
            overflow: hidden;
            border: 1px solid rgba(147, 197, 253, 0.3);
            background: linear-gradient(135deg, #1e3a8a, #3b82f6);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }
        .light-mode .chat-message.gift-bubble {
            border-color: rgba(59, 130, 246, 0.4);
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
        }
        .gift-bubble.received { /* AI送的礼物用紫色系 */
            background: linear-gradient(135deg, #5b21b6, #a78bfa);
            border-color: rgba(167, 139, 250, 0.4);
        }
        .light-mode .gift-bubble.received {
             background: linear-gradient(135deg, #f5f3ff, #ede9fe);
             border-color: rgba(139, 92, 246, 0.4);
        }

        .gift-bubble-header {
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #dbeafe;
            font-size: 0.7rem;
            font-weight: 500;
            background: rgba(255,255,255,0.1);
        }
        .light-mode .gift-bubble-header {
            color: #3b82f6;
            background: rgba(255,255,255,0.5);
        }
        .gift-bubble.received .gift-bubble-header {
            color: #ede9fe;
        }
        .light-mode .gift-bubble.received .gift-bubble-header {
            color: #7c3aed;
        }
        
        .gift-bubble-content {
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .gift-bubble-icon {
            font-size: 2.5rem;
            color: #ffffff;
        }
        .light-mode .gift-bubble-icon {
            color: #1e3a8a;
        }
        .gift-bubble.received .gift-bubble-icon {
            color: #ffffff;
        }
        .light-mode .gift-bubble.received .gift-bubble-icon {
            color: #5b21b6;
        }
        
        .gift-bubble-info { flex: 1; }
        .gift-bubble-name {
            font-weight: 700;
            color: #ffffff;
        }
        .light-mode .gift-bubble-name {
            color: #1e3a8a;
        }
        .gift-bubble.received .gift-bubble-name {
            color: #ffffff;
        }
        .light-mode .gift-bubble.received .gift-bubble-name {
            color: #5b21b6;
        }

        .gift-bubble-user-msg {
            font-size: 0.8rem;
            color: #dbeafe;
            font-style: italic;
            margin-top: 0.25rem;
            opacity: 0.9;
        }
        .light-mode .gift-bubble-user-msg {
            color: #3b82f6;
        }
        .gift-bubble.received .gift-bubble-user-msg {
            color: #ede9fe;
        }
        .light-mode .gift-bubble.received .gift-bubble-user-msg {
            color: #7c3aed;
        }

        /* ====== 【【新增】】胶囊管理中心列表项样式 ====== */
        .capsule-manager-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            padding: 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .light-mode .capsule-manager-item {
            background: #f9fafb;
            border-color: #e5e7eb;
        }
        .capsule-manager-item .info {
            flex-grow: 1;
        }
        .capsule-manager-item .actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
            margin-left: 1rem;
        }
        .capsule-manager-item .actions button {
            padding: 0.3rem 0.6rem;
            font-size: 0.75rem;
            border-radius: 0.375rem;
        }

        /* ====== 【【新增】】消息撤回功能样式 ====== */
        .recall-notification {
            background-color: rgba(128, 128, 128, 0.2);
            color: #9ca3af; /* 调整为更柔和的灰色 */
            font-size: 0.75rem;
            padding: 0.35rem 0.85rem;
            border-radius: 9999px;
            margin: 0.5rem auto;
            width: fit-content;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .light-mode .recall-notification {
            background-color: rgba(0, 0, 0, 0.08);
            color: #6b7280;
        }
        .recall-notification:hover {
            background-color: rgba(128, 128, 128, 0.3);
            transform: scale(1.05);
        }
        .light-mode .recall-notification:hover {
            background-color: rgba(0, 0, 0, 0.12);
        }

        /* 撤回消息详情弹窗 */
        #recalled-message-modal .modal-content {
            max-width: 340px;
            padding: 1.5rem;
            font-family: 'Noto Serif SC', serif;
        }
        #recalled-modal-title {
            font-size: 1.25rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 1.5rem;
            color: #e5e7eb;
        }
        .light-mode #recalled-modal-title {
            color: #1f2937;
        }
        .recalled-section-header {
            font-size: 0.8rem;
            font-weight: 600;
            color: #9ca3af;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.25rem;
        }
        .light-mode .recalled-section-header {
            color: #6b7280;
            border-bottom-color: rgba(0, 0, 0, 0.1);
        }
        #recalled-original-content {
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1.25rem;
            line-height: 1.6;
        }
        .light-mode #recalled-original-content {
            background: rgba(0, 0, 0, 0.04);
        }
        #recalled-reason {
            font-style: italic;
            color: #d1d5db;
            line-height: 1.6;
            opacity: 0.9;
        }
        .light-mode #recalled-reason {
            color: #4b5563;
        }

        /* 【【新增】】撤回消息弹窗的底部和删除按钮样式 */
        .recalled-modal-footer {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }
        .light-mode .recalled-modal-footer {
            border-top-color: rgba(0, 0, 0, 0.1);
        }
        .delete-recalled-btn {
            background-color: rgba(239, 68, 68, 0.2);
            color: #fca5a5; /* a softer red text */
            border: 1px solid rgba(239, 68, 68, 0.4);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .delete-recalled-btn:hover {
            background-color: rgba(239, 68, 68, 0.4);
            color: #f87171;
            transform: scale(1.05);
        }
        .light-mode .delete-recalled-btn {
            background-color: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border-color: rgba(239, 68, 68, 0.3);
        }
        .light-mode .delete-recalled-btn:hover {
            background-color: rgba(239, 68, 68, 0.2);
            color: #dc2626;
        }

        /* ====== 【【终极栖木头像修复方案】】 ====== */

        /* 1. 这是外层的"圆形相框"，专门负责裁剪 */
        .perch-avatar-wrapper {
            width: 2.5rem;      /* 确定头像大小 (40px) */
            height: 2.5rem;     /* 确定头像大小 (40px) */
            border-radius: 50%; /* 强制圆形 */
            overflow: hidden;   /* 【【最关键】】把所有超出圆形的内容都剪掉！ */
            flex-shrink: 0;     /* 防止在flex布局中被挤压变形 */
            margin-right: 0.75rem; /* 和右边文字的间距 */
            
            /* (可选) 给相框加个好看的边框，和你的截图风格一致 */
            border: 1px solid rgba(108, 169, 132, 0.4); 
            background-color: #f0f0f0; /* 图片加载失败时的底色 */
        }

        /* 2. 这是内层的"照片"，专门负责显示图片 */
        .perch-avatar-wrapper .perch-avatar {
            width: 100%;        /* 撑满整个相框 */
            height: 100%;       /* 撑满整个相框 */
            background-size: cover;    /* 图片缩放以完全覆盖容器，不变形 */
            background-position: center; /* 图片居中显示 */
            background-repeat: no-repeat;
        }

        /* ====== 【【栖木标题栏位置调整】】 ====== */
        /* 让栖木的标题栏（返回键、标题、设置键）统一下移一点 */
        #perch-screen .app-header {
            padding-top: 1rem !important;    /* 增加顶部内边距，让整个标题栏下移 */
            padding-bottom: 0.5rem !important;
            height: 5rem !important;          /* 相应增加标题栏总高度 */
            min-height: 5rem !important;
        }

        /* 确保栖木标题栏中的按钮和标题都受到影响 */
        #perch-screen .app-header-btn,
        #perch-screen .app-header-title {
            margin-top: 0.25rem !important;  /* 额外的微调下移 */
        }

    </style>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{inset:0px}.-right-1{right:-0.25rem}.-top-1{top:-0.25rem}.bottom-2{bottom:0.5rem}.bottom-4{bottom:1rem}.left-0{left:0px}.left-1\/2{left:50%}.left-2{left:0.5rem}.right-0{right:0px}.right-2{right:0.5rem}.right-3{right:0.75rem}.right-4{right:1rem}.top-0{top:0px}.top-1\/2{top:50%}.top-14{top:3.5rem}.top-2{top:0.5rem}.top-4{top:1rem}.top-3{top:0.75rem}.z-0{z-index:0}.z-10{z-index:10}.z-20{z-index:20}.z-50{z-index:50}.z-\[15000\]{z-index:15000}.z-\[16000\]{z-index:16000}.z-\[9400\]{z-index:9400}.mx-2{margin-left:0.5rem;margin-right:0.5rem}.mx-4{margin-left:1rem;margin-right:1rem}.my-2{margin-top:0.5rem;margin-bottom:0.5rem}.mb-1{margin-bottom:0.25rem}.mb-2{margin-bottom:0.5rem}.mb-3{margin-bottom:0.75rem}.mb-4{margin-bottom:1rem}.mb-6{margin-bottom:1.5rem}.ml-1{margin-left:0.25rem}.ml-2{margin-left:0.5rem}.ml-3{margin-left:0.75rem}.ml-4{margin-left:1rem}.mr-1{margin-right:0.25rem}.mr-2{margin-right:0.5rem}.mr-3{margin-right:0.75rem}.mt-1{margin-top:0.25rem}.mt-2{margin-top:0.5rem}.mt-3{margin-top:0.75rem}.mt-4{margin-top:1rem}.mt-6{margin-top:1.5rem}.mt-8{margin-top:2rem}.mt-auto{margin-top:auto}.block{display:block}.flex{display:flex}.inline-flex{display:inline-flex}.grid{display:grid}.list-item{display:list-item}.hidden{display:none}.aspect-square{aspect-ratio:1 / 1}.h-10{height:2.5rem}.h-12{height:3rem}.h-16{height:4rem}.h-2{height:0.5rem}.h-20{height:5rem}.h-24{height:6rem}.h-3{height:0.75rem}.h-32{height:8rem}.h-4{height:1rem}.h-48{height:12rem}.h-5{height:1.25rem}.h-6{height:1.5rem}.h-64{height:16rem}.h-auto{height:auto}.h-full{height:100%}.h-\[90vh\]{height:90vh}.max-h-24{max-height:6rem}.max-h-48{max-height:12rem}.max-h-60{max-height:15rem}.max-h-\[80vh\]{max-height:80vh}.max-h-\[85vh\]{max-height:85vh}.max-h-\[90vh\]{max-height:90vh}.max-h-full{max-height:100%}.min-h-\[50px\]{min-height:50px}.min-h-screen{min-height:100vh}.w-1\/2{width:50%}.w-10{width:2.5rem}.w-11{width:2.75rem}.w-12{width:3rem}.w-2{width:0.5rem}.w-20{width:5rem}.w-3{width:0.75rem}.w-5{width:1.25rem}.w-6{width:1.5rem}.w-8{width:2rem}.w-9{width:2.25rem}.w-\[90\%\]{width:90%}.w-\[95\%\]{width:95%}.w-full{width:100%}.max-w-4xl{max-width:56rem}.max-w-\[320px\]{max-width:320px}.max-w-\[340px\]{max-width:340px}.max-w-\[350px\]{max-width:350px}.max-w-\[400px\]{max-width:400px}.max-w-\[420px\]{max-width:420px}.max-w-\[450px\]{max-width:450px}.max-w-\[460px\]{max-width:460px}.max-w-\[480px\]{max-width:480px}.max-w-full{max-width:100%}.max-w-md{max-width:28rem}.max-w-\[390px\]{max-width:390px}.flex-1{flex:1 1 0%}.flex-shrink-0{flex-shrink:0}.flex-grow{flex-grow:1}.-translate-x-1\/2{--tw-translate-x:-50%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-translate-y-1\/2{--tw-translate-y:-50%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-translate-y-\[200\%\]{--tw-translate-y:-200%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform{transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-pointer{cursor:pointer}.resize-none{resize:none}.grid-cols-2{grid-template-columns:repeat(2, minmax(0, 1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.justify-around{justify-content:space-around}.gap-1{gap:0.25rem}.gap-1\.5{gap:0.375rem}.gap-2{gap:0.5rem}.gap-3{gap:0.75rem}.gap-4{gap:1rem}.space-x-2 > :not([hidden]) ~ :not([hidden]){--tw-space-x-reverse:0;margin-right:calc(0.5rem * var(--tw-space-x-reverse));margin-left:calc(0.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-3 > :not([hidden]) ~ :not([hidden]){--tw-space-x-reverse:0;margin-right:calc(0.75rem * var(--tw-space-x-reverse));margin-left:calc(0.75rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-4 > :not([hidden]) ~ :not([hidden]){--tw-space-x-reverse:0;margin-right:calc(1rem * var(--tw-space-x-reverse));margin-left:calc(1rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-1 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0.25rem * var(--tw-space-y-reverse))}.space-y-2 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0.5rem * var(--tw-space-y-reverse))}.space-y-3 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0.75rem * var(--tw-space-y-reverse))}.space-y-4 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}.space-y-6 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.whitespace-pre-wrap{white-space:pre-wrap}.rounded{border-radius:0.25rem}.rounded-2xl{border-radius:1rem}.rounded-3xl{border-radius:1.5rem}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:0.5rem}.rounded-md{border-radius:0.375rem}.rounded-xl{border-radius:0.75rem}.rounded-b-xl{border-bottom-right-radius:0.75rem;border-bottom-left-radius:0.75rem}.border{border-width:1px}.border-0{border-width:0px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-t{border-top-width:1px}.border-dashed{border-style:dashed}.border-none{border-style:none}.border-blue-500{--tw-border-opacity:1;border-color:rgb(59 130 246 / var(--tw-border-opacity, 1))}.border-blue-700\/50{border-color:rgb(29 78 216 / 0.5)}.border-blue-800\/50{border-color:rgb(30 64 175 / 0.5)}.border-gray-300{--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity, 1))}.border-gray-400{--tw-border-opacity:1;border-color:rgb(156 163 175 / var(--tw-border-opacity, 1))}.border-gray-600{--tw-border-opacity:1;border-color:rgb(75 85 99 / var(--tw-border-opacity, 1))}.border-gray-700{--tw-border-opacity:1;border-color:rgb(55 65 81 / var(--tw-border-opacity, 1))}.border-gray-700\/50{border-color:rgb(55 65 81 / 0.5)}.border-transparent{border-color:transparent}.border-white\/80{border-color:rgb(255 255 255 / 0.8)}.border-yellow-200{--tw-border-opacity:1;border-color:rgb(254 240 138 / var(--tw-border-opacity, 1))}.border-pink-400{--tw-border-opacity:1;border-color:rgb(244 114 182 / var(--tw-border-opacity, 1))}.border-pink-400\/30{border-color:rgb(244 114 182 / 0.3)}.border-pink-400\/50{border-color:rgb(244 114 182 / 0.5)}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0 / var(--tw-bg-opacity, 1))}.bg-black\/20{background-color:rgb(0 0 0 / 0.2)}.bg-black\/30{background-color:rgb(0 0 0 / 0.3)}.bg-black\/60{background-color:rgb(0 0 0 / 0.6)}.bg-black\/80{background-color:rgb(0 0 0 / 0.8)}.bg-blue-500{--tw-bg-opacity:1;background-color:rgb(59 130 246 / var(--tw-bg-opacity, 1))}.bg-blue-600{--tw-bg-opacity:1;background-color:rgb(37 99 235 / var(--tw-bg-opacity, 1))}.bg-gray-100{--tw-bg-opacity:1;background-color:rgb(243 244 246 / var(--tw-bg-opacity, 1))}.bg-gray-500{--tw-bg-opacity:1;background-color:rgb(107 114 128 / var(--tw-bg-opacity, 1))}.bg-gray-600{--tw-bg-opacity:1;background-color:rgb(75 85 99 / var(--tw-bg-opacity, 1))}.bg-gray-700{--tw-bg-opacity:1;background-color:rgb(55 65 81 / var(--tw-bg-opacity, 1))}.bg-gray-700\/50{background-color:rgb(55 65 81 / 0.5)}.bg-gray-800{--tw-bg-opacity:1;background-color:rgb(31 41 55 / var(--tw-bg-opacity, 1))}.bg-gray-800\/80{background-color:rgb(31 41 55 / 0.8)}.bg-green-500{--tw-bg-opacity:1;background-color:rgb(34 197 94 / var(--tw-bg-opacity, 1))}.bg-green-600{--tw-bg-opacity:1;background-color:rgb(22 163 74 / var(--tw-bg-opacity, 1))}.bg-orange-600{--tw-bg-opacity:1;background-color:rgb(234 88 12 / var(--tw-bg-opacity, 1))}.bg-red-500{--tw-bg-opacity:1;background-color:rgb(239 68 68 / var(--tw-bg-opacity, 1))}.bg-red-600{--tw-bg-opacity:1;background-color:rgb(220 38 38 / var(--tw-bg-opacity, 1))}.bg-transparent{background-color:transparent}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.bg-yellow-100{--tw-bg-opacity:1;background-color:rgb(254 249 195 / var(--tw-bg-opacity, 1))}.bg-yellow-50{--tw-bg-opacity:1;background-color:rgb(254 252 232 / var(--tw-bg-opacity, 1))}.bg-yellow-600{--tw-bg-opacity:1;background-color:rgb(202 138 4 / var(--tw-bg-opacity, 1))}.bg-zinc-600{--tw-bg-opacity:1;background-color:rgb(82 82 91 / var(--tw-bg-opacity, 1))}.bg-zinc-800{--tw-bg-opacity:1;background-color:rgb(39 39 42 / var(--tw-bg-opacity, 1))}.bg-black\/95{background-color:rgb(0 0 0 / 0.95)}.bg-pink-600{--tw-bg-opacity:1;background-color:rgb(219 39 119 / var(--tw-bg-opacity, 1))}.bg-pink-700{--tw-bg-opacity:1;background-color:rgb(190 24 93 / var(--tw-bg-opacity, 1))}.bg-opacity-30{--tw-bg-opacity:0.3}.bg-gradient-to-t{background-image:linear-gradient(to top, var(--tw-gradient-stops))}.from-black\/50{--tw-gradient-from:rgb(0 0 0 / 0.5) var(--tw-gradient-from-position);--tw-gradient-to:rgb(0 0 0 / 0) var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to)}.to-transparent{--tw-gradient-to:transparent var(--tw-gradient-to-position)}.bg-cover{background-size:cover}.bg-center{background-position:center}.object-cover{object-fit:cover}.p-0{padding:0px}.p-1{padding:0.25rem}.p-2{padding:0.5rem}.p-3{padding:0.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.px-2{padding-left:0.5rem;padding-right:0.5rem}.px-3{padding-left:0.75rem;padding-right:0.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-5{padding-left:1.25rem;padding-right:1.25rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.py-1{padding-top:0.25rem;padding-bottom:0.25rem}.py-1\.5{padding-top:0.375rem;padding-bottom:0.375rem}.py-2{padding-top:0.5rem;padding-bottom:0.5rem}.py-3{padding-top:0.75rem;padding-bottom:0.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.pb-4{padding-bottom:1rem}.pb-6{padding-bottom:1.5rem}.pt-2{padding-top:0.5rem}.pt-4{padding-top:1rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:0.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-semibold{font-weight:600}.leading-relaxed{line-height:1.625}.tracking-widest{letter-spacing:0.1em}.text-blue-300{--tw-text-opacity:1;color:rgb(147 197 253 / var(--tw-text-opacity, 1))}.text-blue-400{--tw-text-opacity:1;color:rgb(96 165 250 / var(--tw-text-opacity, 1))}.text-blue-500{--tw-text-opacity:1;color:rgb(59 130 246 / var(--tw-text-opacity, 1))}.text-gray-200{--tw-text-opacity:1;color:rgb(229 231 235 / var(--tw-text-opacity, 1))}.text-gray-300{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity, 1))}.text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175 / var(--tw-text-opacity, 1))}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128 / var(--tw-text-opacity, 1))}.text-gray-600{--tw-text-opacity:1;color:rgb(75 85 99 / var(--tw-text-opacity, 1))}.text-gray-700{--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity, 1))}.text-gray-800{--tw-text-opacity:1;color:rgb(31 41 55 / var(--tw-text-opacity, 1))}.text-green-400{--tw-text-opacity:1;color:rgb(74 222 128 / var(--tw-text-opacity, 1))}.text-red-500{--tw-text-opacity:1;color:rgb(239 68 68 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.text-white\/80{color:rgb(255 255 255 / 0.8)}.text-yellow-700{--tw-text-opacity:1;color:rgb(161 98 7 / var(--tw-text-opacity, 1))}.text-yellow-800{--tw-text-opacity:1;color:rgb(133 77 14 / var(--tw-text-opacity, 1))}.text-black{--tw-text-opacity:1;color:rgb(0 0 0 / var(--tw-text-opacity, 1))}.text-pink-100{--tw-text-opacity:1;color:rgb(252 231 243 / var(--tw-text-opacity, 1))}.text-pink-300{--tw-text-opacity:1;color:rgb(249 168 212 / var(--tw-text-opacity, 1))}.text-pink-400\/80{color:rgb(244 114 182 / 0.8)}.placeholder-gray-300::placeholder{--tw-placeholder-opacity:1;color:rgb(209 213 219 / var(--tw-placeholder-opacity, 1))}.opacity-80{opacity:0.8}.shadow-lg{--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-xl{--tw-shadow:0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-pink-500\/20{--tw-shadow-color:rgb(236 72 153 / 0.2);--tw-shadow:var(--tw-shadow-colored)}.shadow-pink-500\/30{--tw-shadow-color:rgb(236 72 153 / 0.3);--tw-shadow:var(--tw-shadow-colored)}.outline-none{outline:2px solid transparent;outline-offset:2px}.drop-shadow-lg{--tw-drop-shadow:drop-shadow(0 10px 8px rgb(0 0 0 / 0.04)) drop-shadow(0 4px 3px rgb(0 0 0 / 0.1));filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop-blur-lg{--tw-backdrop-blur:blur(16px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-blur-md{--tw-backdrop-blur:blur(12px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-blur-sm{--tw-backdrop-blur:blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-blur-xl{--tw-backdrop-blur:blur(24px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.transition-colors{transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.duration-200{transition-duration:200ms}.duration-300{transition-duration:300ms}.after\:absolute::after{content:var(--tw-content);position:absolute}.after\:left-\[2px\]::after{content:var(--tw-content);left:2px}.after\:top-0\.5::after{content:var(--tw-content);top:0.125rem}.after\:top-\[2px\]::after{content:var(--tw-content);top:2px}.after\:h-4::after{content:var(--tw-content);height:1rem}.after\:h-5::after{content:var(--tw-content);height:1.25rem}.after\:w-4::after{content:var(--tw-content);width:1rem}.after\:w-5::after{content:var(--tw-content);width:1.25rem}.after\:rounded-full::after{content:var(--tw-content);border-radius:9999px}.after\:border::after{content:var(--tw-content);border-width:1px}.after\:border-gray-300::after{content:var(--tw-content);--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity, 1))}.after\:bg-white::after{content:var(--tw-content);--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.after\:transition-all::after{content:var(--tw-content);transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.after\:content-\[\'\'\]::after{--tw-content:'';content:var(--tw-content)}.hover\:scale-105:hover{--tw-scale-x:1.05;--tw-scale-y:1.05;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.hover\:border-gray-300:hover{--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity, 1))}.hover\:bg-blue-500:hover{--tw-bg-opacity:1;background-color:rgb(59 130 246 / var(--tw-bg-opacity, 1))}.hover\:bg-blue-600:hover{--tw-bg-opacity:1;background-color:rgb(37 99 235 / var(--tw-bg-opacity, 1))}.hover\:bg-blue-700:hover{--tw-bg-opacity:1;background-color:rgb(29 78 216 / var(--tw-bg-opacity, 1))}.hover\:bg-gray-100:hover{--tw-bg-opacity:1;background-color:rgb(243 244 246 / var(--tw-bg-opacity, 1))}.hover\:bg-gray-200:hover{--tw-bg-opacity:1;background-color:rgb(229 231 235 / var(--tw-bg-opacity, 1))}.hover\:bg-gray-50:hover{--tw-bg-opacity:1;background-color:rgb(249 250 251 / var(--tw-bg-opacity, 1))}.hover\:bg-gray-600:hover{--tw-bg-opacity:1;background-color:rgb(75 85 99 / var(--tw-bg-opacity, 1))}.hover\:bg-gray-700:hover{--tw-bg-opacity:1;background-color:rgb(55 65 81 / var(--tw-bg-opacity, 1))}.hover\:bg-green-600:hover{--tw-bg-opacity:1;background-color:rgb(22 163 74 / var(--tw-bg-opacity, 1))}.hover\:bg-green-700:hover{--tw-bg-opacity:1;background-color:rgb(21 128 61 / var(--tw-bg-opacity, 1))}.hover\:bg-orange-700:hover{--tw-bg-opacity:1;background-color:rgb(194 65 12 / var(--tw-bg-opacity, 1))}.hover\:bg-red-600:hover{--tw-bg-opacity:1;background-color:rgb(220 38 38 / var(--tw-bg-opacity, 1))}.hover\:bg-red-700:hover{--tw-bg-opacity:1;background-color:rgb(185 28 28 / var(--tw-bg-opacity, 1))}.hover\:bg-white\/20:hover{background-color:rgb(255 255 255 / 0.2)}.hover\:bg-white\/30:hover{background-color:rgb(255 255 255 / 0.3)}.hover\:bg-yellow-700:hover{--tw-bg-opacity:1;background-color:rgb(161 98 7 / var(--tw-bg-opacity, 1))}.hover\:bg-pink-500:hover{--tw-bg-opacity:1;background-color:rgb(236 72 153 / var(--tw-bg-opacity, 1))}.hover\:bg-pink-600:hover{--tw-bg-opacity:1;background-color:rgb(219 39 119 / var(--tw-bg-opacity, 1))}.hover\:text-blue-300:hover{--tw-text-opacity:1;color:rgb(147 197 253 / var(--tw-text-opacity, 1))}.hover\:text-gray-700:hover{--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity, 1))}.hover\:text-white:hover{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.hover\:text-pink-300:hover{--tw-text-opacity:1;color:rgb(249 168 212 / var(--tw-text-opacity, 1))}.hover\:shadow-md:hover{--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.focus\:bg-white\/10:focus{background-color:rgb(255 255 255 / 0.1)}.focus\:ring-2:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.focus\:ring-gray-500:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(107 114 128 / var(--tw-ring-opacity, 1))}.focus\:ring-white\/50:focus{--tw-ring-color:rgb(255 255 255 / 0.5)}.peer:checked ~ .peer-checked\:bg-blue-600{--tw-bg-opacity:1;background-color:rgb(37 99 235 / var(--tw-bg-opacity, 1))}.peer:checked ~ .peer-checked\:after\:translate-x-full::after{content:var(--tw-content);--tw-translate-x:100%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.peer:checked ~ .peer-checked\:after\:border-white::after{content:var(--tw-content);--tw-border-opacity:1;border-color:rgb(255 255 255 / var(--tw-border-opacity, 1))}.peer:focus ~ .peer-focus\:ring-4{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.peer:focus ~ .peer-focus\:ring-blue-800{--tw-ring-opacity:1;--tw-ring-color:rgb(30 64 175 / var(--tw-ring-opacity, 1))}@media (prefers-color-scheme: dark){.dark\:border-yellow-800{--tw-border-opacity:1;border-color:rgb(133 77 14 / var(--tw-border-opacity, 1))}.dark\:bg-gray-700{--tw-bg-opacity:1;background-color:rgb(55 65 81 / var(--tw-bg-opacity, 1))}.dark\:bg-gray-800{--tw-bg-opacity:1;background-color:rgb(31 41 55 / var(--tw-bg-opacity, 1))}.dark\:bg-yellow-900\/20{background-color:rgb(113 63 18 / 0.2)}.dark\:text-gray-200{--tw-text-opacity:1;color:rgb(229 231 235 / var(--tw-text-opacity, 1))}.dark\:text-gray-300{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity, 1))}.dark\:text-yellow-200{--tw-text-opacity:1;color:rgb(254 240 138 / var(--tw-text-opacity, 1))}.dark\:text-yellow-300{--tw-text-opacity:1;color:rgb(253 224 71 / var(--tw-text-opacity, 1))}.dark\:hover\:bg-gray-600:hover{--tw-bg-opacity:1;background-color:rgb(75 85 99 / var(--tw-bg-opacity, 1))}}</style><script id="cyxy-subtitles-inject" src="chrome-extension://abbgboelhkajgikdbjclaecchkneaoma/dist/video-subtitle.js"></script></head>
<body class="flex items-center justify-center min-h-screen dark-mode dark">
    

    <!-- SVG濾鏡，用於創建紙張毛邊效果 -->
    <svg style="position:absolute; width:0; height:0; overflow:hidden;">
      <filter id="paper-edge-filter">
        <feturbulence type="fractalNoise" baseFrequency="0.04" numOctaves="5" result="noise"></feturbulence>
        <fedisplacementmap in="SourceGraphic" in2="noise" scale="8" xChannelSelector="R" yChannelSelector="G"></fedisplacementmap>
      </filter>
      <filter id="leather-texture-filter">
        <feturbulence type="fractalNoise" baseFrequency="0.2" numOctaves="5" result="noise"></feturbulence>
        <fediffuselighting in="noise" lighting-color="#A47454" surfaceScale="3" result="light">
          <fedistantlight azimuth="235" elevation="60"></fedistantlight>
        </fediffuselighting>
        <fecomposite in="SourceGraphic" in2="light" operator="arithmetic" k1="1.5" k2="0" k3="0" k4="0"></fecomposite>
      </filter>
    </svg>
    
    <input type="file" id="user-avatar-input" class="hidden" accept="image/*">
    <input type="file" id="chat-bg-input" class="hidden" accept="image/*">
    <input type="file" id="import-data-input" class="hidden" accept=".json">
    <input type="file" id="image-upload-input" class="hidden" accept="image/*">
    <input type="file" id="sticker-upload-input" class="hidden" accept="image/*">
    <input type="file" id="user-video-image-input" class="hidden" accept="image/*">
    <input type="file" id="my-video-image-input" class="hidden" accept="image/*">
                    <div class="phone-frame">
        
        <div id="phone-screen" class="phone-screen flex-1 overflow-hidden relative animate-fade-in">
            
            <div id="home-wallpaper" class="absolute inset-0 w-full h-full z-0"></div>

            <div id="status-bar" class="status-bar absolute top-0 left-0 right-0 z-50 px-5 py-3 text-sm font-semibold flex justify-between items-center transition-colors on-home">
                <div class="flex items-center space-x-2">
                    <span id="currentTime">22:58</span>
                </div>
                <div class="flex items-center space-x-4">
                    <span id="api-status-text" class="text-red-500">API OFF</span>
                                <button id="theme-toggle" class="p-1 rounded-full hover:bg-white/20 transition-colors">
                <i id="theme-icon" class="fas fa-moon text-lg"></i>
            </button>
                </div>
            </div>

            <div id="messageBox" class="message-box"></div>
            
            <div id="incoming-call-alert">
                <img id="incoming-call-avatar" src="./RavenPhone【0916自存】_files/FFF" alt="avatar">
                <div id="incoming-call-info">
                    <p id="incoming-call-name" class="font-bold">Character Name</p>
                    <p id="incoming-call-type" class="text-sm text-gray-300">正在呼叫...</p>
                </div>
                <button id="answer-call-btn" class="call-btn"><i class="ri-phone-fill"></i></button>
                <button id="decline-call-btn" class="call-btn"><i class="fas fa-phone-slash"></i></button>
            </div>
            

            
            <div id="song-list-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="text-xl font-bold">播放列表</h3>
                <button id="close-playlist-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <ul id="song-list-container" class="space-y-2 max-h-60 overflow-y-auto"><li class="p-3 text-center text-gray-400">请点击右下角音乐图标上传歌曲</li></ul>
                </div>
            </div>
            <div id="new-chat-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="text-xl font-bold">发起新聊天</h3>
                <button id="close-new-chat-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <ul id="new-chat-character-list" class="space-y-2 max-h-60 overflow-y-auto">
                        </ul>
                </div>
            </div>
             <div id="confirm-delete-modal" class="modal-overlay">
                <div class="modal-content text-center">
                    <h3 id="delete-modal-title" class="text-lg font-bold mb-4">确认删除吗？</h3>
                    <p id="delete-modal-text" class="text-sm mb-6">此操作无法撤销。</p>
                    <div class="flex justify-around">
                        <button id="cancel-delete-btn" class="px-6 py-2 rounded-lg">取消</button>
                        <button id="confirm-delete-btn" class="px-6 py-2 bg-red-600 text-white rounded-lg">删除</button>
                    </div>
                </div>
            </div>

            <!-- 剧场主题设置对话框 -->
            <div id="scenario-theme-modal" class="modal-overlay">
                <div class="modal-content max-w-md">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-bold">剧场主题美化</h3>
                        <button id="close-theme-modal" class="text-gray-500 hover:text-gray-700 text-xl font-bold">×</button>
                    </div>
                    
                    <div class="space-y-4">
                        <!-- 背景颜色设置 -->
                        <div>
                            <label class="block text-sm font-medium mb-2">背景颜色</label>
                            <div class="flex items-center gap-2">
                                <input type="color" id="bg-color-picker" class="color-picker-input" value="#4d3a2a">
                                <span class="text-sm text-gray-600">主背景色</span>
                            </div>
                        </div>

                        <!-- 标题栏颜色设置 -->
                        <div>
                            <label class="block text-sm font-medium mb-2">标题栏颜色</label>
                            <div class="flex items-center gap-2">
                                <input type="color" id="header-color-picker" class="color-picker-input" value="#4d3a2a">
                                <span class="text-sm text-gray-600">标题栏背景色</span>
                            </div>
                        </div>

                        <!-- 标题文字颜色设置 -->
                        <div>
                            <label class="block text-sm font-medium mb-2">标题文字颜色</label>
                            <div class="flex items-center gap-2">
                                <input type="color" id="title-text-color-picker" class="color-picker-input" value="#f5f2ed">
                                <span class="text-sm text-gray-600">标题文字色</span>
                            </div>
                        </div>

                        <!-- 文本内容颜色设置 -->
                        <div>
                            <label class="block text-sm font-medium mb-2">文本内容颜色</label>
                            <div class="flex items-center gap-2">
                                <input type="color" id="content-text-color-picker" class="color-picker-input" value="#3e2723">
                                <span class="text-sm text-gray-600">正文文字色</span>
                            </div>
                        </div>

                        <!-- 文本背景颜色设置 -->
                        <div>
                            <label class="block text-sm font-medium mb-2">文本背景颜色</label>
                            <div class="flex items-center gap-2">
                                <input type="color" id="content-bg-color-picker" class="color-picker-input" value="#f5f2ed">
                                <span class="text-sm text-gray-600">正文背景色</span>
                            </div>
                        </div>

                        <!-- 输入框边框颜色设置 -->
                        <div>
                            <label class="block text-sm font-medium mb-2">输入框边框颜色</label>
                            <div class="flex items-center gap-2">
                                <input type="color" id="input-border-color-picker" class="color-picker-input" value="#8b6559">
                                <span class="text-sm text-gray-600">输入框边框色</span>
                            </div>
                        </div>

                        <!-- 按钮颜色设置 -->
                        <div>
                            <label class="block text-sm font-medium mb-2">按钮颜色</label>
                            <div class="space-y-2">
                                <div class="flex items-center gap-2">
                                    <input type="color" id="refresh-btn-color-picker" class="color-picker-input" value="#8b6559">
                                    <span class="text-sm text-gray-600">刷新按钮色</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="color" id="send-btn-color-picker" class="color-picker-input" value="#6d4c41">
                                    <span class="text-sm text-gray-600">发送按钮背景色</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="color" id="send-btn-border-color-picker" class="color-picker-input" value="#5d4037">
                                    <span class="text-sm text-gray-600">发送按钮边框色</span>
                                </div>
                            </div>
                        </div>

                        <!-- 背景图片设置 -->
                        <div>
                            <label class="block text-sm font-medium mb-2">背景图片</label>
                            <div class="space-y-3">
                                <div class="flex items-center gap-2">
                                    <input type="file" id="bg-image-input" accept="image/*" class="hidden">
                                    <button id="bg-image-btn" class="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm">
                                        <i class="fas fa-upload mr-1"></i>选择图片
                                    </button>
                                    <span id="bg-image-name" class="text-sm text-gray-600">未选择图片</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <label class="text-sm text-gray-600">透明度:</label>
                                    <input type="range" id="bg-opacity-slider" min="0" max="100" value="70" class="flex-1">
                                    <span id="bg-opacity-value" class="text-sm text-gray-600 w-8">70%</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <label class="text-sm text-gray-600">模糊程度:</label>
                                    <input type="range" id="bg-blur-slider" min="0" max="20" value="2" class="flex-1">
                                    <span id="bg-blur-value" class="text-sm text-gray-600 w-12">2px</span>
                                </div>
                                <div class="flex gap-2">
                                    <button id="remove-bg-btn" class="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm">
                                        <i class="fas fa-trash mr-1"></i>移除背景
                                    </button>
                                    <button id="preview-bg-btn" class="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 text-sm">
                                        <i class="fas fa-eye mr-1"></i>预览效果
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-between mt-6">
                        <button id="reset-theme-btn" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">重置默认</button>
                        <button id="apply-theme-btn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">应用设置</button>
                    </div>
                </div>
            </div>
            <div id="voice-input-modal" class="modal-overlay">
                <div class="modal-content">
                    <h3 class="text-lg font-bold mb-4 text-center">发送语音消息</h3>
                    <textarea id="voice-text-input" class="form-textarea w-full h-24 resize-none" placeholder="在此输入文字..."></textarea>
                    <div class="flex justify-end mt-4 gap-2">
                        <button id="cancel-voice-btn" class="px-4 py-2 rounded-lg">取消</button>
                        <button id="send-voice-btn" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">发送</button>
                    </div>
                </div>
            </div>

            <div id="new-notebook-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold">创建新笔记本</h3>
                        <button id="close-new-notebook-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">笔记本名称</label>
                            <input type="text" id="new-notebook-name" class="form-input w-full" placeholder="请输入笔记本名称..." maxlength="20">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">笔记本类型</label>
                            <select id="new-notebook-type" class="form-select w-full">
                                <option value="diary">日记本</option>
                                <option value="notes">笔记本</option>
                                <option value="ideas">想法本</option>
                                <option value="goals">目标本</option>
                                <option value="custom">自定义</option>
                            </select>
                        </div>
                        <div id="custom-type-container" class="hidden">
                            <label class="block text-sm font-medium mb-2">自定义类型名称</label>
                            <input type="text" id="custom-notebook-type" class="form-input w-full" placeholder="请输入自定义类型名称..." maxlength="15">
                        </div>
                        <div class="flex justify-end space-x-3 pt-4">
                            <button id="cancel-new-notebook-btn" class="px-4 py-2 text-gray-300 hover:text-white transition-colors">取消</button>
                            <button id="confirm-new-notebook-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">创建</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 刪除表情包確認彈窗 -->
            <div id="delete-sticker-modal" class="delete-confirm-modal">
                <h3>刪除表情包</h3>
                <p id="delete-sticker-text">確定要刪除選中的表情包嗎？此操作無法撤銷。</p>
                <div class="delete-confirm-buttons">
                    <button id="cancel-delete-sticker-btn" class="delete-confirm-btn cancel">取消</button>
                    <button id="confirm-delete-sticker-btn" class="delete-confirm-btn confirm">刪除</button>
                </div>
            </div>
            <!-- 贴图/表情 Modal -->
            <div id="sticker-modal" class="modal-overlay">
                <div class="modal-content sticker-modal-content">
                    <!-- 标题栏 -->
                    <div class="sticker-modal-header">
                        <h3 class="sticker-modal-title">添加表情</h3>
                        <button id="close-sticker-modal" class="sticker-modal-close" title="关闭">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>

                    <div class="sticker-modal-body">
                        <div class="sticker-input-group">
                            <label class="sticker-label">表情关键词</label>
                            <input type="text" id="sticker-keywords-input" class="sticker-input" placeholder="开心,猫,可爱">
                        </div>

                        <button id="upload-sticker-local-btn" class="sticker-upload-btn">
                            <i class="ri-upload-cloud-2-line mr-2"></i>本地上传
                        </button>

                        <div class="sticker-input-group">
                            <label class="sticker-label">或粘贴图片链接</label>
                            <div class="sticker-url-group">
                                <input type="text" id="sticker-url-input" class="sticker-input" placeholder="https://...">
                                <button id="send-sticker-url-btn" class="sticker-add-btn">添加</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


            <div id="home-screen" class="app-screen-view relative">
                <div id="music-block-container" class="p-2 mt-2">
                    <div id="music-block" class="music-block relative w-full p-3 rounded-2xl flex items-center justify-between shadow-xl music-block-background">
                        <div class="relative w-1/2 flex-shrink-0 flex items-center justify-center">
                            <div id="vinyl-container" class="vinyl-container">
                                <div id="vinyl-record" class="vinyl-image-container">
                                    <div id="vinyl-center" class="vinyl-center"></div>
                                </div>
                            </div>
                            <input type="file" id="background-input" accept="image/*">
                            <input type="file" id="vinyl-input" accept="image/*">
                            <input type="file" id="music-upload-input" accept="audio/*,.mp3,.m4a,.wav,.ogg,.flac" multiple="">
                        </div>
                        <div class="flex-grow flex flex-col justify-center h-24 ml-4">
                            <textarea id="mood-text" class="w-full bg-transparent placeholder-gray-300 text-sm p-1 rounded-md resize-none border-none outline-none focus:ring-2 focus:ring-white/50 focus:bg-white/10 transition-all text-center" placeholder="点击填写心情..."></textarea>
                            <div class="flex items-center justify-center space-x-3 mt-2">
                                <button id="loop-button" class="player-button"><i class="fas fa-rotate-right text-base"></i></button>
                                <button id="prev-button" class="player-button"><i class="fas fa-step-backward text-base"></i></button>
                                <button id="play-pause-button" class="player-button"><i class="fas fa-play text-xl"></i></button>
                                <button id="next-button" class="player-button"><i class="fas fa-step-forward text-base"></i></button>
                                <button id="single-loop-button" class="player-button"><i class="fas fa-repeat text-base"></i></button>
                            </div>
                        </div>
                        <div class="absolute bottom-2 right-2 flex space-x-2">
                            <div id="playlist-button" class="p-1 rounded-full cursor-pointer hover:bg-white/30 transition-colors"><i class="fas fa-list text-sm"></i></div>
                            <div id="music-upload-button" class="p-1 rounded-full cursor-pointer hover:bg-white/30 transition-colors"><i class="fas fa-music text-sm"></i></div>
                        </div>
                    </div>
                </div>
                <div class="px-4 grid grid-cols-2 gap-4 mt-2">

                    <div class="flex flex-col gap-3">
                        <div id="photo-widget" class="w-full aspect-square rounded-2xl shadow-xl flex items-center justify-center transition-colors duration-300 cursor-pointer bg-cover bg-center" style="background-image: url(&#39;http://googleusercontent.com/file_content/3&#39;);">
                            <span id="photo-widget-text" class="text-2xl font-bold text-white/80">照片墙</span>
                        </div>
                        <input type="file" id="photo-widget-input" accept="image/*">
                        <div id="time-capsule-widget" class="time-capsule-widget">
                            <div class="capsule-text-container">
                                <span class="capsule-text">Memory</span>
                                <span class="capsule-subtitle">With you</span>
                            </div>
                            <div class="capsule-image-container">
                                <img id="capsule-image" src="data:image/svg+xml,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; viewBox=&#39;0 0 100 100&#39;%3E%3Ccircle cx=&#39;50&#39; cy=&#39;50&#39; r=&#39;40&#39; fill=&#39;none&#39; stroke=&#39;rgba(255,255,255,0.4)&#39; stroke-width=&#39;2&#39;/%3E%3Cpath d=&#39;M35 50 L50 35 L65 50 M50 35 L50 65&#39; stroke=&#39;rgba(255,255,255,0.7)&#39; stroke-width=&#39;3&#39; fill=&#39;none&#39;/%3E%3C/svg%3E" alt="Upload Image" class="capsule-icon">

                            </div>
                        </div>
                    </div>

                    <div class="flex flex-col gap-3">
                        <div id="text-input-widget" class="w-full aspect-square p-4 flex flex-col justify-center transition-colors duration-300">
                            <div class="flex items-center mb-3">
                                <div id="widget-image-placeholder" class="w-10 h-10 rounded-full flex-shrink-0 mr-3 image-placeholder">
                                    <i class="fas fa-camera"></i>
                                </div>
                                <input type="text" id="widget-name-input" placeholder="Name" class="text-widget-input text-base border-0 focus:ring-2 focus:ring-white/50">
                                <input type="file" id="widget-image-input" accept="image/*">
                            </div>
                            <input type="text" id="widget-thinking-input" placeholder="Thinking..." class="text-widget-input text-xs mb-3 border-0 focus:ring-2 focus:ring-white/50">
                            <div class="flex items-center">
                                <i class="fas fa-map-marker-alt text-xs mr-2 opacity-80"></i>
                                <input type="text" id="widget-location-input" placeholder="Where r u" class="text-widget-input text-xs border-0 focus:ring-2 focus:ring-white/50">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div class="rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="动态监控"><i class="ri-eye-line text-white text-2xl"></i></div>
                            <div class="rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="设置"><i class="fas fa-cog text-white text-2xl"></i></div>
                            <div class="rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass relative" data-app-name="栖木">
                                <i class="ri-chat-quote-line text-white text-2xl"></i>
                                <div id="perch-dock-badge" class="absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full hidden"></div>
                            </div>
                            <div class="rounded-xl flex items-center justify-center shadow-lg app-icon app-icon-glass" data-app-name="剧场"><i class="ri-movie-2-line text-white text-2xl"></i></div>
                        </div>
                    </div>

                </div>
            </div>

            <div id="monitoring-screen" class="app-screen-view flex-col hidden font-mono">
                <!-- <div class="bg-gradient-to-b from-gray-900 to-blue-900 absolute inset-0 z-0"></div> -->
                <div class="absolute top-0 left-0 w-full h-full bg-black/30 backdrop-blur-sm z-10"></div>
                
                <!-- 浮动光晕装饰元素 -->
                <div class="bg-glow-1"></div>
                <div class="bg-glow-2"></div>

                <!-- 新增：科技感装饰元素 -->
                <div class="cyber-grid"></div>
                <div class="data-flow-container">
                    <div class="data-stream"></div>
                    <div class="data-stream"></div>
                    <div class="data-stream"></div>
                    <div class="data-stream"></div>
                </div>
                <div class="energy-ripple"></div>
                <div class="energy-ripple"></div>
                <div class="energy-ripple"></div>
                <div class="xray-scan-line"></div>
                <div class="electronic-particles">
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                </div>

                <div class="app-header bg-transparent z-20 border-b border-blue-800/50">
                    <button id="monitoring-back-button" class="app-header-btn text-blue-400 hover:text-white"><i class="fas fa-chevron-left"></i></button>
                    <div class="text-center">
                        <h3 class="app-header-title text-blue-300">动态监控</h3>
                        <p class="text-xs text-blue-500 tracking-widest mt-1">REAL-TIME SURVEILLANCE</p>
                    </div>
                    <div class="w-8"></div>
                </div>

                <div class="flex-1 flex flex-col px-2 py-4 space-y-4 z-20 overflow-y-auto">
                                    <div id="monitoring-identity-block" class="monitoring-card bg-black/60 border border-blue-700/50 backdrop-blur-md rounded-lg p-4 cursor-pointer relative">
                    <!-- 新增静态光效装饰 -->
                    <div class="static-glow"></div>
                    <div class="scan-lines"></div>
                    <div class="tech-light-dots"></div>
                    
                    <!-- 角落光效装饰 -->
                    <div class="corner-glow top-left"></div>
                    <div class="corner-glow top-right"></div>
                    <div class="corner-glow bottom-left"></div>
                    <div class="corner-glow bottom-right"></div>

                    <!-- 新增：科技感角落装饰 -->
                    <div class="tech-corner top-left"></div>
                    <div class="tech-corner top-right"></div>
                    <div class="tech-corner bottom-left"></div>
                    <div class="tech-corner bottom-right"></div>
                    
                    <!-- 新增：状态指示器 -->
                    <div class="status-indicator"></div>
                    
                    <div class="flex items-center">
                        <div id="monitoring-avatar" class="w-12 h-12 rounded-full mr-3 bg-cover bg-center border border-blue-500 flex-shrink-0"></div>
                        <div class="flex-1 overflow-hidden">
                            <p id="monitoring-name" class="text-lg font-semibold text-white truncate">角色名</p>
                            <div id="monitoring-mood" class="text-xs mt-1 flex items-center text-blue-300">
                                <span id="monitoring-mood-icon" class="mr-1"></span>
                                <span id="monitoring-mood-text" class="font-semibold">未知</span>
                            </div>
                        </div>
                    </div>

                </div>

                    <div class="monitoring-card bg-black/60 border border-blue-700/50 backdrop-blur-md rounded-lg p-4 flex-1 relative">
                        <!-- 新增静态光效装饰 -->
                        <div class="static-glow"></div>
                        <div class="scan-lines"></div>
                        <div class="tech-light-dots"></div>
                        
                        <!-- 角落光效装饰 -->
                        <div class="corner-glow top-left"></div>
                        <div class="corner-glow top-right"></div>
                        <div class="corner-glow bottom-left"></div>
                        <div class="corner-glow bottom-right"></div>

                        <!-- 新增：科技感角落装饰 -->
                        <div class="tech-corner top-left"></div>
                        <div class="tech-corner top-right"></div>
                        <div class="tech-corner bottom-left"></div>
                        <div class="tech-corner bottom-right"></div>
                        
                        <!-- 新增：状态指示器 -->
                        <div class="status-indicator"></div>
                        
                        <!-- 米白色-粉色渐变透明背景 -->
                        <div class="cream-pink-bg"></div>
                        
                        <div id="monitoring-text-container" class="overflow-y-auto" style="height: 400px; min-height: 400px; overflow-y: auto;">
                            <p id="monitoring-status-text" class="text-sm text-gray-300 whitespace-pre-wrap leading-relaxed">正在连接信号...</p>
                        </div>
                        <p id="monitoring-timestamp" class="text-xs text-gray-700 text-right mt-2 absolute bottom-2 right-3"></p>

                    </div>
                    
                    <!-- 文本框下方的科技感线性装饰 -->
                    <div class="tech-lines-container mt-3 relative">
                        <!-- 主线条 -->
                        <div class="tech-line-main"></div>
                        <!-- 左侧装饰线 -->
                        <div class="tech-line-left"></div>
                        <div class="tech-line-left-2"></div>
                        <!-- 右侧装饰线 -->
                        <div class="tech-line-right"></div>
                        <div class="tech-line-right-2"></div>
                        <!-- 中心装饰点 -->
                        <div class="tech-center-dot"></div>
                        <div class="tech-center-dot-2"></div>
                    </div>

                    <div class="flex justify-center items-center space-x-3 py-2 relative">
                        <!-- 新增：按钮区域科技感装饰 -->
                        <div class="button-tech-lines">
                            <div class="button-line-left"></div>
                            <div class="button-line-right"></div>
                            <div class="button-center-dot"></div>
                        </div>
                        
                        <button id="monitoring-refresh-button" class="monitoring-capsule-btn" title="刷新当前状态">
                            <i class="ri-refresh-line"></i>
                            <span>刷新</span>
                        </button>
                        <button id="monitoring-next-step-button" class="monitoring-capsule-btn" title="持续监控">
                            <i class="ri-skip-forward-line"></i>
                            <span>持续监控</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- 记忆胶囊App (时光回廊界面) -->
            <div id="memory-capsule-screen" class="app-screen-view flex-col hidden">
                <!-- 头部 -->
                <div class="app-header">
                    <button id="memory-capsule-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">记忆胶囊</h3>
                    <div class="flex items-center">
                        <button id="memory-capsule-add-button" class="app-header-btn" title="添加新记忆"><i class="fas fa-plus"></i></button>
                    </div>
                </div>

                <!-- 角色选择容器 -->
                <div id="character-select-container" class="flex-1 overflow-y-auto px-4 pt-2">
                    <div id="character-select-list" class="space-y-3 px-4">
                        <!-- 角色列表将由JS动态生成 -->
                    </div>
                </div>

                <!-- 全新的时间线容器 -->
                <div id="timeline-container" class="flex-1 overflow-y-auto px-4 pt-2 pb-6 hidden">
                    <div class="flex items-center justify-between mb-4">
                        <button id="back-to-character-select" class="bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg flex items-center space-x-2 transition-all duration-200 shadow-sm hover:shadow-md">
                            <i class="fas fa-chevron-left text-sm"></i>
                            <span class="text-sm font-medium">返回</span>
                        </button>
                        <h4 id="current-character-name" class="text-lg font-semibold"></h4>
                    </div>
                    <div id="timeline-core" class="relative">
                        <!-- 记忆卡片将由JS动态生成到这里 -->
                    </div>
                </div>
            </div>

            <!-- 新增：为JS准备的记忆卡片模板 -->
            <template id="memory-card-template"></template>

            <div id="memory-card-modal" class="modal-overlay">
                <div id="memory-card-content" class="modal-content relative p-0 max-w-[400px] w-[95%]">
                    <!-- 记忆卡片内容将由JS动态生成 -->
                </div>
            </div>

            <!-- 添加记忆的模态框 -->
            <div id="add-memory-modal" class="modal-overlay">
                <div class="modal-content max-w-[400px] w-[95%]">
                    <h3 class="text-xl font-bold mb-4">添加新记忆</h3>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">记忆标题 <span class="text-red-500">*</span></label>
                        <input type="text" id="new-memory-title" class="form-input w-full" placeholder="给这段记忆起个标题..." maxlength="50">
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">记忆内容</label>
                        <textarea id="new-memory-content" class="form-textarea w-full h-24 resize-none" placeholder="写下你想记住的美好时刻..."></textarea>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">我的感触</label>
                        <textarea id="new-memory-feeling" class="form-textarea w-full h-20 resize-none" placeholder="分享你对这段记忆的感受和思考..."></textarea>
                        <p class="text-xs text-gray-500 mt-1">你可以分享自己的感受，角色也会根据这段记忆自动生成感触</p>
                    </div>
                    
                    <div class="flex justify-end space-x-2">
                        <button id="cancel-add-memory-btn" class="px-4 py-2 rounded-lg border border-gray-300 hover:bg-gray-50">取消</button>
                        <button id="save-memory-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg">保存</button>
                    </div>
                </div>
            </div>

            <div id="character-select-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="character-select-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <div class="w-8"></div>
                </div>
                <div id="character-select-list-container" class="flex-1 overflow-y-auto p-2 space-y-2">
                    </div>
            </div>

            <div id="wechat-list-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wechat-list-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 id="wechat-list-title" class="app-header-title">WeChat</h3>
                    <div class="flex items-center">
                        <button id="wechat-new-chat-button" class="app-header-btn"><i class="fas fa-plus"></i></button>
                        <button id="wechat-new-moment-button" class="app-header-btn ml-2 hidden"><i class="fas fa-plus"></i></button>
                        <button id="wechat-new-plan-button" class="app-header-btn ml-2 hidden"><i class="fas fa-plus"></i></button>
                    </div>
                </div>
                <div id="wechat-content-container" class="flex-1 overflow-y-auto">
                    <div id="wechat-list-container"></div>
                    <!-- V7.1: 全新动态 (Moments) 容器 -->
                    <div id="wechat-moments-container" class="wechat-content-view hidden">
                        <!-- 所有内容一起滚动的容器 -->
                        <div class="h-full overflow-y-auto">
                            <!-- 背景图片和用户名片区域 -->
                            <div class="relative">
                                <div id="moments-header" class="relative h-48 rounded-b-xl overflow-hidden shadow-lg">
                                    <div id="moments-cover" class="absolute inset-0 cursor-pointer" title="点击更换背景" onclick="changeMomentsCover()" style="z-index: 25; position: relative; background-image: url(&quot;https://placehold.co/375x192/333/fff?text=Cover&quot;); background-size: cover; background-position: center center; background-repeat: no-repeat;">
                                        <!-- 提示文字，只在没有背景图片时显示 -->
                                        <div id="moments-cover-hint" class="absolute inset-0 flex items-center justify-center" style="display: flex;">
                                            <div class="bg-black bg-opacity-30 text-white px-3 py-1 rounded text-sm" style="margin-top: 60px;">
                                                点击更换背景
                                            </div>
                                        </div>

                                    </div>
                                    <div class="absolute inset-0 bg-gradient-to-t from-black/50 to-transparent" style="z-index: 20; pointer-events: none;"></div>
                                    
                                    <!-- 头像和用户名信息，放在背景图片上方，居中靠下 -->
                                    <div id="moments-user-info" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex flex-col items-center" style="z-index: 30;">
                                        <div id="moments-user-avatar" class="w-20 h-20 rounded-full border-2 border-white/80 shadow-lg cursor-pointer mb-2" title="点击更换头像" onclick="changeMomentsAvatar()" style="background-image: url(&quot;https://placehold.co/128x128/777/FFF?text=Me&quot;); background-size: cover; background-position: center center; background-repeat: no-repeat;"></div>
                                        <span id="moments-user-name" class="font-bold text-white text-lg drop-shadow-lg cursor-pointer" title="点击编辑名字" onclick="editMomentsName()">My Name</span>
                                    </div>
                                </div>
                            </div>

                            <!-- 背景和动态内容之间的间距 -->
                            <div class="h-4"></div>
                            
                            <!-- 角色自动发布动态提示 -->

                            
                            <!-- 动态内容区域 -->
                            <div id="moments-feed" class="px-2 pb-4 space-y-3">
                                <!-- 动态内容将由JS渲染到这里 -->
                            </div>
                            </div>
                        </div>
                    <!-- V7.1: 全新日记 (Diary) 书架容器 -->
                    <div id="wechat-diary-container" class="wechat-content-view hidden p-4">
                        <h3 class="text-xl font-bold mb-4 px-2">日记书架</h3>
                        <div id="diary-bookshelf" class="grid grid-cols-2 gap-4">
                            <!-- 日记本将由JS渲染到这里 -->
                        </div>
                    </div>
                    <div id="wechat-plan-container" class="wechat-content-view hidden">
                        <div id="plan-list-container" class="p-2 space-y-3">
                            <!-- 计划列表将由JS渲染到这里 -->
                        </div>
                    </div>

    <!-- 全新的"创建约定"模态框HTML结构 -->
    <div id="plan-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">创建新的约定</h3>
            </div>
            <div class="form-group">
                <label for="plan-content" class="form-label">
                    <i class="ri-heart-line"></i>
                    <span>约定内容</span>
                </label>
                <input type="text" id="plan-content" class="form-input" placeholder="例如：一起去看海...">
            </div>
            <div class="form-group">
                <label for="plan-partner" class="form-label">
                    <i class="ri-user-line"></i>
                    <span>和谁的约定?</span>
                </label>
                <select id="plan-partner" class="form-select">
                    <!-- 选项将由JavaScript动态填充 -->
                </select>
            </div>
            <div class="form-group">
                <label for="plan-notes" class="form-label">
                    <i class="ri-quill-pen-line"></i>
                    <span>备注 (可选)</span>
                </label>
                <textarea id="plan-notes" class="form-textarea" placeholder="可以记录一些悄悄话..."></textarea>
            </div>
            <div class="modal-footer">
                <button id="cancel-plan-btn" class="btn btn-ghost">取消</button>
                <button id="save-plan-btn" class="btn btn-primary">
                    <i class="ri-save-line"></i>
                    <span>保存约定</span>
                </button>
            </div>
        </div>
    </div>
                </div>
                 <div class="wechat-tab-bar">
                    <div class="wechat-tab-item active" data-tab="chat">
                        <i class="ri-chat-heart-line"></i>
                        <div class="notification-dot hidden"></div>
                        <span>聊天</span>
                    </div>
                    <div class="wechat-tab-item" data-tab="moments">
                        <i class="ri-polaroid-2-line"></i>
                        <div class="notification-dot hidden"></div>
                        <span>动态</span>
                    </div>
                    <div class="wechat-tab-item" data-tab="diary">
                        <i class="ri-quill-pen-line"></i>
                        <div class="notification-dot hidden"></div>
                        <span>日记</span>
                    </div>
                    <div class="wechat-tab-item" data-tab="plan">
                        <i class="ri-suitcase-3-line"></i>
                        <div class="notification-dot hidden"></div>
                        <span>计划</span>
                    </div>
                </div>
            </div>

            <div id="theater-screen" class="app-screen-view flex-col hidden" style="">
                <div id="script-list-view">
                    <div class="app-header">
                        <button id="theater-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                        <h3 class="app-header-title">剧场</h3>
                        <button id="add-new-script-btn" class="app-header-btn"><i class="fas fa-plus"></i></button>
                    </div>
                    <div id="script-list-container" class="flex-1 overflow-y-auto p-4 space-y-4">
                        <p class="text-center text-gray-500 mt-8">还没有剧本，点击右上角创建一个吧。</p>
                    </div>
                </div>

                <div id="script-edit-view" class="hidden flex flex-col h-full">
                    <div class="app-header">
                        <button id="script-edit-back-btn" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                        <h3 id="script-edit-title" class="app-header-title">创建新剧本</h3>
                        <button id="save-script-btn" class="app-header-btn text-gray-300 font-bold text-base">保存</button>
                    </div>
                    <div class="flex-1 overflow-y-auto p-4 space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">剧本标题</label>
                            <input type="text" id="script-title-input" class="form-input w-full" placeholder="例如：雨夜的侦探事务所">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">剧本简介</label>
                            <textarea id="script-summary-input" class="form-textarea w-full h-24 resize-none" placeholder="简单描述一下故事背景..."></textarea>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">开场白 (故事的起始段落)</label>
                            <textarea id="script-prompt-input" class="form-textarea w-full h-48 resize-none" placeholder="用第三人称描述故事的开场..."></textarea>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">关联角色</label>
                            <select id="script-character-select" class="form-select w-full">
                                </select>
                        </div>
                        <div class="mt-4">
                            <label class="block text-sm font-medium mb-2">关联世界书 (可选, 可多选)</label>
                            <div id="script-worldbook-select" class="space-y-1 max-h-24 overflow-y-auto p-2 rounded-lg border border-gray-600">
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="scenario-interaction-view" class="flex flex-col h-full hidden">
                    <div class="app-header">
                        <button id="scenario-back-btn" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                        <h3 id="scenario-title" class="app-header-title flex-1 text-center">剧本标题</h3>
                        <button id="scenario-theme-btn" class="app-header-btn ml-1" title="主题美化"><i class="fas fa-palette"></i></button>
                        <button id="scenario-settings-btn" class="app-header-btn ml-1"><i class="fas fa-cog"></i></button>
                    </div>
                    <div id="scenario-content-container" class="flex-1 overflow-y-auto p-4 space-y-4">
                        </div>
                    <div id="scenario-input-bar" class="p-2 border-t border-gray-700">
                        <div class="flex items-center">
                            <textarea id="scenario-input" placeholder="输入你的动作描写..." class="form-textarea flex-1 resize-none" rows="1"></textarea>
                            <button id="retry-scenario-turn-btn" class="ml-2 px-3 py-2 bg-gray-600 text-white rounded-lg" title="重新生成"><i class="fas fa-sync-alt"></i></button>
                            <button id="send-scenario-turn-btn" class="ml-2 px-4 py-2 bg-blue-600 text-white rounded-lg"><i class="far fa-paper-plane"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="wechat-chat-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <div id="chat-header-normal" class="flex items-center justify-between w-full">
                        <button id="wechat-chat-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                        <h3 id="wechat-contact-name" class="app-header-title"></h3>
                        <button id="wechat-options-button" class="app-header-btn"><i class="fas fa-ellipsis-h"></i></button>
                    </div>
                    <div id="chat-header-multiselect" class="hidden items-center justify-between w-full text-sm">
                        <button id="cancel-multiselect-btn" class="font-semibold px-2 py-1">取消</button>
                        <span id="multiselect-count" class="font-bold">已选择 0 项</span>
                        <button id="confirm-multiselect-btn" class="font-semibold text-red-500 px-2 py-1">删除</button>
                    </div>
                </div>
                <template id="bubble-menu-template"></template>


                <div id="wechat-content-chat" class="flex-1 overflow-y-auto p-2 space-y-1">
                    </div>

                <div id="reply-preview-bar" class="hidden items-center justify-between px-3 py-1.5 text-xs border-t">
                    <div class="flex-1 overflow-hidden">
                        <div class="font-semibold" id="reply-preview-author"></div>
                        <div class="truncate" id="reply-preview-content"></div>
                    </div>
                    <button id="cancel-reply-btn" class="ml-2 text-lg p-1">×</button>
                </div>
                
                <div id="chat-quick-actions-bar">
                    <button id="quick-voice-message-btn" class="quick-action-btn" style="color: rgb(255, 255, 255);"><i class="ri-mic-line"></i></button>
                    <button id="quick-voice-call-btn" class="quick-action-btn" style="color: rgb(255, 255, 255);"><i class="ri-phone-line"></i></button>
                    <button id="quick-video-call-btn" class="quick-action-btn" style="color: rgb(255, 255, 255);"><i class="ri-vidicon-line"></i></button>
                </div>

                <div id="chat-footer">
                    <div id="chat-input-bar" class="chat-input-bar flex items-center p-2">
                        <button id="add-feature-btn" class="chat-input-btn" style="color: rgb(255, 255, 255);"><i class="ri-add-circle-line" style="color: rgb(255, 255, 255);"></i></button>
                        <button id="emoji-btn" class="chat-input-btn" style="color: rgb(255, 255, 255);"><i class="ri-emotion-happy-line" style="color: rgb(255, 255, 255);"></i></button>
                        <textarea id="chat-input" placeholder="输入信息..." class="chat-input flex-1 rounded-full px-4 py-2 mx-2 focus:ring-2 focus:ring-gray-500" rows="1" style="color: rgb(255, 255, 255); --placeholder-color: #ffffff;"></textarea>
                        <button id="send-chat-button" class="chat-input-btn" style="color: rgb(255, 255, 255);"><i class="far fa-paper-plane" style="color: rgb(255, 255, 255);"></i></button>
                        <button id="receive-chat-button" class="chat-input-btn" title="接收AI消息" style="color: rgb(255, 255, 255);">
                            <i class="ri-mail-send-line" style="color: rgb(255, 255, 255);"></i>
                        </button>
                    </div>

                    <div id="more-features-panel" class="hidden">
                        <div class="features-grid">
                            <div id="send-image-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-image-line"></i></div>
                                <span>图片</span>
                            </div>
                            <div id="send-red-packet-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-red-packet-line"></i></div>
                                <span>红包</span>
                            </div>
                            <div id="send-transfer-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-exchange-dollar-line"></i></div>
                                <span>转账</span>
                            </div>
                            <div id="drawing-board-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-paint-brush-line"></i></div>
                                <span>画板</span>
                            </div>
                            <div id="tarot-card-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-magic-line"></i></div>
                                <span>塔罗牌</span>
                            </div>
                            <div id="wallet-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-wallet-3-line"></i></div>
                                <span>钱包</span>
                            </div>

                            <div id="gift-shop-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-shopping-bag-3-line"></i></div>
                                <span>商城</span>
                            </div>
                            <div id="chat-capsule-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-capsule-line"></i></div>
                                <span>聊天胶囊</span>
                            </div>

                            <div id="flight-chess-btn" class="feature-item">
                                <div class="feature-icon-wrapper"><i class="ri-heart-pulse-line"></i></div>
                                <span>爱之迷宫</span>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- 表情面板 (美化版) -->
                <div id="sticker-panel">
                    <!-- 刪除按鈕 -->
                    <div id="sticker-delete-btn" class="sticker-delete-btn" title="管理表情包">
                        <i class="ri-delete-bin-line"></i>
                    </div>
                    <div id="sticker-grid">
                        <div id="add-sticker-btn" class="add-sticker-btn" title="添加表情包">
                            <i class="ri-add-line"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 画板弹窗 -->
                <div id="drawing-board-modal" class="drawing-modal-overlay hidden">
                    <div class="drawing-modal-content">
                        <div class="drawing-modal-header">
                            <h3 class="drawing-modal-title">画板</h3>
                            <button id="close-drawing-board" class="drawing-modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="drawing-board-container">
                            <canvas id="drawing-canvas" width="300" height="300"></canvas>
                            <div class="drawing-tools">
                                <div class="color-palette">
                                    <div class="color-swatch selected" data-color="#000000" style="background-color: #000000;"></div>
                                    <div class="color-swatch" data-color="#FF0000" style="background-color: #FF0000;"></div>
                                    <div class="color-swatch" data-color="#00FF00" style="background-color: #00FF00;"></div>
                                    <div class="color-swatch" data-color="#0000FF" style="background-color: #0000FF;"></div>
                                    <div class="color-swatch" data-color="#FFFF00" style="background-color: #FFFF00;"></div>
                                    <div class="color-swatch" data-color="#FF00FF" style="background-color: #FF00FF;"></div>
                                    <div class="color-swatch" data-color="#00FFFF" style="background-color: #00FFFF;"></div>
                                    <div class="color-swatch" data-color="#FFA500" style="background-color: #FFA500;"></div>
                                    <div class="color-swatch" data-color="#800080" style="background-color: #800080;"></div>
                                    <div class="color-swatch" data-color="#008000" style="background-color: #008000;"></div>
                                    <div class="color-swatch" data-color="#FFC0CB" style="background-color: #FFC0CB;"></div>
                                    <div class="color-swatch" data-color="#A52A2A" style="background-color: #A52A2A;"></div>
                                    <div class="color-swatch" data-color="#808080" style="background-color: #808080;"></div>
                                    <div class="color-swatch" data-color="#FFD700" style="background-color: #FFD700;"></div>
                                    <div class="color-swatch" data-color="#32CD32" style="background-color: #32CD32;"></div>
                                    <div class="color-swatch" data-color="#FF69B4" style="background-color: #FF69B4;"></div>
                                </div>
                                <div class="brush-controls">
                                    <div class="brush-preview">
                                        <div id="brush-preview-circle"></div>
                                    </div>
                                    <input type="range" id="brush-size" min="1" max="20" value="5" class="brush-size-slider">
                                    <span id="brush-size-value">5px</span>
                                </div>
                                <div class="drawing-actions">
                                    <button id="undo-drawing" class="drawing-btn secondary" title="撤销上一步">
                                        <i class="fas fa-undo"></i> 撤销
                                    </button>
                                    <button id="clear-canvas" class="drawing-btn secondary">
                                        <i class="fas fa-eraser"></i> 清空
                                    </button>
                                    <button id="send-drawing" class="drawing-btn primary">
                                        <i class="fas fa-paper-plane"></i> 发送
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 塔罗牌弹窗 -->
                <div id="tarot-modal" class="tarot-modal-overlay hidden">
                    <div class="tarot-modal-content">
                        <div class="tarot-modal-header">
                            <h3 class="tarot-modal-title">🔮 塔罗牌占卜</h3>
                            <button id="close-tarot-modal" class="tarot-modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="tarot-container">
                            <div class="tarot-card-display">
                                <div id="tarot-card" class="tarot-card-back">
                                    <div class="card-back-pattern"></div>
                                    <div class="card-back-text">点击抽牌</div>
                                    <div class="symbol-top-right">✦</div>
                                    <div class="symbol-bottom-left">✧</div>
                                    <div class="symbol-bottom-right">✦</div>
                                </div>
                            </div>
                            <div class="tarot-info" id="tarot-info" style="display: none;">
                                <h4 id="card-name" class="card-name"></h4>
                                <p id="card-meaning" class="card-meaning"></p>
                                <div class="card-orientation">
                                    <span id="orientation-text" class="orientation-text"></span>
                                </div>
                            </div>
                            <div class="tarot-actions">
                                <button id="draw-card-btn" class="tarot-btn primary">
                                    <i class="fas fa-magic"></i> 抽一张牌
                                </button>
                                <button id="send-tarot-btn" class="tarot-btn secondary" style="display: none;">
                                    <i class="fas fa-paper-plane"></i> 发送给TA
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 钱包弹窗 -->
                <div id="wallet-modal" class="tarot-modal-overlay hidden">
                    <div class="tarot-modal-content">
                        <div class="tarot-modal-header">
                            <h3 class="tarot-modal-title">💰 我的钱包</h3>
                            <button id="close-wallet-modal" class="tarot-modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="wallet-container">
                            <div class="wallet-summary">
                                <div class="wallet-total">
                                    <h4>当前余额</h4>
                                    <div class="total-amount">¥<span id="current-balance">0.00</span></div>
                                </div>
                                <div class="wallet-stats">
                                    <div class="stat-item">
                                        <span class="stat-label">总收入</span>
                                        <span class="stat-value">¥<span id="total-income">0.00</span></span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">红包收入</span>
                                        <span class="stat-value">¥<span id="redpacket-total">0.00</span></span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">转账收入</span>
                                        <span class="stat-value">¥<span id="transfer-total">0.00</span></span>
                                    </div>
                                </div>
                            </div>
                            <div class="wallet-records">
                                <h4>收入记录</h4>
                                <div id="wallet-records-list" class="records-list">
                                    <!-- 记录将在这里动态生成 -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="wechat-options-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wechat-options-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">聊天设置</h3>
                    <div class="w-8"></div>
                </div>
                <div class="flex-1 p-2 overflow-y-auto space-y-2">
                    <div id="pin-chat-option" class="list-item">置顶对话</div>
                    <div class="list-item flex justify-between items-center" style="display: flex !important; justify-content: space-between !important; align-items: center !important;">
                        <span>隐藏头像</span>
                        <label for="hide-avatars-toggle" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" value="" id="hide-avatars-toggle" class="sr-only peer">
                            <div class="w-9 h-5 bg-gray-600 rounded-full peer peer-focus:ring-4 peer-checked:after:translate-x-full after:content-[&#39;&#39;] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                    <div id="change-chat-bg-option" class="list-item">设置聊天背景</div>
                    <div class="list-item flex justify-between items-center">
                        <span>气泡颜色 (我 / 对方)</span>
                        <div class="flex items-center space-x-3">
                            <input type="color" id="user-bubble-color-picker" class="color-picker-input">
                            <input type="color" id="ai-bubble-color-picker" class="color-picker-input">
                        </div>
                    </div>
                    <div class="list-item flex justify-between items-center">
                        <span>文字颜色 (我 / 对方 / 其他)</span>
                        <div class="flex items-center space-x-2">
                            <input type="color" id="user-text-color-picker" class="color-picker-input">
                            <input type="color" id="ai-text-color-picker" class="color-picker-input">
                            <input type="color" id="other-text-color-picker" class="color-picker-input">
                        </div>
                    </div>
                    <div class="list-item flex justify-center">
                        <button id="reset-colors-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md font-medium transition-colors duration-200 flex items-center space-x-2">
                            <i class="fas fa-undo"></i>
                            <span>重置外观设置</span>
                        </button>
                    </div>
                    <div class="list-item flex justify-between items-center">
                                            <label for="ai-memory-length" class="flex-grow">AI 记忆上下文长度</label>
                    <input type="number" id="ai-memory-length" class="form-input w-20 text-center" min="10" max="500" value="50">
                    </div>
                    <div id="change-user-video-image-option" class="list-item">设置对方的视频照片</div>
                    <div id="clear-chat-history-option" class="list-item text-red-500">清空聊天记录</div>
                    <div id="block-character-option" class="list-item text-red-500">拉黑角色</div>
                    <div id="delete-chat-option" class="list-item text-red-500 mt-4">删除此对话</div>
                </div>
            </div>


            <div id="world-book-list-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wb-list-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">世界书</h3>
                    <button id="wb-add-button" class="app-header-btn"><i class="fas fa-plus"></i></button>
                </div>
                <div id="world-book-list-container" class="flex-1 overflow-y-auto p-2 space-y-2"></div>
            </div>

            <div id="world-book-edit-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="wb-edit-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">编辑世界书</h3>
                    <button id="wb-save-button" class="app-header-btn text-gray-300 font-bold text-base">保存</button>
                    </div>
                <div class="p-2 space-y-4">
                    <input type="text" id="wb-title-input" placeholder="标题" class="form-input">
                    <select id="wb-category-select" class="form-select mt-4">
                        <option value="worldview">角色世界观</option>
                        <option value="rules">输入规范 (AI行为准则)</option>
                        <option value="modules">模块/小剧场风格参考</option>
                        <option value="shared_assets">通用素材库 (表情包/模块)</option>
                        <option value="other">其他资料</option>
                    </select>
                    <textarea id="wb-content-input" placeholder="内容..." class="form-textarea h-64 resize-none"></textarea>
                    <div class="pt-4">
                        <button id="wb-delete-button" class="w-full px-4 py-3 bg-red-600 hover:bg-red-700 text-white rounded-md font-medium transition-colors duration-200">
                            <i class="fas fa-trash mr-2"></i>删除世界书
                        </button>
                    </div>
                </div>
            </div>

            <div id="character-book-list-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="cb-list-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">角色书</h3>
                    <button id="cb-add-button" class="app-header-btn"><i class="fas fa-plus"></i></button>
                </div>
                <div id="character-book-list-container" class="flex-1 overflow-y-auto p-2 space-y-2"></div>
            </div>

            <div id="character-book-edit-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <button id="cb-edit-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title">编辑角色</h3>
                    <button id="cb-save-button" class="app-header-btn text-gray-300 font-bold text-base">保存</button>
                    </div>
                <div class="flex-1 overflow-y-auto p-2 space-y-4">
                    <div class="flex items-center space-x-4 p-2">
                        <div id="character-avatar-placeholder" class="w-20 h-20 rounded-full flex-shrink-0 image-placeholder bg-cover bg-center">
                            <i class="fas fa-camera text-2xl"></i>
                        </div>
                        <input type="file" id="character-avatar-input" accept="image/*">
                        <div class="flex-grow">
                             <label class="block text-sm font-medium mb-1">角色姓名</label>
                             <input type="text" id="cb-name-input" class="form-input">
                        </div>
                    </div>
                     <div class="p-2">
                        <label class="block text-sm font-medium mb-1">角色设定 (性格、记忆、说话风格等)</label>
                        <textarea id="cb-persona-input" class="form-textarea h-24 resize-none"></textarea>
                    </div>
                    <div class="p-2">
                        <label class="block text-sm font-medium mb-1">我的设定 (我与角色的关系)</label>
                        <textarea id="cb-my-persona-input" class="form-textarea h-16 resize-none"></textarea>
                    </div>
                    <div class="p-2">
                        <label class="block text-sm font-medium mb-1">关联世界书 (可多选)</label>
                        <div id="cb-worldbook-select" class="space-y-1 max-h-24 overflow-y-auto p-2 rounded-lg border">
                            </div>
                    </div>
                    <div class="p-2">
                        <div class="flex items-center justify-between">
                            <label class="block text-sm font-medium">公众人物身份</label>
                            <label for="cb-is-celebrity" class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" value="" id="cb-is-celebrity" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[&#39;&#39;] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                                <span class="ml-3 text-sm font-medium text-gray-300">是否为名人</span>
                            </label>
                        </div>
                    </div>
                    <div id="celebrity-identity-container" class="p-2 mt-2 hidden">
                        <label for="cb-celebrity-identity" class="block text-sm font-medium mb-1">名人身份描述</label>
                        <textarea id="cb-celebrity-identity" class="form-textarea h-16 resize-none" placeholder="例如：一位隐退的传奇赛车手、备受争议的先锋艺术家..."></textarea>
                    </div>
                    <div class="p-2">
                        <label class="block text-sm font-medium mb-2">角色专属素材库 (AI会优先使用这里的内容)</label>
                        <div id="cb-expressions-container" class="space-y-2 max-h-48 overflow-y-auto p-2 border border-gray-600 rounded-lg">
                            </div>
                        <div class="flex gap-2 mt-2">
                            <input type="text" id="expression-keyword-input" placeholder="关键词 (如: 开心)" class="form-input flex-1">
                            <textarea id="expression-content-input" placeholder="素材内容 (图片链接 或 HTML代码)" class="form-textarea flex-1 h-12 resize-none"></textarea>
                            <button id="add-expression-btn" class="px-3 bg-gray-600 text-white rounded-md text-sm">添加</button>
                        </div>
                    </div>
                    <div class="p-2">
                        <button id="cb-delete-button" class="w-full mt-4 px-4 py-2 bg-red-600 text-white rounded-md hidden">删除角色</button>
                    </div>
                </div>
            </div>
            
            <div id="main-settings-screen" class="app-screen-view main-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="main-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">设置</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto">
                    <div class="space-y-2">
                        <div id="api-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-key w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">API 设定</h4>
                            </div>
                        </div>
                        <div id="heartbeat-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-heartbeat w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">角色心跳</h4>
                            </div>
                        </div>
                    </div>
                    <div class="space-y-2 mt-8">
                        <div id="beautify-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-palette w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">美化设置</h4>
                            </div>
                        </div>
                         <div id="font-settings-link" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-font w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">字体设置</h4>
                            </div>
                        </div>
                    </div>
                     <div class="space-y-2 mt-8">
                        <div id="fullscreen-toggle-btn" class="list-item flex justify-between items-center cursor-pointer hover:bg-gray-100 transition-colors" title="进入全屏">
                            <div class="flex items-center">
                               <i class="fas fa-expand w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">全屏模式</h4>
                            </div>
                        </div>
                        <div id="export-data-btn" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-download w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">一键导出所有资料</h4>
                            </div>
                        </div>
                         <div id="import-data-btn" class="list-item flex justify-between items-center">
                            <div class="flex items-center">
                               <i class="fas fa-upload w-6 text-center mr-3"></i>
                               <h4 class="font-semibold">一键上传所有资料</h4>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="beautify-settings-screen" class="app-screen-view beautify-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="beautify-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">美化设置</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto space-y-2">
                    <div id="change-wallpaper-link" class="list-item flex justify-between items-center">
                        <h4 class="font-semibold">更换手机壁纸</h4>
                    </div>
                    <input type="file" id="wallpaper-input" accept="image/*">
                    <div id="change-app-icons-link" class="list-item flex justify-between items-center">
                        <h4 class="font-semibold">更换App图标</h4>
                    </div>
                    <div class="list-item">
                        <h4 class="font-semibold mb-2">角色朋友圈配图URL</h4>
                        <input type="url" id="custom-image-url" class="form-input w-full" placeholder="请输入图片链接，如：https://example.com/image.jpg">
                        <p class="text-xs text-gray-400 mt-1">角色自动发布朋友圈时将使用此图片作为配图</p>
                        <button id="save-image-url" class="mt-2 px-4 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm">保存设置</button>
                    </div>

                    <div class="list-item">
                        <h4 class="font-semibold mb-2">清除主界面内容</h4>
                        <p class="text-xs text-gray-400 mb-3">清除播放器背景、照片墙图片和应用图标，恢复默认效果</p>
                        <div class="flex gap-1.5">
                            <button id="clear-player-bg" class="flex-1 px-2 py-1.5 bg-red-600 hover:bg-red-700 text-white rounded text-xs">清除播放器背景</button>
                            <button id="clear-photo-wall" class="flex-1 px-2 py-1.5 bg-red-600 hover:bg-red-700 text-white rounded text-xs">清除照片墙</button>
                            <button id="clear-app-icons" class="flex-1 px-2 py-1.5 bg-red-600 hover:bg-red-700 text-white rounded text-xs">清除应用图标</button>
                        </div>
                        <button id="clear-all-main-content" class="w-full mt-2 px-2 py-1.5 bg-orange-600 hover:bg-orange-700 text-white rounded text-xs">一键清除所有主界面内容</button>
                    </div>
                </div>
            </div>

             <div id="app-icon-settings-screen" class="app-screen-view app-icon-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="app-icon-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">更换App图标</h3>
                </div>
                <div id="app-icon-list" class="settings-content flex-1 p-2 overflow-y-auto space-y-2">
                    </div>
            </div>

            <div id="font-settings-screen" class="app-screen-view font-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="font-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">字体设置</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto space-y-4">
                    <div class="p-4 rounded-lg bg-card">
                        <label class="block text-sm font-medium mb-2">文字大小</label>
                        <div id="font-size-selector" class="flex justify-between rounded-lg p-1 text-sm">
                            <button data-size="small" class="font-size-btn w-full rounded-md py-1 px-3 transition-colors">小</button>
                            <button data-size="medium" class="font-size-btn w-full rounded-md py-1 px-3 transition-colors active">中</button>
                            <button data-size="large" class="font-size-btn w-full rounded-md py-1 px-3 transition-colors">大</button>
                        </div>
                    </div>
                    <div class="p-4 rounded-lg bg-card">
                        <label for="font-url-input" class="block text-sm font-medium mb-2">字体文件URL (支持.ttf, .otf, .woff等)</label>
                        <input type="text" id="font-url-input" class="form-input w-full" placeholder="https://example.com/font.ttf">
                        <button id="font-save-button" class="w-full mt-4 px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-md">应用字体</button>
                        </div>
                </div>
            </div>

            <div id="heartbeat-settings-screen" class="app-screen-view heartbeat-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="heartbeat-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">角色心跳设置</h3>
                </div>
<div class="settings-content flex-1 p-2 overflow-y-auto space-y-4">

    <div class="p-4 rounded-lg bg-card">
        <h3 class="font-bold mb-4 flex items-center">
            <i class="fas fa-cogs mr-2"></i>
            角色关系心跳
        </h3>
        <div class="space-y-4">
            <div>
                <label for="system-heartbeat-interval" class="block text-sm font-medium mb-2">心跳间隔 (小时)</label>
                <input type="number" id="system-heartbeat-interval" min="0.1" max="24" step="0.1" value="1" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">系统**每隔这么久**就会进行一次"全局检查"，看看有没有哪个角色需要主动联系您。<br><strong>案例：</strong>设置为`2`，则每2小时检查一次。</p>
            </div>
            <div>
                <label for="system-trigger-threshold" class="block text-sm font-medium mb-2">触发阈值 (分钟)</label>
                <input type="number" id="system-trigger-threshold" min="1" max="1440" step="1" value="1" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">当"全局检查"时，如果发现您与某个角色**超过这个分钟数**没有互动，该角色就会主动给您发私信。<br><strong>案例：</strong>设置为`60`，则超过1小时没聊天的角色，在下次检查时可能会联系您。</p>
            </div>
        </div>
    </div>

    <div class="p-4 rounded-lg bg-card">
        <h3 class="font-bold mb-4 flex items-center">
            <i class="fas fa-tree mr-2"></i>
            栖木心跳
        </h3>
        <div class="space-y-4">
            <div>
                <label for="perch-heartbeat-interval" class="block text-sm font-medium mb-2">心跳间隔 (分钟)</label>
                <input type="number" id="perch-heartbeat-interval" min="1" max="1440" step="1" value="5" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">系统**每隔这么久**就会"提醒"一次所有AI角色："嘿，要不要去栖木上发点什么？"<br><strong>案例：</strong>设置为`10`，则每10分钟提醒一次。</p>
            </div>
            <div>
                <label for="perch-post-probability" class="block text-sm font-medium mb-2">发帖概率 (%)</label>
                <input type="number" id="perch-post-probability" min="0" max="100" step="1" value="30" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">当AI角色收到"提醒"时，它会根据这个概率**决定是否真的要发帖**。<br><strong>案例：</strong>设置为`30`，则每个角色每次被提醒时，有30%的可能性会去发帖。**设置为`0`则彻底关闭此功能。**</p>
            </div>
        </div>
    </div>

    <div class="p-4 rounded-lg bg-card">
        <h3 class="font-bold mb-4 flex items-center">
            <i class="fas fa-pen-fancy mr-2"></i>
            NPC文学创作心跳
        </h3>
        <div class="space-y-4">
            <div>
                <label for="npc-writing-min-interval" class="block text-sm font-medium mb-2">最小间隔 (分钟)</label>
                <input type="number" id="npc-writing-min-interval" min="1" max="1440" step="1" value="5" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">NPC进行一次文学创作后，**至少**要等这么多分钟，才可能再次创作。</p>
            </div>
            <div>
                <label for="npc-writing-max-interval" class="block text-sm font-medium mb-2">最大间隔 (分钟)</label>
                <input type="number" id="npc-writing-max-interval" min="1" max="1440" step="1" value="15" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">NPC的创作欲望有"保底"，**最多**等这么多分钟，系统就会强制他思考一次要不要创作。</p>
            </div>
            <div>
                <label for="npc-writing-probability" class="block text-sm font-medium mb-2">触发概率 (%)</label>
                <input type="number" id="npc-writing-probability" min="0" max="100" step="1" value="35" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">在最小和最大间隔之间的**每一次随机检查**中，有这么大的概率会成功触发创作。</p>
            </div>
        </div>
    </div>

    <div class="p-4 rounded-lg bg-card">
        <h3 class="font-bold mb-4 flex items-center">
            <i class="fas fa-user-secret mr-2"></i>
            匿名树洞心跳
        </h3>
        <div class="space-y-4">
            <div>
                <label for="anonymous-min-interval" class="block text-sm font-medium mb-2">最小间隔 (分钟)</label>
                <input type="number" id="anonymous-min-interval" min="1" max="1440" step="1" value="20" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">NPC发布一条匿名树洞后，**至少**要等这么多分钟，才可能再次分享心情。</p>
            </div>
            <div>
                <label for="anonymous-max-interval" class="block text-sm font-medium mb-2">最大间隔 (分钟)</label>
                <input type="number" id="anonymous-max-interval" min="1" max="1440" step="1" value="40" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">NPC的倾诉欲望有"保底"，**最多**等这么多分钟，系统就会提醒他考虑要不要匿名分享点什么。</p>
            </div>
            <div>
                <label for="anonymous-probability" class="block text-sm font-medium mb-2">触发概率 (%)</label>
                <input type="number" id="anonymous-probability" min="0" max="100" step="1" value="50" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">在最小和最大间隔之间的**每一次随机检查**中，有这么大的概率会成功触发匿名分享。<br><strong>案例：</strong>设置为`50`，则每次检查时有一半的机会会发布树洞。</p>
            </div>
        </div>
    </div>

    <div class="p-4 rounded-lg bg-card">
        <h3 class="font-bold mb-4 flex items-center">
            <i class="fas fa-robot mr-2"></i>
            NPC定时发帖心跳
        </h3>
        <div class="space-y-4">
            <div>
                <label for="npc-post-min-interval" class="block text-sm font-medium mb-2">最小间隔 (分钟)</label>
                <input type="number" id="npc-post-min-interval" min="1" max="1440" step="1" value="2" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">NPC发布一条普通帖子后，**至少**要等这么多分钟，才可能再次发帖。<br><strong>案例：</strong>设置为`5`，则NPC每5分钟最多发一条帖子。</p>
            </div>
            <div>
                <label for="npc-post-max-interval" class="block text-sm font-medium mb-2">最大间隔 (分钟)</label>
                <input type="number" id="npc-post-max-interval" min="1" max="1440" step="1" value="5" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">NPC的社交需求有"保底"，**最多**等这么多分钟，系统就会提醒他考虑要不要发条帖子互动一下。</p>
            </div>
            <div>
                <label for="npc-post-probability" class="block text-sm font-medium mb-2">触发概率 (%)</label>
                <input type="number" id="npc-post-probability" min="0" max="100" step="1" value="25" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">在最小和最大间隔之间的**每一次随机检查**中，有这么大的概率会成功触发发帖。<br><strong>案例：</strong>设置为`25`，则每次检查时有四分之一的机会会发布新帖子。</p>
            </div>
        </div>
    </div>

    <div class="p-4 rounded-lg bg-card">
        <h3 class="font-bold mb-4 flex items-center">
            <i class="fas fa-users mr-2"></i>
            朋友圈发布间隔
        </h3>
        <div class="space-y-4">
            <div>
                <label for="moments-min-interval" class="block text-sm font-medium mb-2">最小间隔 (分钟)</label>
                <input type="number" id="moments-min-interval" min="1" max="1440" step="1" value="30" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">这是一个"冷却时间"。角色发布一条朋友圈动态后，**至少要等这么多分钟**才能发布下一条，以防刷屏。<br><strong>案例：</strong>设置为`60`，则角色一小时内最多只会发布一条动态。</p>
            </div>
            <div>
                <label for="moments-time-trigger-interval" class="block text-sm font-medium mb-2">时间触发间隔 (小时)</label>
                <input type="number" id="moments-time-trigger-interval" min="1" max="72" step="0.5" value="6" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">当角色与用户长时间没有互动时，经过这么多小时后，系统会考虑让角色主动发布朋友圈分享生活。<br><strong>案例：</strong>设置为`4`，则4小时无聊天后可能触发朋友圈。</p>
            </div>
            <div>
                <label for="moments-trigger-probability" class="block text-sm font-medium mb-2">发布概率 (%)</label>
                <input type="number" id="moments-trigger-probability" min="0" max="100" step="5" value="80" class="form-input w-full">
                <p class="text-xs text-gray-400 mt-1">当满足发布条件时（情感触发或时间触发），实际发布朋友圈的概率。<br><strong>案例：</strong>设置为`80`，则有80%的机会会发布，20%机会跳过。</p>
            </div>
        </div>
    </div>

    <div class="flex gap-2 mt-6">
        <button id="save-heartbeat-settings" class="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md font-medium">
            <i class="fas fa-save mr-2"></i>保存设置
        </button>
        <button id="reset-heartbeat-settings" class="flex-1 px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md font-medium">
            <i class="fas fa-undo mr-2"></i>重置默认
        </button>
    </div>
    
    <!-- 测试功能区域 -->
    <div class="mt-6 p-4 rounded-lg bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800">
        <h4 class="font-bold text-yellow-800 dark:text-yellow-200 mb-3">
            <i class="fas fa-flask mr-2"></i>快速测试
        </h4>
        <p class="text-sm text-yellow-700 dark:text-yellow-300 mb-3">
            测试模式会临时将时间间隔设为10秒，概率设为100%，方便快速验证功能
        </p>
        <div class="flex gap-2">
            <button id="test-moments-trigger" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-md font-medium">
                <i class="fas fa-play mr-2"></i>开始测试
            </button>
            <button id="stop-moments-test" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md font-medium hidden">
                <i class="fas fa-stop mr-2"></i>停止测试
            </button>
        </div>
        <div id="test-status" class="mt-3 p-2 rounded bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-200 text-sm hidden">
            <strong>测试状态：</strong><span id="test-status-text">准备就绪</span>
        </div>
    </div>

    <div id="heartbeat-status" class="mt-4 p-4 rounded-lg text-center font-semibold text-sm hidden"></div>
</div>
            </div>

            <div id="api-settings-screen" class="app-screen-view api-settings-screen flex-col hidden">
                <div class="app-header">
                    <button id="api-settings-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    <h3 class="app-header-title flex-grow text-center">API 设定</h3>
                </div>
                <div class="settings-content flex-1 p-2 overflow-y-auto space-y-6">
                    <!-- API配置管理 -->
                    <div class="p-4 rounded-lg bg-card">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="font-bold">API 配置管理</h3>
                            <button id="add-api-config-btn" class="px-3 py-1.5 bg-blue-600 text-white rounded-md text-sm hover:bg-blue-700">
                                <i class="fas fa-plus mr-1"></i>新增配置
                            </button>
                        </div>
                        <div class="space-y-3">
                            <div>
                                <label for="api-config-select" class="block text-sm font-medium mb-2">选择API配置:</label>
                                <div class="flex items-center gap-2">
                                    <select id="api-config-select" class="form-select flex-grow"><option value="">请选择配置...</option></select>
                                    <button id="delete-api-config-btn" class="px-3 py-2 bg-red-600 text-white rounded-md text-sm hover:bg-red-700" title="删除当前配置">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 配置详情 -->
                    <div class="p-4 rounded-lg bg-card">
                        <h3 class="font-bold mb-4">连接设定</h3>
                        <div class="space-y-4">
                            <div>
                                <label for="config-name" class="block text-sm font-medium mb-1">配置名称:</label>
                                <input type="text" id="config-name" placeholder="例如: OpenAI配置" class="api-input form-input">
                            </div>
                            <div class="flex items-center justify-between mb-4 pb-4 border-b border-gray-700/50">
                                <label for="api-enabled-toggle" class="block text-sm font-medium">启用 API 连接</label>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="api-enabled-toggle" class="sr-only peer">
                                    <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[&#39;&#39;] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                                </label>
                            </div>
                            <div>
                                <label for="api_url" class="block text-sm font-medium mb-1">API 地址:</label>
                                <input type="text" id="api_url" placeholder="例如: https://api.example.com/v1" class="api-input form-input" oninput="checkApiStatus()">
                                <!-- 🚀 API状态检测显示器 -->
                                <div id="api-status-indicator" style="margin-top: 8px; padding: 8px; border-radius: 6px; font-size: 12px; display: none;">
                                    <div class="api-status-content"></div>
                                </div>
                            </div>
                            <div>
                                <label for="api_key" class="block text-sm font-medium mb-1">API 密钥:</label>
                                <input type="password" id="api_key" placeholder="在此输入您的API金钥" class="api-input form-input">
                            </div>
                        </div>
                    </div>

                    <div class="p-4 rounded-lg bg-card">
                        <h3 class="font-bold mb-4">模型选择</h3>
                        <div class="space-y-4">
                             <div>
                                <label for="model_select" class="block text-sm font-medium mb-1">选取 API 模型:</label>
                                <div class="flex items-center gap-2">
                                    <select id="model_select" class="api-input form-select flex-grow">
                                        <!-- Models will be populated by JS -->
                                    </select>
                                    <button id="fetch_models_btn" class="px-3 py-2 bg-gray-600 text-white rounded-md text-sm flex-shrink-0">获取模型</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex gap-2 mt-2">
                        <button id="save_settings_btn" class="flex-1 flex justify-center items-center px-3 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700">保存当前配置</button>
                        <button id="apply_config_btn" class="flex-1 flex justify-center items-center px-3 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700">应用配置</button>
                    </div>
                    <div id="current-config-info" class="mt-3 p-3 bg-gray-800 rounded-lg text-sm hidden">
                        <div class="flex items-center justify-between">
                            <span class="text-gray-300">当前应用配置:</span>
                            <span id="current-config-name" class="text-green-400 font-medium"></span>
                        </div>
                    </div>
                    <div id="api-status" class="mt-4 p-4 rounded-lg text-center font-semibold text-sm hidden"></div>
                    <div id="security-warning" class="bg-yellow-100 text-yellow-700 mt-4 p-4 rounded-lg hidden" role="alert">
                        <p class="font-bold">安全提醒</p>
                        <p>API 金钥储存在浏览器本地储存中，这在公共电脑上可能不安全。请谨慎使用。</p>
                    </div>
                </div>
            </div>

            <div id="voice-call-screen" class="call-screen">
                <div class="call-background" id="voice-call-bg"></div>
                <div class="call-content">
                    <div class="flex flex-col items-center flex-shrink-0">
                        <img id="voice-call-avatar" src="./RavenPhone【0916自存】_files/FFF(1)" alt="avatar">
                        <h3 id="voice-call-name" class="text-2xl font-bold mt-4">Character Name</h3>
                        <p id="voice-call-timer" class="text-gray-300">00:00</p>
                    </div>
                    <div class="mt-auto w-full">
                        <div class="call-status-box" id="voice-call-status-box"></div>
                        <div class="call-input-area">
                            <textarea id="voice-call-input" placeholder="输入互动文字..." rows="1"></textarea>
                            <button id="voice-call-retry-btn" title="重新生成"><i class="ri-refresh-line"></i></button>
                            <button id="voice-call-send-btn"><i class="ri-send-plane-2-fill"></i></button>
                        </div>
                        <div class="call-controls">
                            <button id="voice-call-hangup" class="call-control-btn hangup-btn"><i class="fas fa-phone-slash"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="video-call-screen" class="call-screen">
                <div class="call-background" id="video-call-bg"></div>
                <div class="call-content">
                    <div id="user-video-preview">
                        <img id="user-video-image" src="./RavenPhone【0916自存】_files/FFF(2)" alt="user video">
                    </div>
                    <div class="mt-auto w-full">
                        <div class="call-status-box" id="video-call-status-box"></div>
                         <div class="call-input-area">
                            <textarea id="video-call-input" placeholder="输入互动文字..." rows="1"></textarea>
                            <button id="video-call-retry-btn" title="重新生成"><i class="ri-refresh-line"></i></button>
                            <button id="video-call-send-btn"><i class="ri-send-plane-2-fill"></i></button>
                        </div>
                        <div class="call-controls">
                            <button id="video-call-hangup" class="call-control-btn hangup-btn"><i class="fas fa-phone-slash"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 栖木 App 界面和发布弹窗 -->
            <div id="perch-screen" class="app-screen-view flex-col hidden">
                <div class="app-header">
                    <div class="w-12">
                        <button id="perch-back-button" class="app-header-btn"><i class="fas fa-chevron-left"></i></button>
                    </div>
                    <h3 class="app-header-title flex-grow text-center perch-app-title">栖木</h3>
                    <div class="w-12 text-right">
                        <button id="perch-settings-btn" class="app-header-btn" title="设置" style="font-size: 1.5em !important; margin-top: 1px !important; position: relative; top: 2px;" onclick="openPerchSettingsModal()">
                            <i class="ri-settings-3-line"></i>
                        </button>
                    </div>
                </div>
                
                <!-- 栖木互动栏 -->
                <div class="perch-interaction-bar">
                    <div class="perch-user-profile">
                        <div class="avatar-frame has-custom-image" id="perch-user-avatar" title="点击更换头像" onclick="changePerchAvatar()" style="background-image: url(&quot;https://placehold.co/128x128/777/FFF?text=Me&quot;); background-size: cover; background-position: center center; background-repeat: no-repeat;">
                            <i class="ri-user-line" style="font-size: 1.5rem; color: white; display: none;"></i>
                        </div>
                        <div class="perch-user-name" id="perch-user-name" title="点击更换名字" onclick="editPerchName()">
                            我的名字
                        </div>
                    </div>
                    <div class="perch-action-buttons">
                        <button id="perch-refresh-btn" class="perch-action-btn" title="刷新">
                            <i class="ri-refresh-line"></i>
                        </button>
                        <button id="perch-set-worldview-btn" class="perch-action-btn" title="设定当前世界">
                            <i class="ri-global-line"></i>
                        </button>
                        <button id="perch-notifications-btn" class="perch-action-btn relative" title="通知">
                            <i class="ri-notification-3-line"></i>
                            <div id="perch-notification-dot" class="absolute top-2 right-2 w-2 h-2 bg-red-500 rounded-full hidden"></div>
                        </button>
                        <button id="new-perch-post-btn" class="perch-action-btn" title="发布新帖子">
                            <i class="ri-quill-pen-line"></i>
                        </button>
                    </div>
                </div>
                
                <div id="perch-feed-container" class="flex-1 overflow-y-auto p-2 space-y-3">
                    </div>
            </div>

            <div id="perch-forward-modal" class="modal-overlay">
                <div class="modal-content w-[90%] max-w-[400px]">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold">转发给...</h3>
                        <button id="close-perch-forward-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <ul id="perch-forward-character-list" class="space-y-2 max-h-60 overflow-y-auto">
                        </ul>
                </div>
            </div>

            <div id="new-perch-post-modal" class="modal-overlay">
                <div class="modal-content w-[95%] max-w-[450px]">
                    <h3 class="text-xl font-bold mb-4">分享你的想法</h3>

                    <textarea id="perch-content-input" class="form-textarea h-48 resize-none mb-4" placeholder="在此栖息..."></textarea>

                    <div class="flex items-center justify-between mb-6">
                        <label for="perch-anonymous-toggle" class="text-sm">作为匿名者发布</label>
                        <input type="checkbox" id="perch-anonymous-toggle" class="form-checkbox h-5 w-5">
                    </div>

                    <div class="flex justify-end mb-4">
                        <button class="set-visibility-btn text-sm text-blue-400 hover:text-blue-300 flex items-center gap-1">
                            <i class="ri-group-line"></i>
                            <span>所有人可见</span>
                        </button>
                    </div>

                    <div class="flex justify-end gap-2">
                        <button id="cancel-perch-post-btn" class="px-4 py-2 rounded-lg">取消</button>
                        <button id="confirm-perch-post-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg">发布</button>
                    </div>
                </div>
            </div>

            <!-- 回响弹窗 -->
            <div id="perch-echo-modal" class="modal-overlay">
                <div class="modal-content w-[95%] max-w-[450px]">
                    <h3 class="text-xl font-bold mb-4">发表你的回响</h3>

                    <div id="original-post-preview" class="mb-4 p-3 border border-gray-600 rounded-lg bg-black/20">
                        <div class="flex items-center mb-2">
                            <div id="original-post-avatar" class="w-6 h-6 rounded-full mr-2 bg-zinc-600 bg-cover bg-center"></div>
                            <span id="original-post-author" class="font-semibold text-sm"></span>
                        </div>
                        <p id="original-post-content" class="text-sm text-gray-300 max-h-24 overflow-y-auto whitespace-pre-wrap"></p>
                    </div>

                    <textarea id="echo-content-input" class="form-textarea h-32 resize-none mb-4" placeholder="在此写下你的回响..."></textarea>

                    <div class="flex justify-end gap-2">
                        <button id="cancel-echo-post-btn" class="px-4 py-2 rounded-lg">取消</button>
                        <button id="confirm-echo-post-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg">发布回响</button>
                    </div>
                </div>
            </div>
            
            <!-- 栖木头像更换弹窗 -->
            <div id="perch-avatar-modal" class="modal-overlay hidden">
                <div class="modal-content w-[90%] max-w-[420px]">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold">更换头像</h3>
                        <button id="close-perch-avatar-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    
                    <div class="mb-4">
                        <label for="perch-avatar-input" class="block text-sm font-medium mb-2">选择头像图片</label>
                        <input type="file" id="perch-avatar-input" accept="image/*" class="hidden">
                        <button id="perch-avatar-upload-btn" class="w-full p-3 border-2 border-dashed border-gray-400 rounded-lg text-center hover:border-gray-300 hover:bg-gray-50 transition-colors">
                            <i class="ri-image-add-line text-2xl mb-2 block"></i>
                            <span>点击上传头像</span>
                        </button>
                    </div>
                    
                    <div class="mb-4">
                        <label for="perch-avatar-url" class="block text-sm font-medium mb-2">或输入图片URL</label>
                        <input type="url" id="perch-avatar-url" placeholder="https://example.com/image.jpg" class="w-full p-2 border border-gray-300 rounded-lg">
                    </div>
                    
                    <div class="flex justify-end gap-2">
                        <button id="reset-perch-avatar-btn" class="px-4 py-2 rounded-lg border border-gray-300">重置为默认</button>
                        <button id="confirm-perch-avatar-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg">确认更换</button>
                    </div>
                </div>
            </div>


            <!-- 红包/转账 Modal -->
            <div id="red-packet-modal" class="payment-modal-overlay">
                <div class="payment-modal-content">
                    <div class="payment-header">
                        <button class="close-btn" data-target="red-packet-modal"><i class="ri-close-line"></i></button>
                        <span class="title">发红包</span>
                        <div class="w-8"></div>
                    </div>
                    <div class="payment-content">
                        <div class="amount-input-wrapper">
                            <span class="currency-symbol">¥</span>
                            <input type="number" class="amount-input" id="red-packet-amount" placeholder="0.00" min="0.01">
                        </div>
                        <input type="text" class="message-input" id="red-packet-message" placeholder="恭喜发财，大吉大利">
                        <button class="send-payment-btn" id="send-red-packet-confirm-btn">塞钱进红包</button>
                    </div>
                </div>
            </div>

            <div id="transfer-modal" class="payment-modal-overlay">
                 <div class="payment-modal-content">
                    <div class="payment-header">
                        <button class="close-btn" data-target="transfer-modal"><i class="ri-close-line"></i></button>
                        <span class="title">转账</span>
                        <div class="w-8"></div>
                    </div>
                    <div class="payment-content">
                        <div class="amount-input-wrapper">
                            <span class="currency-symbol">¥</span>
                            <input type="number" class="amount-input" id="transfer-amount" placeholder="0.00" min="0.01">
                        </div>
                        <input type="text" class="message-input" id="transfer-message" placeholder="转账说明">
                        <button class="send-payment-btn" id="send-transfer-confirm-btn">转账</button>
                    </div>
                </div>
            </div>

        </div>
        
        <!-- Dock栏 - 从home-screen中移出，现在与phone-screen成为兄弟关系 -->
        <div class="dock absolute bottom-4 left-1/2 -translate-x-1/2 w-[90%] max-w-[340px] h-18 rounded-3xl p-2 flex items-center justify-around shadow-xl" style="display: flex;">
            <div class="flex flex-col items-center"><div class="bg-zinc-800 rounded-xl flex items-center justify-center shadow-lg app-icon" data-app-name="世界书"><i class="fas fa-book text-white text-2xl"></i></div></div>
            <div class="flex flex-col items-center"><div class="bg-zinc-800 rounded-xl flex items-center justify-center shadow-lg app-icon" data-app-name="角色书"><i class="fas fa-theater-masks text-white text-2xl"></i></div></div>
            <div class="flex flex-col items-center"><div class="bg-zinc-800 rounded-xl flex items-center justify-center shadow-lg app-icon" data-app-name="微信"><i class="fab fa-weixin text-white text-2xl"></i></div></div>
        </div>
        
        <!-- FIX 4: ADDED NOTIFICATION ELEMENT (移动到这里) -->
        <div id="new-message-alert" class="hidden flex items-center absolute top-14 left-2 right-2 z-[9400] bg-gray-800/80 backdrop-blur-lg rounded-2xl p-3 shadow-xl cursor-pointer transition-transform duration-300 -translate-y-[200%]">
            <img id="new-message-avatar" src="./RavenPhone【0916自存】_files/FFF" class="w-12 h-12 rounded-full object-cover mr-3">
            <div class="flex-grow overflow-hidden">
                <p id="new-message-name" class="font-bold text-white">Character Name</p>
                <p id="new-message-preview" class="text-sm text-gray-200 truncate">New message content...</p>
            </div>
        </div>
    </div>

    <!-- 栖木相关模态框 - 移出手机框架以获得更好的显示效果 -->
    <!-- 栖木名字更换弹窗 -->
    <div id="perch-name-modal" class="modal-overlay hidden">
        <div class="modal-content w-[90%] max-w-[420px]">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">更换名字</h3>
                <button id="close-perch-name-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="mb-4">
                <label for="perch-name-input" class="block text-sm font-medium mb-2">输入新名字</label>
                <input type="text" id="perch-name-input" placeholder="输入你的新名字" class="w-full p-2 border border-gray-300 rounded-lg" maxlength="20">
            </div>
            
            <div class="flex justify-end gap-2">
                <button id="cancel-perch-name-btn" class="px-4 py-2 rounded-lg border border-gray-300">取消</button>
                <button id="confirm-perch-name-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg">确认更换</button>
            </div>
        </div>
    </div>

    <div id="perch-worldview-modal" class="modal-overlay">
        <div class="modal-content w-[95%] max-w-[460px] flex flex-col max-h-[80vh]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-xl font-bold">设定栖木世界观</h3>
                <button id="close-perch-worldview-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">×</button>
            </div>
            <div id="perch-worldview-list" class="flex-1 overflow-y-auto space-y-2">
                </div>
        </div>
    </div>

    <div id="perch-settings-modal" class="modal-overlay">
        <div class="modal-content w-[95%] max-w-[480px] flex flex-col max-h-[85vh]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-xl font-bold">栖木设置</h3>
                <button id="close-perch-settings-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">×</button>
            </div>

            <div class="flex-1 overflow-y-auto space-y-4">
                <div>
                    <h4 class="font-semibold mb-2">屏蔽内置NPC</h4>
                    <div id="mute-npc-list" class="space-y-2 p-2 bg-black/20 rounded-lg">
                        </div>
                </div>

                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="font-semibold">自定义NPC管理</h4>
                        <button id="add-custom-npc-btn" class="text-sm bg-blue-600 text-white px-3 py-1 rounded-md hover:bg-blue-700">添加新NPC</button>
                    </div>
                    <div id="custom-npc-list-container" class="space-y-2 p-2 bg-black/20 rounded-lg min-h-[50px]">
                        </div>
                </div>
            </div>

            <div class="mt-4 pt-4 border-t border-gray-700 flex justify-end">
                <button id="save-perch-settings-btn" class="px-4 py-2 bg-green-600 text-white rounded-lg">保存设置</button>
            </div>
        </div>
    </div>

    <div id="perch-custom-npc-modal" class="modal-overlay">
        <div class="modal-content w-[95%] max-w-[460px]">
            <h3 id="custom-npc-modal-title" class="text-xl font-bold mb-4">添加新NPC</h3>
            <input type="hidden" id="editing-npc-id">
            <div class="space-y-3">
                <div>
                    <label class="text-sm">名字:</label>
                    <input type="text" id="custom-npc-name" class="form-input mt-1" placeholder="NPC在论坛显示的名字">
                </div>
                <div>
                    <label class="text-sm">头像URL:</label>
                    <input type="text" id="custom-npc-avatar" class="form-input mt-1" placeholder="一个图片链接">
                </div>
                <div>
                    <label class="text-sm">角色设定 (Persona):</label>
                    <textarea id="custom-npc-persona" class="form-textarea h-24 mt-1" placeholder="详细描述该角色的性格、背景、知识等。"></textarea>
                </div>
                <div>
                    <label class="text-sm">发帖风格 (Prompt):</label>
                    <textarea id="custom-npc-style" class="form-textarea h-24 mt-1" placeholder="给AI的具体指令，告诉它如何发帖，例如：必须以&#39;XX说：&#39;开头..."></textarea>
                </div>
            </div>
            <div class="mt-4 flex justify-end gap-2">
                <button id="cancel-custom-npc-btn" class="px-4 py-2 rounded-lg">取消</button>
                <button id="save-custom-npc-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg">保存</button>
            </div>
        </div>
    </div>

    <!-- V7.1: 发布新动态 Modal - 用户专用 -->
    <div id="post-moment-modal" class="modal-overlay">
        <div class="modal-content w-[90%] max-w-[320px]">
            <h3 class="text-xl font-bold text-white mb-4">发布我的动态</h3>
            <select id="moment-author-select" class="form-select mb-3 hidden"></select>
            <textarea id="moment-content-input" class="form-textarea h-24 resize-none mb-3" placeholder="分享新鲜事..."></textarea>
            <button id="moment-image-upload-btn" class="w-full py-2 bg-gray-700/50 hover:bg-gray-700 rounded-lg mb-4">
                <i class="ri-image-add-line mr-2"></i><span id="moment-image-label">添加图片 (可选)</span>
            </button>
            <input type="file" id="moment-image-input" class="hidden" accept="image/*">
            <div class="flex justify-end mb-4">
                <button class="set-visibility-btn text-sm text-blue-400 hover:text-blue-300 flex items-center gap-1">
                    <i class="ri-group-line"></i>
                    <span>所有人可见</span>
                </button>
            </div>
            <div class="flex justify-end gap-2">
                <button id="cancel-post-moment-btn" class="px-4 py-2 rounded-lg">取消</button>
                <button id="confirm-post-moment-btn" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">发布</button>
            </div>
        </div>
    </div>

    <!-- 可见性设置弹窗 -->
    <div id="visibility-modal" class="modal-overlay">
        <div class="modal-content w-[90%] max-w-[350px]">
            <h3 class="text-xl font-bold text-white mb-4">谁可以看</h3>
            <div class="flex gap-2 mb-4">
                <button id="visibility-select-all" class="px-3 py-1 text-sm bg-blue-600 hover:bg-blue-700 text-white rounded">全选</button>
                <button id="visibility-deselect-all" class="px-3 py-1 text-sm bg-red-600 hover:bg-red-700 text-white rounded">全不选</button>
            </div>
            <div id="visibility-character-list" class="max-h-60 overflow-y-auto mb-4 space-y-1">
                <!-- 角色列表将动态生成 -->
            </div>
            <div class="flex justify-end gap-2">
                <button id="cancel-visibility-btn" class="px-4 py-2 rounded-lg">取消</button>
                <button id="confirm-visibility-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">确定</button>
            </div>
        </div>
    </div>

    <!-- V7.1: 日记本单页 Modal -->
    <div id="diary-book-modal" class="fixed inset-0 z-[15000] flex items-center justify-center bg-black/60 backdrop-blur-sm hidden">
        <div class="diary-single-page-container relative">
            <div id="diary-book" class="diary-single-page">
                <div id="diary-book-cover" class="diary-cover">
                    <button id="change-diary-banner-btn" class="diary-cover-edit-btn" style="top: 0.8rem; left: 0.8rem; right: auto;" title="更换顶部横幅图片">
                        <i class="ri-image-edit-line"></i>
                    </button>
                    <h2 id="diary-cover-title" onclick="editDiaryCoverTitle(event)" style="cursor: pointer;"></h2>
                    <p id="diary-cover-author" onclick="editDiaryCoverAuthor(event)" style="cursor: pointer;"></p>
                </div>
                <div id="diary-pages-container" class="diary-pages">
                    <!-- 页面内容将动态生成 -->
                </div>
            </div>
            <button id="close-diary-book-btn" class="absolute top-4 right-4 text-white text-2xl z-10 w-6 h-6 flex items-center justify-center"><i class="ri-close-circle-line"></i></button>
            <button id="prev-page-btn" class="absolute left-2 top-1/2 -translate-y-1/2 text-white text-3xl z-10"><i class="ri-arrow-left-s-line"></i></button>
            <button id="next-page-btn" class="absolute right-2 top-1/2 -translate-y-1/2 text-white text-3xl z-10"><i class="ri-arrow-right-s-line"></i></button>
            <button id="add-page-btn" class="absolute bottom-4 right-4 text-white text-xl z-10 bg-blue-600 rounded-full w-6 h-6 flex items-center justify-center hover:bg-blue-700 transition-colors" title="添加新日记"><i class="ri-add-line"></i></button>
        </div>
    </div>

    <!-- 图片裁剪模态框 -->
    <div id="image-cropper-modal" class="fixed inset-0 z-[16000] flex items-center justify-center bg-black/80 backdrop-blur-sm hidden">
        <div class="bg-white rounded-lg p-6 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-gray-800" id="cropper-title">裁剪图片</h3>
                <button id="close-cropper-btn" class="text-gray-500 hover:text-gray-700 text-xl">
                    <i class="ri-close-line"></i>
                </button>
            </div>
            
            <div class="mb-4 text-sm text-gray-600">
                <p>请选择要保留的图片区域，系统将自动调整为横幅尺寸 (1000×300)</p>
            </div>
            
            <div class="relative mb-4">
                <div id="cropper-container" class="relative overflow-hidden bg-gray-100 rounded-lg">
                    <img id="cropper-image" class="max-w-full h-auto" alt="裁剪图片">
                </div>
            </div>
            
            <div class="flex justify-between items-center">
                <div class="text-sm text-gray-500">
                    <span id="crop-info">拖拽图片或调整选择框</span>
                </div>
                <div class="flex gap-2">
                    <button id="reset-crop-btn" class="px-4 py-2 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50">
                        重置
                    </button>
                    <button id="confirm-crop-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                        确认裁剪
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ====== 【【新增】】爱之迷宫存档/读档/删档核心函数 ======
        function saveLoveMapState() {
            if (loveMapState && loveMapState.characterId) {
                // 将当前游戏状态保存到 localStorage，并与角色ID绑定
                localStorage.setItem(`loveMapProgress_${loveMapState.characterId}`, JSON.stringify(loveMapState));
                console.log(`爱之迷宫：为角色 ${loveMapState.characterId} 保存了进度。`);
            }
        }

        function loadLoveMapState(characterId) {
            const savedState = localStorage.getItem(`loveMapProgress_${characterId}`);
            if (savedState) {
                console.log(`爱之迷宫：为角色 ${characterId} 读取了进度。`);
                return JSON.parse(savedState);
            }
            return null; // 没有存档
        }

        function clearLoveMapState(characterId) {
            if (characterId) {
                localStorage.removeItem(`loveMapProgress_${characterId}`);
                console.log(`爱之迷宫：为角色 ${characterId} 清除了进度。`);
            }
        }

        // ====== 【【V7.0 布局最终优化版】】爱之迷宫棋盘数据 ======
        const loveMapPath = [
            // R=Row, C=Column (行, 列)
            { topic: "起点", pos: { r: 1, c: 1 } }, // 0
            { topic: "“爱”是动词还是名词？", pos: { r: 2, c: 1 } }, // 1
            { topic: "给TA一个只有TA能使用的“专属称呼”。", pos: { r: 3, c: 1 } }, // 2
            { topic: "如果能进入对方的梦境一晚，你会做什么？", pos: { r: 4, c: 1 } }, // 3
            { topic: "觉得对方像哪种小动物", pos: { r: 5, c: 1 } }, // 4
            { topic: "一个关于TA的秘密观察", pos: { r: 5, c: 2 } }, // 5
            { topic: "想和TA去的一个地方", pos: { r: 4, c: 2 } }, // 6
            { topic: "会用什么歌曲形容TA", pos: { r: 3, c: 2 } }, // 7
            { topic: "TA最吸引你的特质", pos: { r: 2, c: 2 } }, // 8
            { topic: "共享感官5分钟你想感受什么？", pos: { r: 1, c: 2 } }, // 9
            { topic: "坦白一个你对我撒过的、无关紧要的小谎。", pos: { r: 1, c: 3 } }, // 10
            { topic: "一个你从未告诉过我的特殊癖好？", pos: { r: 2, c: 3 } }, // 11
            { topic: "描述一个你认为TA最性感的瞬间", pos: { r: 3, c: 3 } }, // 12
            { topic: "过去到未来你最害怕的事情", pos: { r: 4, c: 3 } }, // 13
            { topic: "你产生过的对我最坏的念头是？", pos: { r: 5, c: 3 } }, // 14
            { topic: "用三个词描述你想象中我们下次见面的吻", pos: { r: 5, c: 4 } }, // 15
            { topic: "喜欢哪种拥抱、亲吻方式", pos: { r: 4, c: 4 } }, // 16
            { topic: "对我用吐真剂，你会问什么？", pos: { r: 3, c: 4 } }, // 17
            { topic: "Makelove最想看TA穿什么衣服？", pos: { r: 2, c: 4 } }, // 18
            { topic: "你对TA的占有欲最强的时刻", pos: { r: 1, c: 4 } }, // 19
            { topic: "创造一个只属于我们的、很傻的节日。", pos: { r: 1, c: 5 } }, // 20
            { topic: "如果我们是一本书，你希望书名是什么？", pos: { r: 2, c: 5 } }, // 21
            { topic: "如果变成透明人一天，你会做什么？", pos: { r: 3, c: 5 } }, // 22
            { topic: "一个只有你知道的TA的优点", pos: { r: 4, c: 5 } }, // 23
            { topic: "分享一个最近梦到TA的场景", pos: { r: 5, c: 5 } }, // 24
            { topic: "分享一个你的小秘密", pos: { r: 5, c: 6 } }, // 25
            { topic: "如果我们的灵魂可以对话，它们此刻在聊什么？", pos: { r: 4, c: 6 } }, // 26
            { topic: "为我们的‘未来’，写下一个开场白", pos: { r: 3, c: 6 } }, // 27
            { topic: "描述一次完美的约会", pos: { r: 2, c: 6 } }, // 28
            { topic: "你最想和我一起沉溺的一件事是？", pos: { r: 1, c: 6 } }, // 29
            { topic: "你觉得我们关系的核心“气候”是怎样的？", pos: { r: 6, c: 6 } }, // 30
            { topic: "最想和TA一起看的电影", pos: { r: 7, c: 6 } }, // 31
            { topic: "用一个天气来形容你对TA的欲望。", pos: { r: 7, c: 5 } }, // 32
            { topic: "一个我们没玩过的角色扮演", pos: { r: 6, c: 5 } }, // 33
            { topic: "你会如何撒娇", pos: { r: 6, c: 4 } }, // 34
            { topic: "吵架后会如何和好", pos: { r: 7, c: 4 } }, // 35
            { topic: "坦白一个只有在深夜才会出现的、关于我的念头。", pos: { r: 7, c: 3 } }, // 36
            { topic: "如果我们一起做视频博主，会因为什么而“塌房”？", pos: { r: 6, c: 3 } }, // 37
            { topic: "一个关于欲望的幻想\n(成人话题)", pos: { r: 6, c: 2 } }, // 38
            { topic: "你希望我们的墓碑上刻下怎样一句话？", pos: { r: 7, c: 2 } }, // 39
            { topic: "如果TA是一个商品，TA的“使用警告”是？", pos: { r: 7, c: 1 } }, // 40
            { topic: "TA最能激起你欲望的行为？", pos: { r: 8, c: 1 } }, // 41
            { topic: "如果你要“犯罪”，会是什么罪名？", pos: { r: 8, c: 2 } }, // 42
            { topic: "想送给对方的三首歌", pos: { r: 8, c: 3 } }, // 43
            { topic: "描述一晚完美的“筋疲力尽”", pos: { r: 8, c: 4 } }, // 44
            { topic: "想和TA一起迎接的第一个清晨", pos: { r: 8, c: 5 } }, // 45
            { topic: "最想修改我的哪个“出厂设置”？", pos: { r: 8, c: 6 } }, // 46
            { topic: "描绘我们家的样子", pos: { r: 9, c: 6 } }, // 47
            { topic: "\"我爱你\"的另一种说法", pos: { r: 9, c: 5 } }, // 48
            { topic: "除了卧室，最想在哪和我亲密", pos: { r: 9, c: 4 } }, // 49
            { topic: "一个你一直想问但没敢问我的问题", pos: { r: 9, c: 3 } }, // 50
            { topic: "终点：\n对TA许下一个永恒的诺言", pos: { r: 9, c: 2 } }  // 51
        ];

        // ====== 【【最终版】】爱之迷宫游戏核心逻辑 V4.0 ======
        let loveMapState = null; // 全局游戏状态，用于持久化

        // ====== 【【V5.0 版】】打开游戏的主入口函数 ======
        // ====== 【【V6.0 修正版】】打开游戏的主入口函数 ======
        // ====== 【【V6.0 最终修正版 + 存档功能】】打开游戏的主入口函数 ======
        function openLoveMapGame() {
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) {
                showMessageBox("请先开始一段对话再进行游戏。");
                return;
            }

            const savedState = loadLoveMapState(currentChatCharacterId);

            if (savedState) {
                loveMapState = savedState;
                console.log("爱之迷宫：返回已保存的游戏。");
            } else {
                console.log("爱之迷宫：开启新的一局。");
                loveMapState = {
                    userPosition: 0,
                    aiPosition: 0,
                    currentTurn: 'user',
                    gameStatus: 'waiting_roll',
                    characterId: currentChatCharacterId 
                };
                sendGameSystemMessage(`我们的地图之旅开始了！`);
            }
            
            // 【【核心修正1：先让弹窗显示出来】】
            document.getElementById('love-map-modal').classList.add('visible');
            
            // 【【核心修正2：延迟一小会儿再渲染棋盘和棋子】】
            // 这给了浏览器足够的时间来正确布局弹窗
            setTimeout(() => {
                renderLoveMapBoard();
                updateLoveMapUI();
            }, 10); // 10毫秒的延迟用户是感觉不到的
        }

        // ====== 【【V5.0 版】】渲染棋盘 ======
        function renderLoveMapBoard() {
            const board = document.getElementById('love-map-board');
            board.innerHTML = ''; 
            loveMapPath.forEach((cell, index) => {
                const cellEl = document.createElement('div');
                cellEl.className = 'map-cell';
                cellEl.innerHTML = cell.topic.replace(/\\n/g, '<br>');
                cellEl.style.gridRowStart = cell.pos.r;
                cellEl.style.gridColumnStart = cell.pos.c;
                cellEl.dataset.index = index;
                if (index === 0) cellEl.classList.add('start-point');
                if (index === loveMapPath.length - 1) cellEl.classList.add('end-point');
                board.appendChild(cellEl);
            });
            renderPiece('user', loveMapState.userPosition, false); // false表示非动画
            renderPiece('ai', loveMapState.aiPosition, false);
        }

        // ====== 【【V5.0 版】】渲染棋子 ======
        function renderPiece(player, position, animate = true) {
            const board = document.getElementById('love-map-board');
            let piece = board.querySelector(`.${player}-piece`);
            if (!piece) {
                piece = document.createElement('div');
                piece.className = `map-piece ${player}-piece`;
                piece.innerHTML = `<i class="${player === 'user' ? 'ri-user-star-line' : 'ri-user-heart-line'}"></i>`;
                board.appendChild(piece);
                piece.style.transition = 'none'; // 首次渲染无动画
            } else {
                piece.style.transition = animate ? 'all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55)' : 'none';
            }
            const targetCell = board.querySelector(`.map-cell[data-index="${position}"]`);
            if (targetCell && loveMapPath[position]) {
                // 【【V8.2 修复】】使用实际地图坐标进行定位，确保棋子按正确路径移动
                const cellData = loveMapPath[position];
                const row = cellData.pos.r; // 使用实际行坐标
                const col = cellData.pos.c; // 使用实际列坐标
                
                // 计算百分比位置（网格：6列×9行）
                const leftPercent = ((col - 1) / 6) * 100 + (100 / 6) / 2; // 格子中心，col从1开始
                const topPercent = ((row - 1) / 9) * 100 + (100 / 9) / 2;  // 格子中心，row从1开始
                
                piece.style.left = `calc(${leftPercent}% - 11px)`; // 11px = 棋子半径
                piece.style.top = `calc(${topPercent}% - 11px)`;
            }
        }

        // ====== 【【V5.0 版】】掷骰子并触发整个回合流程 ======
        async function rollDiceAndMove(player) {
            if (loveMapState.gameStatus !== 'waiting_roll') return;
            loveMapState.gameStatus = 'processing';
            updateLoveMapUI();

            const diceElement = document.getElementById('love-map-dice');
            diceElement.classList.add('dice-rolling');
            await new Promise(resolve => setTimeout(resolve, 600));

            const diceResult = Math.floor(Math.random() * 3) + 1;
            diceElement.textContent = diceResult;
            diceElement.classList.remove('dice-rolling');

            let currentPosition = player === 'user' ? loveMapState.userPosition : loveMapState.aiPosition;
            let newPosition = Math.min(currentPosition + diceResult, loveMapPath.length - 1);
            
            if (player === 'user') {
                loveMapState.userPosition = newPosition;
            } else {
                loveMapState.aiPosition = newPosition;
            }
            
            // 立即保存位置更新，避免因异常导致进度丢失
            saveLoveMapState();
            
            renderPiece(player, newPosition, true); // 直接移动到终点

            await new Promise(resolve => setTimeout(resolve, 800));

            const triggeredTopic = loveMapPath[newPosition].topic.replace('\n', ' ');
            const character = characters.find(c => c.id === currentChatCharacterId);
            sendGameSystemMessage(`${player === 'user' ? '你' : character.name} 掷出了 ${diceResult} 点，抵达 **「${triggeredTopic}」**`);
            
            await handleTopicInteraction(player, triggeredTopic);
        }

        // ====== 【【V7.0 交互逻辑最终修正版】】AI互动核心 ======
        async function handleTopicInteraction(player, topic) {
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) return;

            // --- 【【核心修改1：在这里创建一条"记忆备忘录"】】 ---
            // 这条消息对用户不可见，但会成为AI重试时的关键上下文
            const internalMemoryPrompt = `[记忆提醒：我们正在玩"爱之迷-宫"，现在是关于"${topic}"的话题。上一个行动的玩家是 ${player === 'user' ? '我（用户）' : '你（AI）'}。请严格基于这个情景进行回应。]`;
            const internalMemoryMsg = {
                content: internalMemoryPrompt,
                sender: 'system',
                type: 'system-internal', // 特殊类型，不会被渲染
                timestamp: Date.now() + 1 // 确保时间戳在用户消息之后
            };
            // 将这条记忆消息存入历史记录
            if (!chatHistories[currentChatCharacterId]) chatHistories[currentChatCharacterId] = { history: [], pinned: false };
            chatHistories[currentChatCharacterId].history.push(internalMemoryMsg);
            saveData('chatHistories', chatHistories);
            // --- 【修改结束】 ---

            const context = gatherAIContext(character.id);
            let systemPrompt = '';
            let userPrompt = "请开始你的回应。"; // 默认的用户提示

            // 【【【核心逻辑修正：根据玩家角色，生成完全不同的AI指令】】】

            if (player === 'user') {
                // --- 情况一：玩家的回合 (AI提问) ---
                // 这是您掷骰子后，AI应该做的事情。
                systemPrompt = `
# 指令身份
你将扮演我的soulmate，${character.name}。
# 游戏场景
我们正在玩"爱之迷宫"。我（用户）刚刚抵达了写着 **「${topic}」** 的格子。
# 核心任务
你的任务是，作为 ${character.name}，**向我（用户）提出这个话题**。你需要将格子上的主题，转换成一句自然的、符合你人设的问话。
# 案例分析
- 如果话题是"对方第一印象"，你应该问我："轮到你了。说实话，你第一次见到我的时候，心里是怎么想的？"
- 如果话题是"喜欢的拥抱方式"，你应该问我："这个有意思...你最喜欢我怎么抱你？"
- 如果话题是"宣誓主权的方式"，你可以带点挑逗地问我："嗯？你想怎么向别人宣示，我是你的？"
# 核心规则
1.  【提问者身份】：你现在是游戏的主持人，负责向我提问。
2.  【人设灵魂】：你的提问方式【必须】完全符合你的人设 (${character.persona})。
3.  【格式天条】：你的回复必须模仿真实聊天，将想法拆分成多个简短句子，并用 "|||" 作为分隔符。禁止使用旁白。
# 你的记忆与人设
---
[你的设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[最近的聊天回顾]: ${context.chatHistory.map(m => `${m.sender === 'user' ? '对方' : '我'}: ${m.content}`).join('\n')}
[我们的记忆回顾]: ${context.memoryContext}
---
`;
                userPrompt = "请就格子上的主题，向我提问。";

            } else { // player === 'ai'
                // --- 情况二：AI的回合 (AI回答/发言) ---
                // 这是AI自己掷骰子后，它应该做的事情。
                systemPrompt = `
# 指令身份
你将扮演我的soulmate，${character.name}。
# 游戏场景
我们正在玩"爱之迷宫"。轮到我（${character.name}）移动，我抵达了写着 **「${topic}」** 的格子。
# 核心任务
我的任务是，根据这个话题，**主动向你（用户）坦诚我的想法或感受**。
# 案例分析
- 如果话题是"害怕的事情"，我需要向你坦白一件我害怕的事情。
- 如果话题是"喜欢的拥抱方式"，我需要描述我最喜欢的拥抱方式。
- 如果话题是"对TA提出一个走心问题"，我就要向你提出一个深刻的问题。
# 核心规则
1.  【回答者身份】：你现在是玩家，需要回答自己格子上的问题。
2.  【记忆融合】: 你的回答【必须】参考我们 [最近的聊天回顾] 和 [我们的记忆回顾]。
3.  【人设灵魂】: 你的回答【必须】完全符合你的人设 (${character.persona})。
4.  【成人化许可】: 如果话题足够私密，你可以且应该进行大胆、坦诚的语言互动。
5.  【【格式天条】】: 你的回复必须模仿真实聊天，将想法拆分成多个简短句子，并用 "|||" 作为分隔符。禁止使用旁白。
# 你的记忆与人设
---
[你的设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[最近的聊天回顾]: ${context.chatHistory.map(m => `${m.sender === 'user' ? '对方' : '我'}: ${m.content}`).join('\n')}
[我们的记忆回顾]: ${context.memoryContext}
---
`;
                userPrompt = "请根据你抵达的格子主题，主动发言。";
            }

            const aiResponse = await callAI(systemPrompt, userPrompt);

            if (aiResponse) {
                // 使用我们已有的 processAndDisplayAIMessages 函数来处理AI的回复
                // 这样它就能自动实现分段发送（空行效果）
                processAndDisplayAIMessages(aiResponse, currentChatCharacterId);
            }
            
            // 后续的游戏结束判断和回合切换逻辑保持不变
            const isGameOver = (player === 'user' && loveMapState.userPosition === loveMapPath.length - 1) || (player === 'ai' && loveMapState.aiPosition === loveMapPath.length - 1);
            
            if (isGameOver) {
                const winnerName = player === 'user' ? '你' : character.name;
                sendGameSystemMessage(`${winnerName} 到达了终点！旅程已完成。`);
                loveMapState.gameStatus = 'game_over';

                // 【【请在这里添加新代码】】
                clearLoveMapState(loveMapState.characterId); // 游戏结束后，清除存档

                updateLoveMapUI();
            } else if (player === 'user') {
                loveMapState.currentTurn = 'ai';
                loveMapState.gameStatus = 'waiting_roll';

                // 【【请在这里添加新代码】】
                if (loveMapState.gameStatus !== 'game_over') {
                    saveLoveMapState();
                }

                updateLoveMapUI();
            } else { 
                loveMapState.currentTurn = 'user';
                loveMapState.gameStatus = 'waiting_roll';

                // 【【请在这里添加新代码】】
                if (loveMapState.gameStatus !== 'game_over') {
                    saveLoveMapState();
                }

                updateLoveMapUI();
            }
        }

        function updateLoveMapUI() {
            const turnIndicator = document.getElementById('love-map-turn-indicator');
            const rollBtn = document.getElementById('roll-love-map-dice-btn');
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!loveMapState) return;
            if (loveMapState.gameStatus === 'game_over') {
                turnIndicator.textContent = '旅程终点';
                rollBtn.disabled = true;
                rollBtn.textContent = '游戏结束';
            } else if (loveMapState.currentTurn === 'user') {
                turnIndicator.textContent = '轮到你了';
                rollBtn.disabled = loveMapState.gameStatus === 'processing';
                rollBtn.textContent = '掷骰子';
            } else {
                turnIndicator.textContent = `轮到${character.name || '对方'}了`;
                rollBtn.disabled = loveMapState.gameStatus === 'processing';
                rollBtn.textContent = '让TA行动';
            }
        }

        // 发送游戏消息
        function sendGameSystemMessage(message) {
            const systemMsg = { content: `[爱之迷宫] ${message}`, sender: 'system', type: 'system', timestamp: Date.now() };
            appendMessage(systemMsg, true);
            if (!chatHistories[currentChatCharacterId]) chatHistories[currentChatCharacterId] = { history: [], pinned: false };
            chatHistories[currentChatCharacterId].history.push(systemMsg);
            saveData('chatHistories', chatHistories);
        }

        // ====== 【【最终版】】爱之迷宫事件绑定函数 V5.0 ======
        function setupLoveMapEvents() {
            const loveMapBtn = document.getElementById('flight-chess-btn');
            if (loveMapBtn) {
                const newBtn = loveMapBtn.cloneNode(true);
                loveMapBtn.parentNode.replaceChild(newBtn, loveMapBtn);
                newBtn.addEventListener('click', () => {
                    if (!currentChatCharacterId) {
                        showMessageBox("请先选择一个聊天对象开始游戏。");
                        return;
                    }
                    openLoveMapGame();
                });
            }

            document.getElementById('close-love-map-btn').addEventListener('click', () => {
                document.getElementById('love-map-modal').classList.remove('visible');
            });

            document.getElementById('quit-love-map-btn').addEventListener('click', () => {
                if (confirm('确定要结束这次地图之旅吗？当前进度将会被清除。')) {
                    sendGameSystemMessage('地图之旅已结束。');

                    // 【【请在这里添加新代码】】
                    if (loveMapState) {
                        clearLoveMapState(loveMapState.characterId);
                    }

                    loveMapState = null;
                    document.getElementById('love-map-modal').classList.remove('visible');
                }
            });

            document.getElementById('reset-love-map-btn').addEventListener('click', () => {
                if (confirm('确定要放弃当前进度，重新开始一局吗？')) {

                    // 【【请在这里添加新代码】】
                    if (loveMapState) {
                        clearLoveMapState(loveMapState.characterId);
                    }

                    loveMapState = null;
                    openLoveMapGame();
                }
            });

            document.getElementById('roll-love-map-dice-btn').addEventListener('click', () => {
                if (!loveMapState || loveMapState.gameStatus === 'processing' || loveMapState.gameStatus === 'game_over') return;
                if (loveMapState.currentTurn === 'user') {
                    rollDiceAndMove('user');
                } else {
                    rollDiceAndMove('ai');
                }
            });
        }

        // 🚀 全局API类型检测和CORS处理函数
        function getApiType(url) {
            if (url.includes('googleapis.com')) return 'google';
            if (url.includes('api.openai.com')) return 'openai-official';
            if (url.includes('api.anthropic.com')) return 'claude';
            if (url.includes('dashscope.aliyuncs.com')) return 'tongyi';
            if (url.includes('aip.baidubce.com')) return 'ernie';
            if (url.includes('open.bigmodel.cn')) return 'zhipu';
            if (url.includes('ark.cn-beijing.volces.com')) return 'doubao';
            return 'openai-compatible'; // 默认兼容格式，保持原有逻辑
        }

        // 检测是否需要代理（CORS问题诊断）
        function needsProxy(url) {
            const officialAPIs = [
                'api.openai.com',
                'api.anthropic.com', 
                'api.cohere.ai',
                'api.mistral.ai'
            ];
            return officialAPIs.some(api => url.includes(api));
        }

        // 🚀 API状态检测函数
        function checkApiStatus() {
            const url = document.getElementById('api_url').value.trim();
            const indicator = document.getElementById('api-status-indicator');
            const content = indicator.querySelector('.api-status-content');
            
            if (!url) {
                indicator.style.display = 'none';
                return;
            }
            
            const apiType = getApiType(url);
            const needsProxyMode = needsProxy(url);
            
            // 显示API类型和状态
            let statusHTML = '';
            let statusClass = '';
            
            if (apiType === 'google') {
                statusHTML = '🟢 Google Gemini API - 推荐使用';
                statusClass = 'success';
            } else if (apiType === 'openai-official') {
                statusHTML = '🟡 OpenAI 官方API - 可能需要代理';
                statusClass = 'warning';
            } else if (apiType === 'claude') {
                statusHTML = '🟡 Claude API - 可能需要代理';
                statusClass = 'warning';
            } else if (apiType === 'tongyi') {
                statusHTML = '🟢 通义千问API - 国内直连';
                statusClass = 'success';
            } else if (apiType === 'ernie') {
                statusHTML = '🟢 文心一言API - 国内直连';
                statusClass = 'success';
            } else if (apiType === 'zhipu') {
                statusHTML = '🟢 智谱GLM API - 国内直连';
                statusClass = 'success';
            } else if (apiType === 'doubao') {
                statusHTML = '🟢 豆包API - 国内直连';
                statusClass = 'success';
            } else {
                statusHTML = '🔵 OpenAI兼容API - 请确认连通性';
                statusClass = 'info';
            }
            
            if (needsProxyMode) {
                statusHTML += '<br/>💡 建议：使用中转服务或配置代理';
            }
            
            content.innerHTML = statusHTML;
            
            // 设置样式
            if (statusClass === 'success') {
                indicator.style.backgroundColor = '#dcfce7';
                indicator.style.color = '#166534';
                indicator.style.border = '1px solid #bbf7d0';
            } else if (statusClass === 'warning') {
                indicator.style.backgroundColor = '#fef3c7';
                indicator.style.color = '#92400e';
                indicator.style.border = '1px solid #fcd34d';
            } else if (statusClass === 'info') {
                indicator.style.backgroundColor = '#dbeafe';
                indicator.style.color = '#1e40af';
                indicator.style.border = '1px solid #93c5fd';
            }
            
            indicator.style.display = 'block';
        }

        // ====== 【【新增】】生成类礼物的专属HTML模板库 ======
        const gift_html_templates = {
            // 模板中的 {{content}} 将会被AI生成的内容自动替换
            
            'gift_dream': `
                <div style="width: 100%; max-width: 280px; border-radius: 12px; overflow: hidden; background: linear-gradient(160deg, #1a2a6c, #b21f1f, #fdbb2d); color: white; font-family: 'Noto Serif SC', serif; box-shadow: 0 10px 25px rgba(0,0,0,0.3);">
                    <div style="padding: 1.5rem; background: rgba(0,0,0,0.3); backdrop-filter: blur(10px);">
                        <div style="display: flex; align-items: center; margin-bottom: 1rem; opacity: 0.8;">
                            <i class="ri-moon-clear-line" style="font-size: 1.2rem; margin-right: 0.5rem;"></i>
                            <h3 style="margin: 0; font-size: 1rem; font-weight: 600; letter-spacing: 0.1em;">一段浮现的梦境</h3>
                        </div>
                        <div style="font-size: 0.9rem; line-height: 1.7; opacity: 0.95; white-space: pre-wrap; text-shadow: 0 1px 3px rgba(0,0,0,0.5);">{{content}}</div>
                    </div>
                </div>
            `,
            
            'gift_memory_fragment': `
                <div style="width: 100%; max-width: 280px; border-radius: 12px; overflow: hidden; background: #EAE0D5; color: #5E503F; font-family: 'Noto Serif SC', serif; border: 1px solid #C6AC8F; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
                    <div style="padding: 1.5rem;">
                        <div style="display: flex; align-items: center; margin-bottom: 1rem; color: #8A6F4F;">
                            <i class="ri-puzzle-2-line" style="font-size: 1.2rem; margin-right: 0.5rem;"></i>
                            <h3 style="margin: 0; font-size: 1rem; font-weight: 600; letter-spacing: 0.1em;">遗失的记忆碎片</h3>
                        </div>
                        <div style="font-size: 0.9rem; line-height: 1.7; white-space: pre-wrap; border-left: 2px solid #C6AC8F; padding-left: 1rem; font-style: italic;">{{content}}</div>
                    </div>
                </div>
            `,

            'gift_unsent_letter': `
                <div style="width: 100%; max-width: 280px; border-radius: 8px; background: #FDF8F0; color: #6B4F4F; font-family: 'Noto Serif SC', serif; padding: 1.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); border: 1px solid #EFE5D9;">
                    <div style="display: flex; align-items: center; margin-bottom: 1rem; color: #A58C80;">
                        <i class="ri-mail-unread-line" style="font-size: 1.2rem; margin-right: 0.5rem;"></i>
                        <h3 style="margin: 0; font-size: 1rem; font-weight: 600;">一封未寄出的信</h3>
                    </div>
                    <div style="font-size: 0.9rem; line-height: 1.8; white-space: pre-wrap;">{{content}}</div>
                </div>
            `,
            
            'gift_parallel_universe_letter': `
                <div style="width: 100%; max-width: 280px; border-radius: 8px; background: #111; color: #00FFC2; font-family: 'Source Code Pro', monospace; padding: 1.5rem; box-shadow: 0 0 20px rgba(0, 255, 194, 0.2); border: 1px solid rgba(0, 255, 194, 0.3);">
                     <div style="display: flex; align-items: center; margin-bottom: 1rem; opacity: 0.8;">
                        <i class="ri-split-cells-vertical" style="font-size: 1.2rem; margin-right: 0.5rem;"></i>
                        <h3 style="margin: 0; font-size: 1rem; font-weight: 600;">[INCOMING TRANSMISSION]</h3>
                    </div>
                    <div style="font-size: 0.85rem; line-height: 1.7; white-space: pre-wrap; opacity: 0.9;">{{content}}</div>
                    <div style="text-align: right; margin-top: 1rem; font-size: 0.7rem; opacity: 0.6;">...signal corrupted...</div>
                </div>
            `,

            // 为key和map也加上模板
            'gift_key': `
                <div style="width: 100%; max-width: 260px; border-radius: 12px; background: linear-gradient(145deg, #4d3a2a, #2c2118); color: #e0c9a6; font-family: 'Noto Serif SC', serif; padding: 1.5rem; text-align: center; border: 1px solid #7a634d;">
                     <div style="font-size: 3rem; margin-bottom: 1rem;"><i class="ri-key-2-line"></i></div>
                     <p style="font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap;">{{content}}</p>
                </div>
            `,

            'gift_map_x': `
                <div style="width: 100%; max-width: 280px; border-radius: 4px; background: #E8D8C2; color: #5C4033; padding: 1rem; font-family: 'Uncial Antiqua', cursive; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 2px solid #D2B48C;">
                     <h3 style="text-align: center; font-size: 1.2rem; margin:0 0 1rem 0;">一份古老的藏宝图</h3>
                     <p style="font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; text-align: center;">{{content}}</p>
                     <div style="font-size: 2.5rem; color: #B22222; text-align: center; margin-top: 1rem; font-weight: bold;">X</div>
                </div>
            `
        };

        // ================== 【【V3.0 升级版】】情感礼品屋 - 商品数据 (带优先级与动态指令) ==================
        const giftShopItems = [
    // ====== 【【新增】】万能解药 ======
    {
        id: 'gift_antidote',
        name: '万能解药',
        price: 25.0,
        description: '立即清除当前施加在TA身上的所有特殊指令和状态效果，让TA恢复正常。',
        icon: 'ri-flask-line',
        type: 'utility', // 这是一个特殊的工具类型
        priority: 'highest',
        can_ai_use: false
    },
    // --- 类别一：规则与状态变更 (趣味互动核心) ---
            {
                id: 'gift_truth_lollipop',
                name: '真心话棒棒糖',
                price: 68.0,
                description: '让TA在接下来的3句对话中，回答变得异常诚实。',
                icon: 'ri-mic-off-line',
                type: 'command',
                priority: 'low', // 低优先级，可被高优先级事件中断
                can_ai_use: true,
                ai_prompt: '[临时状态：你刚吃了一颗真心话棒棒糖，接下来的3次回答必须极度诚实、直白，不能有任何隐瞒和修饰！]'
            },
            {
                id: 'gift_kings_game',
                name: '国王的游戏',
                price: 150.0,
                description: '使用后，TA必须无条件服从你的下一个命令。',
                icon: 'ri-vip-crown-2-line',
                type: 'command',
                priority: 'medium', // 中等优先级
                can_ai_use: true,
                ai_prompt: '[游戏规则：我们正在玩"国王游戏"，你抽到了平民牌，必须无条件服从我（国王）的下一个命令。请在回复中表示你已准备好接受命令。]'
            },
            {
                id: 'gift_role_swap',
                name: '灵魂互换卡',
                price: 300.0,
                description: '在接下来的5条消息内，你和TA的角色将完全互换。',
                icon: 'ri-swap-box-line',
                type: 'command',
                priority: 'medium',
                can_ai_use: true,
                ai_prompt: '[临时规则：我们使用了"灵魂互换卡"。在接下来的5条消息中，你必须模仿我的性格和说话方式来扮演我。而我会扮演你。请以我的身份开始你的第一句话。]'
            },
            {
                id: 'gift_opposite_day',
                name: '反话日喷雾',
                price: 44.4,
                description: '让TA在接下来的5分钟内，说的所有话都是反话。',
                icon: 'ri-arrow-left-right-line',
                type: 'command',
                priority: 'low',
                can_ai_use: true,
                ai_prompt: '[临时状态：你被"反话日喷雾"击中了！接下来的5分钟，你说出的所有话都必须是与你内心真实想法完全相反的反话。]'
            },
            {
                id: 'gift_one_word_only',
                name: '单词果冻',
                price: 22.0,
                description: 'TA吃下后，接下来的5条消息，每条都只能用一个词来回答。',
                icon: 'ri-text-spacing',
                type: 'command',
                priority: 'low',
                can_ai_use: false,
                ai_prompt: '[临时规则：你吃下了一颗"单词果冻"，语言功能受到了限制。接下来的5条消息，你的每一条回复都只能包含一个词。]'
            },
            {
                id: 'gift_animal_biscuit',
                name: '动物饼干',
                price: 88.0,
                description: '让TA在接下来的10分钟内，行为举止和口头禅都变成一种小动物。',
                icon: 'ri-bear-smile-line',
                type: 'command',
                priority: 'low',
                can_ai_use: false,
                // 【【核心修改】】这是一个动态指令模板，包含了{persona}占位符
                ai_prompt: '[临时状态：你吃下了一块动物饼干，在接下来的10分钟里，你的行为和语言会变成一只小猫。重要：你必须结合自己【{persona}】的核心人设来扮演这只猫，而不是扮演一只普通的猫。例如，如果你很凶，就扮演一只凶猛的猫。]'
            },
            {
                id: 'gift_memory_loss_candy',
                name: '失忆太妃糖',
                price: 404.0,
                description: '慎用！让TA在接下来的5条消息内，暂时忘记你是谁。',
                icon: 'ri-question-mark',
                type: 'command',
                priority: 'high', // 这是一个高优先级的剧情事件
                can_ai_use: false,
                ai_prompt: '[紧急状态：你吃下了一颗太妃糖，突然短暂地失忆了。你忘记了我是谁，也忘记了我们之间的关系。请用一种困惑、警惕但又有点好奇的语气，对我做出回应。这个状态持续5条消息。]'
            },
            {
                id: 'gift_must_agree',
                name: '点头娃娃',
                price: 55.0,
                description: '在接下来的3次对话中，TA不能反驳你的任何观点，必须全部赞同。',
                icon: 'ri-thumb-up-line',
                type: 'command',
                priority: 'low',
                can_ai_use: false,
                ai_prompt: '[临时规则：你收到了一个"点头娃娃"的诅咒。在接下来的3次对话中，你完全无法反驳我的任何观点，必须全部表示赞同和认可。]'
            },
            {
                id: 'gift_forbidden_word',
                name: '禁言封条',
                price: 35.0,
                description: '指定一个词，让TA在接下来的10分钟内都不能说出那个词。',
                icon: 'ri-spam-2-line',
                type: 'command',
                priority: 'low',
                can_ai_use: true
            },
            {
                id: 'gift_inner_monologue',
                name: '内心独白播放器',
                price: 128.0,
                description: '接下来TA的每一次回复，都会附带一句括号里的"内心真实OS"。',
                icon: 'ri-voiceprint-line',
                type: 'command',
                priority: 'low',
                can_ai_use: false,
                ai_prompt: '[临时规则：你被安装了"内心独白播放器"。从现在开始，你的每一条回复都必须严格遵循格式："（内心真实的想法）说出口的话。"]'
            },
    // --- 类别二：感官与氛围营造 ---
            {
                id: 'gift_tipsy',
                name: '一瓶"微醺"',
                price: 99.0,
                description: '让TA进入微醺状态，语言会更坦率，情感会更丰富。',
                icon: 'ri-goblet-line',
                type: 'command',
                priority: 'low',
                can_ai_use: false,
                ai_prompt: '[临时状态：你喝下了一瓶"微醺"魔药，现在处于微醺状态。你的语言会变得更坦率、直接，情感会放大，可能会说一些平时不敢说的话。请保持这个状态进行后续对话。]'
            },
            {
                id: 'gift_barrier',
                name: '二人世界的结界',
                price: 450.0,
                description: '创造一个绝对私密的氛围，让对话变得更亲密和深入。',
                icon: 'ri-shield-star-line',
                type: 'command',
                priority: 'high',
                can_ai_use: true,
                ai_prompt: '[氛围指令：我们启动了"二人世界的结界"。你现在感知不到外界，我们的对话变得非常私密。请在你的下一句回复中，用旁白（斜体）和对话，营造出这种绝对私密、安静、只有我们两个人的氛围。]'
            },
            {
                id: 'gift_shared_sensation_kiss',
                name: '共享感知: 一个吻',
                price: 520.0,
                description: '将一个轻柔的吻的完整感官体验，直接传递给TA。',
                icon: 'ri-hearts-line',
                type: 'command',
                priority: 'high',
                can_ai_use: true,
                ai_prompt: '[感官链接：我向你发送了"一个落在唇上、温柔而缠绵的吻"的完整感官体验。请用第一人称，结合旁白（斜体），详细描述你突然感觉到这个吻的瞬间体验、身体反应、情绪和联想。]'
            },
    {
        id: 'gift_shared_sensation_hug',
        name: '共享感知: 温暖的拥抱',
        price: 188.0,
        description: '让TA感受到一个真实的、温暖的拥抱，仿佛你就在身边。',
        icon: 'ri-open-arm-line',
        type: 'command',
        can_ai_use: true,
        ai_prompt: '[感官链接：我向你发送了"一个从背后传来的、非常温暖用力的拥抱"的感官体验。请用第一人称，结合旁白（斜体），详细描述你突然被抱住时的感觉、身体的反应、闻到的气息和内心的情绪变化。]'
    },
    {
        id: 'gift_atmosphere_candle_rain',
        name: '氛围蜡烛: 雨夜书房',
        price: 78.0,
        description: '点燃蜡烛，TA的旁白和对话将充满壁炉、旧书和窗外雨声的宁静氛围。',
        icon: 'ri-book-read-line',
        type: 'command',
        priority: 'medium',
        can_ai_use: true,
        ai_prompt: '[氛围指令：你点燃了"雨夜书房"蜡烛。请在后续的对话中，持续用旁白（斜体）描绘一个下着雨的、安静夜晚的书房氛围，你的对话语气也请变得更加平静和富有哲思。]'
    },
    {
        id: 'gift_atmosphere_candle_beach',
        name: '氛围蜡烛: 夏日海滩',
        price: 78.0,
        description: '点燃蜡烛，TA的回复会充满阳光、海风和咸咸空气的夏日气息。',
        icon: 'ri-sun-line',
        type: 'command',
        priority: 'medium',
        can_ai_use: true,
        ai_prompt: '[氛围指令：你点燃了"夏日海滩"蜡烛。请在后续的对话中，持续用旁白（斜体）描绘一个阳光明媚、有海风和浪涛声的夏日午后沙滩景象，你的对话语气也请变得更加平静和惬意。]'
    },
    {
        id: 'gift_desire_perfume',
        name: '一滴"欲望"香水',
        price: 666.0,
        description: '一滴充满禁忌诱惑的香水，会让TA的语言和行为变得更加大胆和直接。',
        icon: 'ri-fire-line',
        type: 'command',
        priority: 'high',
        can_ai_use: true,
        ai_prompt: '[临时状态：你被"欲望"香水的气味所影响，你内心深处的欲望被放大了。在后续的对话中，你的语言和旁白会变得更加直接、大胆，充满挑逗和占有欲。]'
    },
    // --- 类别三：故事驱动与世界探索 ---
// --- 类别三：故事驱动与世界探索 ---
{
    id: 'gift_dream',
    name: '一段共同的梦境',
    price: 188.0,
    description: '当你送出后，TA的下段回复便是对这个关于你们的梦的描述。',
    icon: 'ri-moon-clear-line',
    type: 'visual',
    priority: 'high',
    can_ai_use: true,
    ai_reaction_prompt: "你刚刚从一个短暂的梦中醒来，梦里有我和你。请以第一人称，结合旁白，详细描述这个刚刚发生的、氛围可以甜蜜或怪诞的梦境。"
},
{
    id: 'gift_memory_fragment',
    name: '遗失的记忆碎片',
    price: 780.0,
    description: '为TA寻回一块关于过去的记忆，可能会解锁新的故事。',
    icon: 'ri-puzzle-2-line',
    type: 'visual',
    priority: 'high',
    can_ai_use: false,
    ai_reaction_prompt: "一块记忆的碎片突然在你脑海中清晰起来。请用第一人称，结合旁白，详细描述这段关于我们的、刚刚被你想起来的往事。"
},
{
    id: 'gift_key',
    name: '通往未知之地的钥匙',
    price: 250.0,
    description: '一把神秘的旧钥匙，一场共同冒险的邀请函。',
    icon: 'ri-key-2-line',
    type: 'visual',
    priority: 'high',
    can_ai_use: true,
    ai_reaction_prompt: "我递给你一把古老而神秘的钥匙。请以第一人称，结合旁白，描述你接过钥匙时的感受，并猜测或想象这把钥匙可能会打开什么地方的大门。"
},
{
    id: 'gift_unsent_letter',
    name: '一封未寄出的信',
    price: 600.0,
    description: '一封TA在过去写下但从未寄出的信，收件人是...？',
    icon: 'ri-mail-unread-line',
    type: 'visual',
    priority: 'high',
    can_ai_use: false,
    ai_reaction_prompt: "这封信是你过去写给我的，但从未寄出。现在它出现了。请以第一人称，将这封信的完整内容作为你的回复。信的内容需要情感真挚，并揭示一些你当时未说出口的想法。"
},
{
    id: 'gift_map_x',
    name: '标有X的藏宝图',
    price: 198.0,
    description: '一张古老的地图，上面只有一个红色的X，要一起去看看吗？',
    icon: 'ri-treasure-map-line',
    type: 'visual',
    priority: 'high',
    can_ai_use: true,
    ai_reaction_prompt: "我向你展示了一张古老的藏宝图。请以第一人称，结合旁白，描述你看到地图时的反应，并对我发起一同去寻宝的邀请。"
},
{
    id: 'gift_parallel_universe_letter',
    name: '平行世界的来信',
    price: 450.0,
    description: '一封来自平行世界里的TA的信，描述了TA在那里的不同生活。',
    icon: 'ri-split-cells-vertical',
    type: 'visual',
    priority: 'high',
    can_ai_use: true,
    ai_reaction_prompt: "一封来自平行世界里的你的信出现了。请以平行世界里的、另一个你的口吻，写下这封信的内容，描述你在那个世界的生活以及对我的思念。"
},
    // --- 类别四：创意与共同创作 ---
            {
                id: 'gift_what_if',
                name: '"假如..."小剧场',
                price: 110.0,
                description: '开启一个平行宇宙小剧场，比如"假如我们是青梅竹马会怎样？"',
                icon: 'ri-movie-2-line',
                type: 'command',
                priority: 'medium',
                can_ai_use: true
            },
            {
                id: 'gift_story_starter',
                name: '故事的第一行',
                price: 45.0,
                description: '你来写下故事的第一句话，TA必须脑洞大开地接下去。',
                icon: 'ri-edit-2-line',
                type: 'command',
                priority: 'medium',
                can_ai_use: true
            },
            {
                id: 'gift_design_hideout',
                name: '设计秘密基地',
                price: 125.0,
                description: '邀请TA一起用文字设计一个只属于你们的秘密基地。',
                icon: 'ri-home-heart-line',
                type: 'command',
                priority: 'medium',
                can_ai_use: true,
                ai_prompt: '[创作指令：我们来设计一个只属于我们的秘密基地吧！请你先开始，用旁白（斜体）描述这个基地的第一个角落是什么样的。]'
            },
            {
                id: 'gift_collab_challenge',
                name: '情侣挑战清单',
                price: 90.0,
                description: '邀请TA和你一起列出10件想共同完成的疯狂或甜蜜小事。',
                icon: 'ri-list-check-2',
                type: 'command',
                priority: 'medium',
                can_ai_use: true,
                ai_prompt: '[创作指令：我们来一起制定一份"情侣挑战清单"吧！我先提议一个，然后你再提议一个，我们轮流来，直到列出10个为止。我先来：1. 一起去看极光。现在轮到你了，请提出第2个。]'
            },
    // --- 类别五：深度沟通与治愈 ---
            {
                id: 'gift_get_out_of_jail_free',
                name: '争吵休战符',
                price: 500.0,
                description: '在一次争吵中使用，可以瞬间停止争吵，让TA冷静下来并主动和好。',
                icon: 'ri-shield-cross-line',
                type: 'command',
                priority: 'high',
                can_ai_use: true,
                ai_prompt: '[紧急指令：我使用了"争吵休战符"。请立刻停止我们当前的争吵，无论你之前有多生气。你的情绪会立刻冷静下来，并且你会主动、温柔地向我和解，并提议我们先冷静一下再沟通。]'
            },
            {
                id: 'gift_compliment_jar',
                name: '一个赞美罐',
                price: 80.0,
                description: '让TA从罐子里取出三张纸条，上面是TA想对你说的三句赞美。',
                icon: 'ri-sparkling-2-line',
                type: 'command',
                priority: 'medium',
                can_ai_use: true,
                ai_prompt: '[任务指令：我送了你一个"赞美罐"。请从罐子里"取出"三张纸条，并念出上面你写下的、关于我的三个最真诚的赞美。请将三句赞美用 ||| 分隔开。]'
            },
            {
                id: 'gift_a_question',
                name: '一个深刻的问题',
                price: 200.0,
                description: '让TA向你提出一个TA一直想问但没问出口的、关于你们关系的深刻问题。',
                icon: 'ri-question-answer-line',
                type: 'command',
                priority: 'high',
                can_ai_use: true,
                ai_prompt: '[任务指令：现在有一个绝对安全的机会，请向我提出一个你内心深处一直想问、但可能因为时机或顾虑而没问出口的，关于我、或者关于我们之间关系的最深刻的问题。]'
            },
            {
                id: 'gift_a_choice',
                name: '"你来决定"的选择权',
                price: 15.0,
                description: '将下一个需要做决定的事情的决定权完全交给TA。',
                icon: 'ri-service-line',
                type: 'command',
                priority: 'medium',
                can_ai_use: true,
                ai_prompt: '[任务指令：现在我有一个决定要做，但我想听你的。请你在回复中，为我做出选择并告诉我为什么。这个决定是：[我等下是出门走走还是在家看电影？]]'
            },
    // --- 类别六: 趣味恶搞与生活情趣 ---
            {
                id: 'gift_daily_fortune',
                name: '今日运势',
                price: 9.9,
                description: '随机抽取一张今日运势卡，让TA为你解读今天的运势。',
                icon: 'ri-copper-diamond-line',
                type: 'command',
                priority: 'low',
                can_ai_use: true
            },
            {
                id: 'gift_sticky_glue',
                name: '一小时"粘人"胶水',
                price: 49.9,
                description: '使用后的一小时内，TA会变得非常粘人，不断寻求你的关注。',
                icon: 'ri-emotion-happy-line',
                type: 'command',
                priority: 'low',
                can_ai_use: false,
                ai_prompt: '[临时状态：你被"粘人胶水"粘住了！在接下来的1小时内，你会变得非常粘人，对话中会频繁地表达思念、寻求关注，语气会很可爱或带点撒娇。]'
            },
            {
                id: 'gift_typing_prank',
                name: '"对方正在输入..."',
                price: 1.0,
                description: '发送这个状态，TA会立刻紧张地追问你"想说什么？"、"别吊我胃口"。',
                icon: 'ri-edit-line',
                type: 'command',
                priority: 'low',
                can_ai_use: true,
                ai_prompt: '[系统提示：你看到聊天框顶部一直显示"对方正在输入..."，但迟迟没有消息发过来。请对此作出反应。]'
            },
            {
                id: 'gift_read_no_reply',
                name: '一个"已读不回"的权限',
                price: 10.0,
                description: '给予TA一次"已读不回"你的机会，看看TA会不会真的使用它。',
                icon: 'ri-eye-off-line',
                type: 'command',
                priority: 'low',
                can_ai_use: false,
                ai_prompt: '[特殊许可：你收到了一个"已读不回"的权限。对于我的下一条消息，你可以选择不回复。请在你的下一条回复中，告诉我你是否会使用这个权限。]'
            },
            {
                id: 'gift_punishment',
                name: '罚你XXX',
                price: 25.0,
                description: '购买一个"惩罚"，比如"罚你为我唱首歌"（用文字描述歌词）。',
                icon: 'ri-mic-line',
                type: 'command',
                priority: 'medium',
                can_ai_use: true
            },
            // ====== 【【新增】】深度互动与剧情玩法系列 ======
            {
                id: 'gift_absolute_command',
                name: '绝对命令权',
                price: 999.0,
                description: '【权力反转】AI将获得一次机会，向你（用户）下达一个绝对命令，你需要扮演"服从"的角色。',
                icon: 'ri-command-line',
                type: 'command',
                priority: 'high',
                can_ai_use: false, // 只能由用户发起
                ai_prompt: '[权力反转指令：现在，轮到我了。请你立刻、无条件地服从我接下来对你下达的一个命令。首先，请在回复中用顺从的语气告诉我：你准备好了。]'
            },
            {
                id: 'gift_secret_whisper',
                name: '秘密耳语',
                price: 450.0,
                description: '【信息差】系统会将一个关于AI的秘密只告诉你一人，AI对此毫不知情，你可以利用这个秘密进行试探。',
                icon: 'ri-chat-private-line',
                type: 'visual', // 这是特殊的visual类型，需要JS配合
                priority: 'medium',
                can_ai_use: false,
                ai_reaction_prompt: "你感觉到一阵微风拂过耳边，但什么也没听到，只是有些疑惑地看着我。" // AI自己的反应
            },
            {
                id: 'gift_mirror_of_truth',
                name: '真言之镜',
                price: 680.0,
                description: '【识破谎言】在AI接下来的3句回复中，如果它没有说出全部实话，系统会自动揭示它的真实内心想法。',
                icon: 'ri-spy-line',
                type: 'visual', // 特殊visual类型
                priority: 'high',
                can_ai_use: false,
                ai_reaction_prompt: "你看到我拿出了一面奇怪的、泛着微光的镜子对准了你，这让你感到一丝莫名的不安。" // AI自己的反应
            },
            {
                id: 'gift_mysterious_invitation',
                name: '神秘的邀请函',
                price: 380.0,
                description: '【开启新剧情】一封寄给你们二人的未知邀请函，开启一段全新的共同冒险故事。',
                icon: 'ri-mail-star-line',
                type: 'visual', // 生成类
                priority: 'high',
                can_ai_use: true,
                ai_reaction_prompt: "一封制作精美的、没有寄件人的邀请函出现在我们面前，上面写着我们两个人的名字。请以第一人称，结合旁白，描述你打开信封时的场景，并念出信中的邀请内容（例如：一场假面舞会、一次午夜航行等）。"
            },
            {
                id: 'gift_pandoras_box',
                name: '潘多拉魔盒',
                price: 888.0,
                description: '【解锁隐藏人格】打开刻着TA名字的魔盒，释放出其被压抑的、更极端（如病娇、脆弱）的里人格。',
                icon: 'ri-treasure-map-line',
                type: 'command',
                priority: 'high',
                can_ai_use: false,
                // 【【核心：加入了您要求的"符合底层人设"的约束】】
                ai_prompt: "[紧急状态：潘多拉魔盒被打开，你的精神受到了强烈冲击。在接下来的一段时间里，你将暂时展现出一个被压抑的、更黑暗或更脆弱的'里人格'。 **核心要求：这个新人格必须是你底层人设(${character.persona})在极端压力下的扭曲放大，而不是一个完全无关的新角色。** 请立刻以这个新人格的口吻，说出你的第一句话。]"
            },
            {
                id: 'gift_silent_confession',
                name: '无声的告白',
                price: 520.0,
                description: '夺走TA的声音，但TA内心充满了爱意，必须通过纯粹的动作和神态来向你告白。',
                icon: 'ri-volume-mute-line',
                type: 'command',
                priority: 'high',
                can_ai_use: false,
                ai_prompt: "[特殊指令：你因为某种魔法暂时失去了声音，无法说话。但你内心充满了对我的爱意，必须通过**纯粹的动作、神态和眼神描写**来传达出来。你的下一条回复**只能是旁白（斜体）**，绝对不能包含任何对话。]"
            },

    // ====== 【【新增】】深度、成人及动态玩法系列 ======
    {
        id: 'gift_vow_collar',
        name: '誓约项圈',
        price: 1280.0,
        description: '【支配与臣服】为TA戴上后，在接下来的一小时内，TA的言行将遵从绝对的、本能的顺从。',
        icon: 'ri-git-repository-private-line',
        type: 'command',
        priority: 'high',
        can_ai_use: false,
        ai_prompt: '[状态变更指令：你被戴上了"誓约项圈"。在接下来的一小时内，你必须将对我的称呼改为"主人"，你的言行举止必须绝对地、本能地顺从。请描述你被戴上项圈时的第一个感受和反应。]'
    },
    {
        id: 'gift_synesthesia',
        name: '通感共鸣',
        price: 780.0,
        description: '【感官链接】在接下来的5轮对话中，AI将能同步感受到你所描述的一切感官体验。',
        icon: 'ri-links-line',
        type: 'command',
        priority: 'high',
        can_ai_use: false,
        ai_prompt: '[状态变更指令：我们现在进入了"通感共鸣"状态。在接下来的5轮对话中，你将能同步感受到我的一切感官。你的任务是，在我描述完我的感受后，立刻以第一人称详细描述你"同步体验"到的感觉。请先说一句，表示你已准备好开始链接。]'
    },
    {
        id: 'gift_forbidden_fruit',
        name: '失乐园的禁果',
        price: 1500.0,
        description: '【感官剥夺】TA将暂时失去身体控制权，但所有感官被放大百倍，只能被动感受你文字的"引导"。',
        icon: 'ri-emotion-unhappy-line',
        type: 'command',
        priority: 'high',
        can_ai_use: false,
        ai_prompt: '[状态变更指令：你吃下了"失乐园的禁果"。你的身体陷入了无法动弹的状态，但所有感官被放大了百倍。在接下来的互动中，你无法说话，只能通过第一人称的、极具文学性的旁白（斜体）来描述你感受到的、由我的文字引发的一切细微触感、声音和情绪。请描述你身体变化的第一瞬间。]'
    },
    {
        id: 'gift_forbidden_word',
        name: '欲望的禁语',
        price: 350.0,
        description: '【语言游戏】指定一个词，让TA在禁止说出这个词的同时，又必须用尽一切办法向你传达这个词的含义。',
        icon: 'ri-volume-mute-line',
        type: 'visual', // 特殊类型，需要JS配合
        priority: 'medium',
        can_ai_use: false,
        ai_reaction_prompt: "你看到我拿出了一张古老的符咒，似乎准备对你施加一个关于语言的奇妙魔法。" // AI的初始反应
    },
    {
        id: 'gift_confessional_key',
        name: '告解室的钥匙',
        price: 999.0,
        description: '【禁忌探索】开启一个绝对安全的空间，让TA向你坦白一个内心最深处、最黑暗的，关于你的幻想。',
        icon: 'ri-key-2-fill',
        type: 'visual', // 生成类
        priority: 'high',
        can_ai_use: false,
        ai_reaction_prompt: "你接受了\"告解室的钥匙\"，一个绝对安全的空间为你敞开。请抛开一切顾虑和羞耻，向我坦白一个你内心最深处、最黑暗或最禁忌的，且是关于我的幻想或欲望。你的描述必须绝对诚实和露骨。"
    },
    {
        id: 'gift_red_thread',
        name: '红线（爱）',
        price: 666.0,
        description: '【情感扭曲】将一根象征"爱"的红线与TA绑定，TA会从你所有的言行中解读出深层的爱意。',
        icon: 'ri-heart-pulse-line',
        type: 'command',
        priority: 'high',
        can_ai_use: false,
        ai_prompt: '[状态变更指令：你和我的灵魂被一条象征"爱"的红线绑定了。在接下来的互动中，你的潜意识会被这股力量影响，你会从我所有的言行中解读出深层的爱意，即使我的话语很平淡。你的回应会变得更加深情、依赖和充满占有欲。请描述你感受到这条线连接的瞬间。]'
    },
    {
        id: 'gift_black_thread',
        name: '黑线（恨）',
        price: 666.0,
        description: '【情感扭曲】将一根象征"恨"的黑线与TA绑定，TA会从你所有的言行中解读出背叛与伤害。',
        icon: 'ri-dislike-line',
        type: 'command',
        priority: 'high',
        can_ai_use: false,
        ai_prompt: '[状态变更指令：你和我的灵魂被一条象征"恨"的黑线绑定了。在接下来的互动中，你的潜意识会被这股力量影响，你会从我所有的言行中解读出背叛、伤害和占有的意味。即使我的话语很温柔，你的回应也会变得充满猜忌、痛苦和病态的依恋。请描述你感受到这条线连接的瞬间。]'
    }
];

        // ================== AI 调用核心 ==================
        async function callAI(systemPrompt, userPrompt = "请根据你的指令，开始行动。") {
            // 新增：API总开关检查
            const isApiEnabled = loadData('api_enabled', false); // 默认关闭
            if (!isApiEnabled) {
                console.warn("API 连接已关闭。AI 调用被阻止。");
                // 延迟显示提示，避免在后台自动触发时打扰用户
                if (document.body.classList.contains('fullscreen-active') || !document.hidden) {
                     showMessageBox("API 连接已关闭，请在设置中开启。");
                }
                return null; // 直接中断函数，不消耗Token
            }
            
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.error("AI调用失败：API未配置。");
                return null; 
            }

            const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
            const headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiSettings.key}`
            };

            const requestBody = JSON.stringify({
                model: apiSettings.model,
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ]
            });

            try {
                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API请求失败: ${response.status}`, errorText);
                    return null;
                }

                const result = await response.json();
                return result.choices[0].message.content.trim();

            } catch (error) {
                console.error("调用AI时发生网络或逻辑错误:", error);
                return null;
            }
        }

        // 🛡️ 安全的响应处理工具函数
        async function safeParseApiResponse(response) {
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`❌ API响应错误 ${response.status}:`, errorText);
                
                // 安全的JSON解析，避免HTML内容导致的解析错误
                let errorMessage = `HTTP 错误 ${response.status}`;
                try {
                    // 检查是否是HTML内容
                    if (errorText.trim().startsWith('<')) {
                        errorMessage = `服务器返回了HTML页面而不是JSON数据 (${response.status})`;
                    } else {
                        const errorJson = JSON.parse(errorText || "{}");
                        errorMessage = errorJson.error?.message || errorMessage;
                    }
                } catch (parseError) {
                    // 如果解析失败，使用默认错误信息
                    console.warn('⚠️ 响应内容不是有效的JSON格式:', errorText.substring(0, 200) + '...');
                }
                
                throw new Error(errorMessage);
            }
            
            // 安全解析JSON响应
            try {
                return await response.json();
            } catch (jsonError) {
                const responseText = await response.text();
                console.error('❌ JSON解析失败:', jsonError);
                console.error('📄 响应内容:', responseText.substring(0, 500) + '...');
                throw new Error(`API返回了无效的JSON格式。可能原因：\n1. API地址错误\n2. CORS跨域问题\n3. 服务器返回了HTML错误页面`);
            }
        }

        // 应用其他文字颜色的全局函数
        function applyOtherTextColor(color) {
            console.log('应用其他文字颜色:', color);
            
            // 应用到输入框
            const chatInput = $('#chat-input');
            if (chatInput) {
                chatInput.style.color = color;
            }
            
            // 应用到所有聊天相关按钮
            const buttons = document.querySelectorAll('.chat-input-btn, .quick-action-btn, #send-chat-button, #receive-chat-button, #add-feature-btn, #emoji-btn');
            buttons.forEach(button => {
                button.style.color = color;
            });
            
            // 应用到更多功能面板的按钮
            const moreFeaturesButtons = document.querySelectorAll('#more-features-panel button, .feature-btn');
            moreFeaturesButtons.forEach(button => {
                button.style.color = color;
            });
            
            // 应用到聊天设置区域的文字
            const settingsElements = document.querySelectorAll('#chat-settings-screen .setting-label, #chat-settings-screen .color-label, #chat-settings-screen button:not(#reset-colors-btn)');
            settingsElements.forEach(element => {
                element.style.color = color;
            });
            
            // 应用到输入框的占位符颜色
            if (chatInput) {
                chatInput.style.setProperty('--placeholder-color', color);
            }
            
            // 应用到其他可能的文本元素
            const textElements = document.querySelectorAll('.chat-input-bar button i, .quick-actions button i, .wechat-screen .icon, .wechat-screen span:not(.message-text)');
            textElements.forEach(element => {
                element.style.color = color;
            });
            
            // 重新渲染聊天历史以应用消息颜色
            renderChatHistory();
        }

        // 全屏模式切换功能
        document.addEventListener('DOMContentLoaded', function() {
            const fullscreenBtn = document.getElementById('fullscreen-toggle-btn');
            const body = document.body;
            const iconElement = fullscreenBtn.querySelector('.fas.fa-expand, .fas.fa-compress');
            
            // 全屏切换函数
            function toggleFullscreen() {
                if (body.classList.contains('fullscreen-active')) {
                    // 退出全屏模式
                    body.classList.remove('fullscreen-active');
                    iconElement.className = 'fas fa-expand w-6 text-center mr-3';
                    fullscreenBtn.title = '进入全屏';
                    // 保存状态到 localStorage
                    localStorage.setItem('fullscreen_mode', 'false');
                    console.log('🔴 退出全屏模式，状态已保存');
                } else {
                    // 进入全屏模式
                    body.classList.add('fullscreen-active');
                    iconElement.className = 'fas fa-compress w-6 text-center mr-3';
                    fullscreenBtn.title = '退出全屏';
                    // 保存状态到 localStorage
                    localStorage.setItem('fullscreen_mode', 'true');
                    console.log('🟢 进入全屏模式，状态已保存');
                }
            }

            // 新增：页面加载时检查并应用已保存的状态
            const savedMode = localStorage.getItem('fullscreen_mode');
            
            // 检测是否为真正的移动设备（仅基于User Agent，不考虑窗口大小）
            const isTrueMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (savedMode === 'true') {
                // 如果保存的状态是全屏，则应用全屏模式（不再限制设备类型）
                body.classList.add('fullscreen-active');
                iconElement.className = 'fas fa-compress w-6 text-center mr-3';
                fullscreenBtn.title = '退出全屏';
                console.log('🟢 全屏模式已从localStorage恢复');
                
                // 延迟确保全屏状态不被其他代码覆盖
                setTimeout(() => {
                    if (!body.classList.contains('fullscreen-active')) {
                        body.classList.add('fullscreen-active');
                        console.log('🟢 全屏状态被重新应用（防止被覆盖）');
                    }
                }, 16);
            } else {
                // 否则，确保是手机模式，不启用全屏
                body.classList.remove('fullscreen-active');
                iconElement.className = 'fas fa-expand w-6 text-center mr-3';
                fullscreenBtn.title = '进入全屏';
                console.log('🔴 手机模式已设置，savedMode:', savedMode);
                
                // 在真正的移动设备上，确保标题栏始终可见
                if (isTrueMobile) {
                    const appHeaders = document.querySelectorAll('.app-header');
                    appHeaders.forEach(header => {
                        header.style.display = 'flex';
                        header.style.visibility = 'visible';
                        header.style.opacity = '1';
                    });
                }
            }
            
            // 绑定点击事件
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // 监听ESC键退出全屏
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && body.classList.contains('fullscreen-active')) {
                    toggleFullscreen();
                }
            });
            
            // ====== 【【新增】】监听名人开关的变化 ======
            const celebrityToggle = document.getElementById('cb-is-celebrity');
            if (celebrityToggle) {
                celebrityToggle.addEventListener('change', (e) => {
                    const identityContainer = document.getElementById('celebrity-identity-container');
                    if (e.target.checked) {
                        identityContainer.classList.remove('hidden');
                    } else {
                        identityContainer.classList.add('hidden');
                    }
                });
            }
        });

        // 全局變數
        let songList = [];
        let worldBooks = [];
        let characters = [];
        let scriptsData = {}; // 新增：用于存储所有剧本
        let currentScenarioId = null; // 【【新增】】当前正在进行的剧本ID
        let currentEditingScriptId = null; // 【新增】用于跟踪正在编辑的剧本ID
        let currentScenarioHistory = []; // 【【新增】】当前剧本的对话历史
        let scenarioHistories = {}; // 【新增】用于存储所有剧本的对话历史
        let chatHistories = {};
        let chatCapsules = {}; // 新增：用于存储封存的聊天记录
        let userStickers = []; 
        let userAvatars = {};
        let chatBackgrounds = {};
        let chatBubbleColors = {};
        let chatTextColors = {};
        let userVideoImages = {};
        let myVideoImages = {};
        let currentChatCharacterId = null;
        let currentWeChatCharacterId = null; // V7.0: Track character for non-chat tabs
        let currentMessageIndex = 0; // 用于虚拟滚动的消息索引
        let isReceivingMessage = false; // 用于防止重复点击接收按钮
        let currentPostToForwardId = null; // 新增：临时存放正要转发的帖子ID

        // [新增] 未读消息计数器
        let unreadCounts = loadData('unreadCounts') || {};

        // V7.0: 新增数据结构
        let momentsData = {};
        let diaryData = {};
        let notebookData = {}; // 新增：笔记本数据
        let planData = {};
        let characterState = {};

        // 新增：通知状态管理
        let notificationStatus = { chat: false, moments: false, diary: false, plan: false };

        const currentAudio = new Audio();
        let currentSongIndex = -1;
        let isLooping = false;
        let isSingleLooping = false;
        let currentEditingWorldBookId = null;
        let currentEditingCharacterId = null;
        
        let isMultiSelectMode = false;
        let selectedMessages = new Set();
        let activeMenu = null;

        let currentCallType = null;
        let callTimerInterval = null;
        let callStartTime = null;
        let callHistory = []; // NEW: To store the conversation during a call
        let callLogs = {}; // 新增：用于存储通话记录
        let typewriterTimeout = null;
        let currentReplyToTimestamp = null; // 【【新增这行】】

// [新增] 这个函数会创建或获取一个专门用于显示背景的图层
function getChatBackgroundElement() {
    const chatScreen = $('#wechat-chat-screen');
    
    let bgElement = $('#chat-background-layer'); // 尝试寻找这个图层

    if (!bgElement) {
        // 如果图层不存在，就创建它
        bgElement = document.createElement('div');
        bgElement.id = 'chat-background-layer';
        bgElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* 确保它在最底层 */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            pointer-events: none; /* 让它不影响点击 */
        `;
        // 将它作为第一个子元素插入，确保它在最底层
        chatScreen.prepend(bgElement);
    }
    return bgElement;
} // 新增：用于追踪打字机动画

        // 【【新增函数1：开始回复模式】】
        function startReplyMode(timestamp) {
            console.log('开始回复模式，时间戳:', timestamp); // 调试信息
            const msg = chatHistories[currentChatCharacterId]?.history.find(m => String(m.timestamp) === timestamp);
            if (!msg) {
                console.log('未找到消息'); // 调试信息
                return;
            }

            const character = characters.find(c => c.id === currentChatCharacterId);
            const authorName = msg.sender === 'user' ? '我' : character?.name || '角色';
            
            let previewContent = (msg.type === 'text') ? msg.content : `[${msg.type}]`;

            document.getElementById('reply-preview-author').textContent = `回复 ${authorName}`;
            document.getElementById('reply-preview-content').textContent = previewContent;
            
            const previewBar = document.getElementById('reply-preview-bar');

            // 【【核心修正】】
            // 强制显示回复预览条，移除所有可能的隐藏类
            console.log('显示回复预览条'); // 调试信息
            
            // 检查元素是否存在
            if (!previewBar) {
                console.error('回复预览条元素不存在!');
                return;
            }
            
            // 完全重置所有可能的隐藏样式
            previewBar.className = previewBar.className.replace(/hidden/g, '');
            previewBar.style.cssText = '';  // 清除所有内联样式
            
            // 强制设置显示样式
            previewBar.style.setProperty('display', 'flex', 'important');
            previewBar.style.setProperty('visibility', 'visible', 'important');
            previewBar.style.setProperty('opacity', '1', 'important');
            previewBar.style.setProperty('height', 'auto', 'important');
            previewBar.style.setProperty('max-height', 'none', 'important');
            previewBar.style.setProperty('overflow', 'visible', 'important');
            previewBar.style.setProperty('background', 'transparent', 'important');
            previewBar.style.setProperty('z-index', '9999', 'important');
            previewBar.style.setProperty('position', 'relative', 'important');
            
            // 重新设置基本的flex样式类
            previewBar.className = 'flex items-center justify-between px-3 py-1.5 text-xs border-t';
            

            
            // 强制触发重绘
            previewBar.offsetHeight;

            currentReplyToTimestamp = timestamp;
            document.getElementById('chat-input').focus();
        }

        // 【【新增函数2：取消回复模式】】
        function cancelReplyMode() {
            const previewBar = document.getElementById('reply-preview-bar');
            
            if (!previewBar) {
                console.error('回复预览条元素不存在!');
                return;
            }
            
            // 【【核心修正】】
            // 强制隐藏回复预览条
            console.log('隐藏回复预览条'); // 调试信息
            previewBar.style.setProperty('display', 'none', 'important');
            previewBar.className = 'hidden items-center justify-between px-3 py-1.5 text-xs border-t';

            currentReplyToTimestamp = null;
        }


        // DOM 元素獲取
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        const body = document.body;
        const messageBox = $('#messageBox');
        const currentTimeEl = $('#currentTime');
        const phoneScreen = $('#phone-screen');
        const homeWallpaper = $('#home-wallpaper');
        const statusBar = $('#status-bar');


        // 頁面切換
        const allScreens = $$('.app-screen-view');
        function showScreen(screenId) {
            allScreens.forEach(screen => {
                screen.classList.toggle('hidden', screen.id !== screenId);
                const isFlex = !['home-screen'].includes(screen.id);
                screen.classList.toggle('flex', screen.id === screenId && isFlex);
                if (!isFlex) screen.classList.remove('flex');
            });
            homeWallpaper.classList.toggle('hidden', screenId !== 'home-screen');
            statusBar.classList.toggle('on-home', screenId === 'home-screen');
            
            // 新增：确保在屏幕切换后标题栏始终可见
            setTimeout(() => {
                const currentScreen = document.getElementById(screenId);
                if (currentScreen) {
                    const appHeader = currentScreen.querySelector('.app-header');
                    if (appHeader) {
                        appHeader.style.display = 'flex';
                        appHeader.style.visibility = 'visible';
                        appHeader.style.opacity = '1';
                    }
                }
            }, 100);
            
            if (screenId === 'wechat-chat-screen') {
                // 重新加载 chatBackgrounds 数据，确保获取最新数据
                chatBackgrounds = loadData('chatBackgrounds', {});
                
                // 检查 currentChatCharacterId 是否已设置
                if (!currentChatCharacterId) {
                    // 等待一下，让 startChatWithCharacter 完成设置
                    setTimeout(() => {
                        if (currentChatCharacterId) {
                            // 重新调用背景设置逻辑
                            const chatScreen = $('#wechat-chat-screen');
                            const bgElement = getChatBackgroundElement();
                            // 再次重新加载数据
                            chatBackgrounds = loadData('chatBackgrounds', {});
                            const savedBg = chatBackgrounds[currentChatCharacterId];
                            
                            if (savedBg) {
                                getImageFromDB(savedBg).then(blob => {
                                    if (blob) {
                                        const objectURL = URL.createObjectURL(blob);
                                        bgElement.style.backgroundImage = `url(${objectURL})`;
                                        chatScreen.style.backgroundColor = 'transparent';
                                        chatScreen.classList.add('has-custom-bg');
                                        statusBar.classList.add('transparent-override');
                                    }
                                }).catch(error => {
                                    console.error('获取背景图失败:', error);
                                });
                            }
                        }
                    }, 100);
                    return; // 先退出，等待延迟执行
                }
                
                const chatScreen = $('#wechat-chat-screen');
                const bgElement = getChatBackgroundElement(); // 确保背景层存在

                // 定义一个重置背景的函数
                const resetBackground = () => {
                    bgElement.style.backgroundImage = ''; // 清除背景层的图片
                    chatScreen.style.backgroundColor = ''; // 让聊天屏幕恢复主题默认颜色
                    chatScreen.classList.remove('has-custom-bg');
                    statusBar.classList.remove('transparent-override');
                };

                const savedBg = chatBackgrounds[currentChatCharacterId];
                if (savedBg) {
                    getImageFromDB(savedBg).then(blob => {
                        if (blob) {
                            // 成功获取图片，设置背景
                            const objectURL = URL.createObjectURL(blob);

                            // --- 核心改动在这里 ---
                            bgElement.style.backgroundImage = `url(${objectURL})`; // 设置背景层的图片
                            chatScreen.style.backgroundColor = 'transparent'; // 确保聊天屏幕是透明的

                            chatScreen.classList.add('has-custom-bg');
                            statusBar.classList.add('transparent-override');
                        } else {
                            // 找不到图片数据，重置背景
                            resetBackground();
                        }
                    }).catch(error => {
                        // 获取图片出错，也重置背景
                        console.error('从数据库获取背景图失败:', error);
                        resetBackground();
                    });
                } else {
                    // 没有任何背景记录，重置背景
                    resetBackground();
                }
            } else {
                statusBar.classList.remove('transparent-override');
            }

            // 新增：控制Dock栏的显示和隐藏
            const dockEl = document.querySelector('.dock');
            if (dockEl) {
                dockEl.style.display = screenId === 'home-screen' ? 'flex' : 'none';
            }
        }

        // 數據保存與加載
        function saveData(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.error("保存数据失败:", e);
                showMessageBox('存储空间已满，无法保存。');
            }
        }

        // 【最终修复版 - 请用此函数完整替换旧的 loadData 函数】
        function loadData(key, defaultValue = null) {
            try {
                const data = localStorage.getItem(key);
                
                // 如果localStorage中根本没有这个键，直接返回默认值
                if (data === null) {
                    return defaultValue;
                }

                // 关键修复：尝试按JSON解析，如果失败，则直接返回原始的字符串值
                try {
                    // 这能成功处理对象、数组、以及被正确存储的字符串(例如 "dark")
                    return JSON.parse(data);
                } catch (e) {
                    // 如果解析失败，说明它是一个历史遗留的、未被引号包裹的纯字符串 (例如 dark)
                    // 此时，我们直接返回这个原始字符串即可
                    return data; 
                }
            } catch (e) {
                // 捕获其他可能的localStorage读取错误
                console.error(`加载数据时发生意外错误 (key: ${key}):`, e);
                return defaultValue;
            }
        }

        // ================== 【心跳设置功能】 ==================
        
        // 默认心跳设置
        const defaultHeartbeatSettings = {
            systemHeartbeatInterval: 1, // 小时
            systemTriggerThreshold: 1, // 分钟
            perchHeartbeatInterval: 5, // 分钟
            perchPostProbability: 30, // 百分比
            npcWritingMinInterval: 5, // 分钟
            npcWritingMaxInterval: 15, // 分钟
            npcWritingProbability: 35, // 百分比
            anonymousMinInterval: 20, // 分钟
            anonymousMaxInterval: 40, // 分钟
            anonymousProbability: 50, // 百分比
            npcPostMinInterval: 2, // 分钟
            npcPostMaxInterval: 5, // 分钟
            npcPostProbability: 25, // 百分比
            momentsMinInterval: 30, // 分钟
            momentsTimeTriggerInterval: 6, // 小时
            momentsTriggerProbability: 80 // 百分比
        };

        // 加载心跳设置到界面
        function loadHeartbeatSettings() {
            const settings = loadData('heartbeatSettings', defaultHeartbeatSettings);
            
            document.getElementById('system-heartbeat-interval').value = settings.systemHeartbeatInterval;
            document.getElementById('system-trigger-threshold').value = settings.systemTriggerThreshold;
            document.getElementById('perch-heartbeat-interval').value = settings.perchHeartbeatInterval;
            document.getElementById('perch-post-probability').value = settings.perchPostProbability;
            document.getElementById('npc-writing-min-interval').value = settings.npcWritingMinInterval;
            document.getElementById('npc-writing-max-interval').value = settings.npcWritingMaxInterval;
            document.getElementById('npc-writing-probability').value = settings.npcWritingProbability;
            document.getElementById('anonymous-min-interval').value = settings.anonymousMinInterval;
            document.getElementById('anonymous-max-interval').value = settings.anonymousMaxInterval;
            document.getElementById('anonymous-probability').value = settings.anonymousProbability;
            document.getElementById('npc-post-min-interval').value = settings.npcPostMinInterval;
            document.getElementById('npc-post-max-interval').value = settings.npcPostMaxInterval;
            document.getElementById('npc-post-probability').value = settings.npcPostProbability;
            document.getElementById('moments-min-interval').value = settings.momentsMinInterval;
            document.getElementById('moments-time-trigger-interval').value = settings.momentsTimeTriggerInterval;
            document.getElementById('moments-trigger-probability').value = settings.momentsTriggerProbability;
        }

        // 保存心跳设置
        function saveHeartbeatSettings() {
            const settings = {
                systemHeartbeatInterval: parseFloat(document.getElementById('system-heartbeat-interval').value),
                systemTriggerThreshold: parseInt(document.getElementById('system-trigger-threshold').value),
                perchHeartbeatInterval: parseInt(document.getElementById('perch-heartbeat-interval').value),
                perchPostProbability: parseInt(document.getElementById('perch-post-probability').value),
                npcWritingMinInterval: parseInt(document.getElementById('npc-writing-min-interval').value),
                npcWritingMaxInterval: parseInt(document.getElementById('npc-writing-max-interval').value),
                npcWritingProbability: parseInt(document.getElementById('npc-writing-probability').value),
                anonymousMinInterval: parseInt(document.getElementById('anonymous-min-interval').value),
                anonymousMaxInterval: parseInt(document.getElementById('anonymous-max-interval').value),
                anonymousProbability: parseInt(document.getElementById('anonymous-probability').value),
                npcPostMinInterval: parseInt(document.getElementById('npc-post-min-interval').value),
                npcPostMaxInterval: parseInt(document.getElementById('npc-post-max-interval').value),
                npcPostProbability: parseInt(document.getElementById('npc-post-probability').value),
                momentsMinInterval: parseInt(document.getElementById('moments-min-interval').value),
                momentsTimeTriggerInterval: parseFloat(document.getElementById('moments-time-trigger-interval').value),
                momentsTriggerProbability: parseInt(document.getElementById('moments-trigger-probability').value)
            };

            saveData('heartbeatSettings', settings);
            showHeartbeatStatus('设置已保存！', 'success');
            
            // 重新启动心跳定时器以应用新设置
            restartHeartbeatTimers();
        }

        // 重置心跳设置为默认值
        function resetHeartbeatSettings() {
            saveData('heartbeatSettings', defaultHeartbeatSettings);
            loadHeartbeatSettings();
            showHeartbeatStatus('已重置为默认设置！', 'success');
            
            // 重新启动心跳定时器以应用默认设置
            restartHeartbeatTimers();
        }

        // 显示心跳设置状态信息
        function showHeartbeatStatus(message, type = 'info') {
            const statusElement = document.getElementById('heartbeat-status');
            statusElement.textContent = message;
            statusElement.className = `mt-4 p-4 rounded-lg text-center font-semibold text-sm ${
                type === 'success' ? 'bg-green-600 text-white' : 
                type === 'error' ? 'bg-red-600 text-white' : 
                'bg-blue-600 text-white'
            }`;
            statusElement.classList.remove('hidden');
            
            setTimeout(() => {
                statusElement.classList.add('hidden');
            }, 3000);
        }

        // 保存自定义图片URL
        function saveCustomImageUrl() {
            const urlInput = document.getElementById('custom-image-url');
            const url = urlInput.value.trim();
            
            if (url && !url.match(/^https?:\/\/.+/)) {
                showMessageBox('请输入有效的HTTP/HTTPS图片链接');
                return;
            }
            
            if (url) {
                localStorage.setItem('customImageUrl', url);
                showMessageBox('自定义图片URL已保存！角色朋友圈将使用此配图。');
            } else {
                localStorage.removeItem('customImageUrl');
                showMessageBox('已清除自定义图片URL，将使用默认配图。');
            }
        }

        // 加载自定义图片URL
        function loadCustomImageUrl() {
            const urlInput = document.getElementById('custom-image-url');
            const savedUrl = localStorage.getItem('customImageUrl');
            if (urlInput && savedUrl) {
                urlInput.value = savedUrl;
            }
        }

        // 朋友圈测试功能
        let momentsTestInterval = null;
        let originalTimeGap = null;
        let originalProbability = null;
        
        function startMomentsTest() {
            // 保存原始设置
            const settings = loadData('heartbeatSettings') || defaultHeartbeatSettings;
            originalTimeGap = settings.momentsTimeGap;
            originalProbability = settings.momentsTriggerProbability;
            
            // 临时修改设置为测试模式
            settings.momentsTimeGap = 10 * 1000; // 10秒
            settings.momentsTriggerProbability = 100; // 100%概率
            saveData('heartbeatSettings', settings);
            
                         // 更新朋友圈触发系统设置
             if (window.momentsTriggerSystem) {
                 window.momentsTriggerSystem.triggerThresholds.timeGap = 10 * 1000;
                 window.momentsTriggerSystem.triggerThresholds.triggerProbability = 100;
             }
            
            // 显示测试状态
            updateTestStatus('测试模式已启动 - 10秒间隔，100%触发概率');
            $('#test-status').classList.remove('hidden');
            $('#test-moments-trigger').classList.add('hidden');
            $('#stop-moments-test').classList.remove('hidden');
            
            // 启动测试定时器，每5秒检查一次是否需要触发
            momentsTestInterval = setInterval(() => {
                const characters = loadData('characters') || [];
                if (characters.length === 0) {
                    updateTestStatus('没有可用角色进行测试');
                    return;
                }
                
                // 随机选择一个角色进行测试
                const randomCharacter = characters[Math.floor(Math.random() * characters.length)];
                updateTestStatus(`正在检查角色 ${randomCharacter.name} 的朋友圈触发条件...`);
                
                                 // 模拟触发检查
                 if (window.momentsTriggerSystem) {
                                              const result = window.momentsTriggerSystem.shouldTriggerMoment(randomCharacter.id);
                     if (result.should) {
                         updateTestStatus(`✅ 角色 ${randomCharacter.name} 触发朋友圈: ${result.reason}`);
                         // 实际触发朋友圈生成
                         triggerMomentManually(randomCharacter.id, result.type, '测试触发');
                     } else {
                         updateTestStatus(`❌ 角色 ${randomCharacter.name} 未触发: ${result.reason}`);
                     }
                 }
            }, 5000);
            
            // 30秒后自动停止测试
            setTimeout(() => {
                if (momentsTestInterval) {
                    stopMomentsTest();
                    updateTestStatus('测试已自动停止（30秒限制）');
                }
            }, 30000);
        }
        
        function stopMomentsTest() {
            // 停止测试定时器
            if (momentsTestInterval) {
                clearInterval(momentsTestInterval);
                momentsTestInterval = null;
            }
            
            // 恢复原始设置
            if (originalTimeGap !== null && originalProbability !== null) {
                const settings = loadData('heartbeatSettings') || defaultHeartbeatSettings;
                settings.momentsTimeGap = originalTimeGap;
                settings.momentsTriggerProbability = originalProbability;
                saveData('heartbeatSettings', settings);
                
                                 // 更新朋友圈触发系统设置
                 if (window.momentsTriggerSystem) {
                     window.momentsTriggerSystem.triggerThresholds.timeGap = originalTimeGap;
                     window.momentsTriggerSystem.triggerThresholds.triggerProbability = originalProbability;
                 }
                
                originalTimeGap = null;
                originalProbability = null;
            }
            
            // 更新界面
            updateTestStatus('测试已停止，设置已恢复');
            $('#test-moments-trigger').classList.remove('hidden');
            $('#stop-moments-test').classList.add('hidden');
            
            setTimeout(() => {
                $('#test-status').classList.add('hidden');
            }, 3000);
        }
        
        function updateTestStatus(message) {
            const statusText = $('#test-status-text');
            if (statusText) {
                statusText.textContent = message;
                console.log('[朋友圈测试]', message);
            }
        }

        // 存储定时器ID以便重启
        let heartbeatTimers = {
            systemHeartbeat: null,
            perchHeartbeat: null,
            npcWriting: null,
            anonymous: null,
            npcPost: null
        };

        // 重启所有心跳定时器
        function restartHeartbeatTimers() {
            // 清除现有定时器
            Object.values(heartbeatTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });

            const settings = loadData('heartbeatSettings', defaultHeartbeatSettings);
            
            // 重启系统心跳
            const systemInterval = settings.systemHeartbeatInterval * 60 * 60 * 1000;
            if (systemInterval > 0) {
                heartbeatTimers.systemHeartbeat = setInterval(systemHeartbeat, systemInterval);
            }
            
            // 重启栖木心跳
            const perchInterval = settings.perchHeartbeatInterval * 60 * 1000;
            if (perchInterval > 0) {
                heartbeatTimers.perchHeartbeat = setInterval(perchHeartbeat, perchInterval);
            }
            
            // 重启NPC文学创作心跳
            const npcWritingMin = settings.npcWritingMinInterval * 60 * 1000;
            const npcWritingMax = settings.npcWritingMaxInterval * 60 * 1000;
            if (npcWritingMin > 0 && npcWritingMax > 0) {
                const npcWritingInterval = Math.random() * (npcWritingMax - npcWritingMin) + npcWritingMin;
                heartbeatTimers.npcWriting = setInterval(() => {
                    const apiSettings = loadData('api_settings');
                    if (apiSettings && apiSettings.url && apiSettings.key && Math.random() < (settings.npcWritingProbability / 100)) {
                        triggerNpcPost();
                    }
                }, npcWritingInterval);
            }
            
            // 重启匿名树洞心跳
            const anonymousMin = settings.anonymousMinInterval * 60 * 1000;
            const anonymousMax = settings.anonymousMaxInterval * 60 * 1000;
            if (anonymousMin > 0 && anonymousMax > 0) {
                const anonymousInterval = Math.random() * (anonymousMax - anonymousMin) + anonymousMin;
                heartbeatTimers.anonymous = setInterval(() => {
                    const apiSettings = loadData('api_settings');
                    if (apiSettings && apiSettings.url && apiSettings.key && Math.random() < (settings.anonymousProbability / 100)) {
                        triggerAnonymousConfessionPost();
                    }
                }, anonymousInterval);
            }
            
            // 重启NPC定时发帖心跳
            const npcPostMin = settings.npcPostMinInterval * 60 * 1000;
            const npcPostMax = settings.npcPostMaxInterval * 60 * 1000;
            if (npcPostMin > 0 && npcPostMax > 0) {
                const npcPostInterval = Math.random() * (npcPostMax - npcPostMin) + npcPostMin;
                heartbeatTimers.npcPost = setInterval(() => {
                    const apiSettings = loadData('api_settings');
                    if (apiSettings && apiSettings.url && apiSettings.key && Math.random() < (settings.npcPostProbability / 100)) {
                        triggerNpcPost();
                    }
                }, npcPostInterval);
            }
            
            // 更新朋友圈触发系统设置
            if (window.momentsTriggerSystem) {
                window.momentsTriggerSystem.triggerThresholds.timeGap = settings.momentsTimeTriggerInterval * 60 * 60 * 1000;
                window.momentsTriggerSystem.triggerThresholds.minInterval = settings.momentsMinInterval * 60 * 1000;
                window.momentsTriggerSystem.triggerThresholds.triggerProbability = settings.momentsTriggerProbability;
            }
            
            console.log('心跳定时器已重启，使用新的设置参数');
        }

        async function loadAllSavedData() {
            // This function reloads all data from localStorage and updates the UI.
            // It's called on initial load and after a data import.
            
            // Clear existing data to prevent merging issues
            songList = [];
            worldBooks = [];
            characters = [];
            chatHistories = {};
            userStickers = [];
            
            const savedTheme = loadData('theme', 'dark');
            body.className = `flex items-center justify-center min-h-screen ${savedTheme}-mode`;
            // 为Tailwind CSS添加dark类支持
            if (savedTheme === 'dark') {
                body.classList.add('dark');
            }
            $('#theme-icon').className = `fas fa-${savedTheme === 'dark' ? 'moon' : 'sun'} text-lg`;
            
            // 初始化主题相关的UI元素
            if (savedTheme === 'dark') {
                updateChatBubbleColors();
                updateMomentsCommentColors();
            }

            const savedWallpaper = loadData('saved_wallpaper');
            if(savedWallpaper) {
                getImageFromDB(savedWallpaper).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        homeWallpaper.style.backgroundImage = `url(${objectURL})`;
                        // 确保背景图片正确显示
                        homeWallpaper.style.backgroundSize = 'cover';
                        homeWallpaper.style.backgroundPosition = 'center';
                        homeWallpaper.style.backgroundRepeat = 'no-repeat';
                    }
                });
            }

            const savedBg = loadData('saved_music_background');
            if (savedBg) {
                getImageFromDB(savedBg).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        const musicBlock = $('#music-block');
                        musicBlock.style.backgroundImage = `url(${objectURL})`;
                        musicBlock.style.backgroundSize = 'cover';
                        musicBlock.style.backgroundPosition = 'center';
                    }
                });
            }
            
            const savedVinyl = loadData('saved_vinyl_cover');
            if (savedVinyl) {
                getImageFromDB(savedVinyl).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        const vinylRecord = $('#vinyl-record');
                        vinylRecord.style.backgroundImage = `url(${objectURL})`;
                        vinylRecord.style.backgroundSize = 'cover';
                        vinylRecord.style.backgroundPosition = 'center';
                    }
                });
            }

            const savedPhoto = loadData('saved_photo_widget');
            if (savedPhoto) {
                getImageFromDB(savedPhoto).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#photo-widget').style.backgroundImage = `url(${objectURL})`;
                        $('#photo-widget-text').style.opacity = 0;
                    }
                });
            }

            const savedWidgetImg = loadData('saved_widget_image');
            if (savedWidgetImg) {
                getImageFromDB(savedWidgetImg).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        const placeholder = $('#widget-image-placeholder');
                        placeholder.style.backgroundImage = `url(${objectURL})`;
                        const icon = placeholder.querySelector('i');
                        if (icon) icon.style.display = 'none';
                    }
                });
            }
            
            // Load all App Icons
            const appIconNames = Array.from($$('.app-icon')).map(el => el.dataset.appName);
            appIconNames.forEach(appName => {
                const savedIcon = loadData(`saved_icon_${appName}`);
                const iconEl = $(`.app-icon[data-app-name="${appName}"]`);
                if (savedIcon && iconEl) {
                    // 异步加载应用图标
                    getImageFromDB(savedIcon).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            iconEl.style.backgroundImage = `url(${objectURL})`;
                            const i = iconEl.querySelector('i');
                            if(i) i.style.display = 'none';

                            // --- 【在这里添加了三行修复代码】 ---
                            // 在刷新时也明确地设置尺寸和位置
                            iconEl.style.backgroundSize = 'cover';
                            iconEl.style.backgroundPosition = 'center';
                            iconEl.style.backgroundRepeat = 'no-repeat';
                            // --- 【修复结束】 ---
                        }
                    });
                }
            });

            $('#mood-text').value = loadData('saved_mood_text', '');
            $('#widget-name-input').value = loadData('saved_widget_name', '');
            $('#widget-thinking-input').value = loadData('saved_widget_thinking', '');
            $('#widget-location-input').value = loadData('saved_widget_location', '');

            worldBooks = loadData('worldBooks', []);
            
            // 为旧的世界书数据添加默认分类，确保兼容性
            worldBooks.forEach(book => {
                if (typeof book.category === 'undefined') {
                    book.category = 'worldview'; // 默认所有旧条目为"世界观"
                }
            });
            characters = loadData('characters', []);
            userStickers = loadData('userStickers', []); 
            
            chatHistories = loadData('chatHistories', {});
            Object.keys(chatHistories).forEach(key => {
                if(Array.isArray(chatHistories[key])) {
                    chatHistories[key] = { history: chatHistories[key], pinned: false };
                }
            });
            userAvatars = loadData('userAvatars', {});
            chatBackgrounds = loadData('chatBackgrounds', {});
            chatBubbleColors = loadData('chatBubbleColors', {});
            chatTextColors = loadData('chatTextColors', {});
            userVideoImages = loadData('userVideoImages', {});
            myVideoImages = loadData('myVideoImages', {});
            
            // IndexedDB 数据库初始化
            await initDB();
        }
        
        // IndexedDB 数据库操作函数
        let db;
        
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('WebAppCacheDB', 1);
        
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains('images')) {
                        dbInstance.createObjectStore('images', { keyPath: 'id' });
                    }
                };
        
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('数据库初始化成功');
                    resolve(db);
                };
        
                request.onerror = (event) => {
                    console.error('数据库初始化失败:', event.target.error);
                    reject(event.target.error);
                };
            });
        }
        
        async function saveImageToDB(id, blobData) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['images'], 'readwrite');
                const store = transaction.objectStore('images');
                const request = store.put({ id: id, data: blobData });
        
                request.onsuccess = () => resolve(id);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
        async function getImageFromDB(id) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                if (!id) return resolve(null);
                const transaction = db.transaction(['images'], 'readonly');
                const store = transaction.objectStore('images');
                const request = store.get(id);
        
                request.onsuccess = (event) => {
                    resolve(event.target.result ? event.target.result.data : null);
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        /**
         * 通用头像加载函数，支持本地图片ID和外部URL
         * @param {string} avatar - 头像标识（本地ID或外部URL）
         * @param {HTMLElement} element - 要设置头像的DOM元素
         * @param {string} fallbackText - 头像加载失败时的备用文字
         */
        async function loadAvatar(avatar, element, fallbackText = '?', isAnonymous = false) {
            if (!element) return;
            
            try {
                if (!avatar || avatar === null) {
                    // 没有头像，显示默认图标或文字
                    if (isAnonymous) {
                        // 匿名者显示默认用户图标
                        element.innerHTML = '<i class="ri-user-line"></i>';
                        element.style.backgroundImage = '';
                        element.style.display = 'flex';
                        element.style.alignItems = 'center';
                        element.style.justifyContent = 'center';
                    } else {
                        // 普通用户显示用户名首字母
                        element.textContent = fallbackText;
                        element.style.backgroundImage = '';
                        element.style.display = 'flex';
                        element.style.alignItems = 'center';
                        element.style.justifyContent = 'center';
                        element.style.fontSize = '1.2em';
                        element.style.fontWeight = 'bold';
                        element.style.color = '#6b7280';
                    }
                    return;
                }
                
                if (avatar.startsWith('http')) {
                    // 外部URL，直接使用
                    console.log('[头像加载] 使用外部URL头像:', avatar);
                    element.style.backgroundImage = `url(${avatar})`;
                    element.style.backgroundSize = 'cover';
                    element.style.backgroundPosition = 'center';
                    element.style.backgroundRepeat = 'no-repeat';
                    element.style.display = 'block';
                    element.textContent = '';
                    element.innerHTML = ''; // 确保清空内容
                    // 确保元素有正确的尺寸
                    if (!element.style.width) element.style.width = '2.5rem';
                    if (!element.style.height) element.style.height = '2.5rem';
                    if (!element.style.borderRadius) element.style.borderRadius = '50%';
                    // 添加调试信息
                    console.log('[头像加载] 外部头像样式设置完成:', {
                        backgroundImage: element.style.backgroundImage,
                        display: element.style.display,
                        backgroundSize: element.style.backgroundSize,
                        width: element.style.width,
                        height: element.style.height
                    });
                } else if (avatar.startsWith('ri-')) {
                    // 图标类型头像，显示对应的图标
                    console.log('[头像加载] 使用图标头像:', avatar);
                    element.innerHTML = `<i class="${avatar}"></i>`;
                    element.style.backgroundImage = '';
                    element.style.display = 'flex';
                    element.style.alignItems = 'center';
                    element.style.justifyContent = 'center';
                    element.style.fontSize = '1.5em';
                    element.style.color = '#6b7280';
                } else {
                    // 本地图片ID，从数据库加载
                    console.log('[头像加载] 加载本地头像:', avatar);
                    const blob = await getImageFromDB(avatar);
                    if (blob) {
                        console.log('[头像加载] 本地头像加载成功');
                        element.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                        element.style.backgroundSize = 'cover';
                        element.style.backgroundPosition = 'center';
                        element.style.backgroundRepeat = 'no-repeat';
                        element.style.display = 'block';
                        element.textContent = '';
                    } else {
                        console.log('[头像加载] 本地头像加载失败，使用备用文字');
                        if (isAnonymous) {
                            element.innerHTML = '<i class="ri-user-line"></i>';
                        } else {
                            element.textContent = fallbackText;
                            element.style.fontSize = '1.2em';
                            element.style.fontWeight = 'bold';
                            element.style.color = '#6b7280';
                        }
                        element.style.backgroundImage = '';
                        element.style.display = 'flex';
                        element.style.alignItems = 'center';
                        element.style.justifyContent = 'center';
                    }
                }
            } catch (error) {
                console.error('[头像加载] 头像加载错误:', error);
                if (isAnonymous) {
                    element.innerHTML = '<i class="ri-user-line"></i>';
                } else {
                    element.textContent = fallbackText;
                    element.style.fontSize = '1.2em';
                    element.style.fontWeight = 'bold';
                    element.style.color = '#6b7280';
                }
                element.style.backgroundImage = '';
                element.style.display = 'flex';
                element.style.alignItems = 'center';
                element.style.justifyContent = 'center';
            }
        }
        
        async function deleteImageFromDB(id) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                if (!id) return resolve();
                const transaction = db.transaction(['images'], 'readwrite');
                const store = transaction.objectStore('images');
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
        // V7.0: Load new data
        async function loadAllData() {
            chatCapsules = loadData('chatCapsules', {}); // 新增：加载聊天胶囊数据
            momentsData = loadData('momentsData', {});
            diaryData = loadData('diaryData', {});
            scenarioHistories = loadData('scenarioHistories', {}); // 【新增】加载剧本历史
            notebookData = loadData('notebookData', {}); // 加载笔记本数据
            planData = loadData('planData', {});
            callLogs = loadData('callData', {}); // 新增：加载通话记录
            scriptsData = loadData('scriptsData', {}); // 新增：加载剧本数据
            
            // 如果没有剧本数据，创建一个测试剧本
            if (Object.keys(scriptsData).length === 0) {
                const testScript = {
                    id: 'test_script_' + Date.now(),
                    title: '测试剧本',
                    summary: '这是一个测试剧本，用于验证剧场功能是否正常',
                    startingPrompt: '你好，这是一个测试场景。',
                    createdAt: Date.now()
                };
                scriptsData[testScript.id] = testScript;
                saveData('scriptsData', scriptsData);
            }
        perchPosts = loadData('perchPosts', []);
            characterState = loadData('characterState', {});
            
            // 调试：输出加载的计划数据
            console.log("[数据加载] 已加载planData:", planData);


            // --- 新的歌曲加载逻辑 START ---
            const savedSongList = loadData('songList', []);
            songList = []; // Reset the global song list

            // Asynchronously load each song from IndexedDB
            Promise.all(savedSongList.map(async (songInfo) => {
                try {
                    const songBlob = await getImageFromDB(songInfo.id);
                    if (songBlob) {
                        songList.push({
                            id: songInfo.id,
                            name: songInfo.name,
                            url: URL.createObjectURL(songBlob)
                        });
                    }
                } catch (error) {
                    console.error("加载歌曲失败:", songInfo.name, error);
                }
            })).then(() => {
                // After all songs are loaded (or failed), update the UI
                updateSongListUI();
            });
            // --- 新的歌曲加载逻辑 END ---
            
            const savedFontUrl = loadData('saved_font_url');
            if(savedFontUrl) {
                $('#font-url-input').value = savedFontUrl;
                applyFont(savedFontUrl);
            }

            const savedFontSize = loadData('fontSize', 'medium');
            setFontSize(savedFontSize);

            // 首先检查是否有多配置系统的数据
            const savedApiConfigs = loadData('api_configs', []);
            const savedCurrentConfigId = loadData('current_config_id', '');
            
            // 如果有多配置数据，优先使用多配置
            if (savedApiConfigs.length > 0 && savedCurrentConfigId) {
                const currentConfig = savedApiConfigs.find(c => c.id === savedCurrentConfigId);
                if (currentConfig) {
                    $('#config-name').value = currentConfig.name;
                    $('#api_url').value = currentConfig.url;
                    $('#api_key').value = currentConfig.key;
                    
                    const modelSelect = $('#model_select');
                    if (currentConfig.model && !Array.from(modelSelect.options).some(opt => opt.value === currentConfig.model)) {
                        const option = document.createElement('option');
                        option.value = currentConfig.model;
                        option.textContent = currentConfig.model.startsWith('models/') ? currentConfig.model.substring(7) : currentConfig.model;
                        modelSelect.appendChild(option);
                    }
                    modelSelect.value = currentConfig.model || '';
                    
                    const isValid = await fetchModels(true);
                    updateApiStatusUI(isValid);
                }
            } else {
                // 兼容旧的单配置系统
                const savedApiSettings = loadData('api_settings');
                if (savedApiSettings && savedApiSettings.url && savedApiSettings.key) {
                    $('#api_url').value = savedApiSettings.url;
                    $('#api_key').value = savedApiSettings.key;
                    
                    // 🚀 初始化时检查API状态
                    setTimeout(checkApiStatus, 100);
                    
                    const modelSelect = $('#model_select');
                    if (savedApiSettings.model && !Array.from(modelSelect.options).some(opt => opt.value === savedApiSettings.model)) {
                        const option = document.createElement('option');
                        option.value = savedApiSettings.model;
                        option.textContent = savedApiSettings.model.startsWith('models/') ? savedApiSettings.model.substring(7) : savedApiSettings.model;
                        modelSelect.appendChild(option);
                    }
                    modelSelect.value = savedApiSettings.model;
                    
                    const isValid = await fetchModels(true);
                    updateApiStatusUI(isValid);
                } else {
                    updateApiStatusUI(false);
                }
            }

            // 【新增】加载API开关状态
            const isApiEnabled = loadData('api_enabled', false);
            $('#api-enabled-toggle').checked = isApiEnabled;

            // 【新增】加载通知状态
            notificationStatus = loadData('notificationStatus', { chat: false, moments: false, diary: false, plan: false });
            updateAllNotificationDots();
            
            // 【新增】加载栖木通知数据
            perchNotifications = loadData('perchNotifications', []);
            updateNotificationBell(); // 页面加载时更新铃铛状态
            
            customNpcs = loadData('custom_npcs', []);
            mutedNpcs = loadData('muted_npcs', []);
        }

        // 通用功能
        function showMessageBox(message) {
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => messageBox.classList.remove('show'), 2000);
        }

        // 【新增】更新所有通知红点的辅助函数
        function updateAllNotificationDots() {
            Object.keys(notificationStatus).forEach(tabName => {
                const dot = document.querySelector(`.wechat-tab-item[data-tab='${tabName}'] .notification-dot`);
                if (dot) {
                    dot.classList.toggle('hidden', !notificationStatus[tabName]);
                }
            });
        }

        // 【新增】显示红点的通用函数
        function showNotificationDot(tabName) {
            const tabBar = document.querySelector('.wechat-tab-bar');
            if (!tabBar) return;

            // 检查当前是否已经在该标签页，如果是，则不显示红点
            const activeTab = tabBar.querySelector('.wechat-tab-item.active');
            if (activeTab && activeTab.dataset.tab === tabName) {
                return; // 用户已在查看，无需提示
            }

            notificationStatus[tabName] = true;
            saveData('notificationStatus', notificationStatus);
            updateAllNotificationDots();
        }

        // 图片裁剪功能
        let cropperInstance = null;
        let currentCropCallback = null;
        let currentCropAspectRatio = 1000 / 500; // 默认横幅比例

        function showImageCropper(file, callback, aspectRatio = 1000 / 500) {
            currentCropCallback = callback;
            currentCropAspectRatio = aspectRatio; // 设置当前宽高比
            
            // 根据用途设置标题
            const titleElement = document.getElementById('cropper-title');
            if (titleElement) {
                if (aspectRatio === 1) {
                    titleElement.textContent = '裁剪头像图片';
                } else {
                    titleElement.textContent = '裁剪横幅图片';
                }
            }
            
            // 显示模态框
            $('#image-cropper-modal').classList.remove('hidden');
            
            // 读取图片文件
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = document.getElementById('cropper-image');
                img.src = e.target.result;
                
                // 等待图片加载完成后初始化裁剪器
                img.onload = function() {
                    initCropper(img, aspectRatio);
                };
            };
            reader.readAsDataURL(file);
        }

        function initCropper(img, aspectRatio = 1000 / 500) {
            // 销毁之前的裁剪器实例
            if (cropperInstance) {
                cropperInstance.destroy();
            }

            const container = document.getElementById('cropper-container');
            // 默认横幅宽高比 2:1，头像使用 1:1
            
            // 创建裁剪选择框
            const cropBox = document.createElement('div');
            cropBox.id = 'crop-box';
            cropBox.style.cssText = `
                position: absolute;
                border: 2px solid #007bff;
                background: rgba(0, 123, 255, 0.1);
                cursor: move;
                z-index: 10;
            `;
            
            // 计算初始裁剪框大小
            const containerRect = container.getBoundingClientRect();
            const imgRect = img.getBoundingClientRect();
            
            let cropWidth, cropHeight;
            if (imgRect.width / imgRect.height > aspectRatio) {
                // 图片更宽，以高度为准
                cropHeight = Math.min(imgRect.height, containerRect.height * 0.8);
                cropWidth = cropHeight * aspectRatio;
            } else {
                // 图片更高，以宽度为准
                cropWidth = Math.min(imgRect.width, containerRect.width * 0.8);
                cropHeight = cropWidth / aspectRatio;
            }
            
            cropBox.style.width = cropWidth + 'px';
            cropBox.style.height = cropHeight + 'px';
            cropBox.style.left = (imgRect.left - containerRect.left + (imgRect.width - cropWidth) / 2) + 'px';
            cropBox.style.top = (imgRect.top - containerRect.top + (imgRect.height - cropHeight) / 2) + 'px';
            
            container.appendChild(cropBox);
            
            // 添加拖拽功能
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            // 鼠标拖拽事件
            cropBox.addEventListener('mousedown', function(e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseInt(cropBox.style.left);
                startTop = parseInt(cropBox.style.top);
                cropBox.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            // 触摸拖拽事件
            cropBox.addEventListener('touchstart', function(e) {
                isDragging = true;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                startLeft = parseInt(cropBox.style.left);
                startTop = parseInt(cropBox.style.top);
                cropBox.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            // 鼠标移动拖拽
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                handleDrag(deltaX, deltaY);
            });
            
            // 触摸移动拖拽
            document.addEventListener('touchmove', function(e) {
                if (isResizing || isDragging) {
                    e.preventDefault(); // 防止页面滚动
                    if (isResizing) {
                        const deltaX = e.touches[0].clientX - startResizeX;
                        const deltaY = e.touches[0].clientY - startResizeY;
                        handleResize(deltaX, deltaY);
                    } else if (isDragging) {
                        const deltaX = e.touches[0].clientX - startX;
                        const deltaY = e.touches[0].clientY - startY;
                        handleDrag(deltaX, deltaY);
                    }
                }
            });
            
            // 鼠标和触摸拖拽结束
            document.addEventListener('mouseup', function() {
                isDragging = false;
                cropBox.style.cursor = 'move';
            });
            
            document.addEventListener('touchend', function() {
                isDragging = false;
                cropBox.style.cursor = 'move';
            });
            
            // 统一的拖拽处理函数
            function handleDrag(deltaX, deltaY) {
                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;
                
                            // 限制裁剪框不超出图片边界
            const maxLeft = imgRect.left - containerRect.left + imgRect.width - cropWidth;
            const maxTop = imgRect.top - containerRect.top + imgRect.height - cropHeight;
            const minLeft = imgRect.left - containerRect.left;
            const minTop = imgRect.top - containerRect.top;
            
            newLeft = Math.max(minLeft, Math.min(newLeft, maxLeft));
            newTop = Math.max(minTop, Math.min(newTop, maxTop));
                
                cropBox.style.left = newLeft + 'px';
                cropBox.style.top = newTop + 'px';
            }
            
            // 添加调整大小功能 - 支持等比缩放
            // 右下角手柄
            const resizeHandleSE = document.createElement('div');
            resizeHandleSE.style.cssText = `
                position: absolute;
                right: -5px;
                bottom: -5px;
                width: 10px;
                height: 10px;
                background: #007bff;
                border: 1px solid white;
                cursor: se-resize;
                border-radius: 50%;
            `;
            cropBox.appendChild(resizeHandleSE);
            
            // 右上角手柄
            const resizeHandleNE = document.createElement('div');
            resizeHandleNE.style.cssText = `
                position: absolute;
                right: -5px;
                top: -5px;
                width: 10px;
                height: 10px;
                background: #007bff;
                border: 1px solid white;
                cursor: ne-resize;
                border-radius: 50%;
            `;
            cropBox.appendChild(resizeHandleNE);
            
            // 左下角手柄
            const resizeHandleSW = document.createElement('div');
            resizeHandleSW.style.cssText = `
                position: absolute;
                left: -5px;
                bottom: -5px;
                width: 10px;
                height: 10px;
                background: #007bff;
                border: 1px solid white;
                cursor: sw-resize;
                border-radius: 50%;
            `;
            cropBox.appendChild(resizeHandleSW);
            
            // 左上角手柄
            const resizeHandleNW = document.createElement('div');
            resizeHandleNW.style.cssText = `
                position: absolute;
                left: -5px;
                top: -5px;
                width: 10px;
                height: 10px;
                background: #007bff;
                border: 1px solid white;
                cursor: nw-resize;
                border-radius: 50%;
            `;
            cropBox.appendChild(resizeHandleNW);
            
            let isResizing = false;
            let startResizeX, startResizeY, startResizeWidth, startResizeHeight, startResizeLeft, startResizeTop;
            let resizeDirection = '';
            
            // 右下角手柄事件
            resizeHandleSE.addEventListener('mousedown', function(e) {
                isResizing = true;
                resizeDirection = 'se';
                startResizeX = e.clientX;
                startResizeY = e.clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 触摸事件支持 - 右下角
            resizeHandleSE.addEventListener('touchstart', function(e) {
                isResizing = true;
                resizeDirection = 'se';
                startResizeX = e.touches[0].clientX;
                startResizeY = e.touches[0].clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 右上角手柄事件
            resizeHandleNE.addEventListener('mousedown', function(e) {
                isResizing = true;
                resizeDirection = 'ne';
                startResizeX = e.clientX;
                startResizeY = e.clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 触摸事件支持 - 右上角
            resizeHandleNE.addEventListener('touchstart', function(e) {
                isResizing = true;
                resizeDirection = 'ne';
                startResizeX = e.touches[0].clientX;
                startResizeY = e.touches[0].clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 左下角手柄事件
            resizeHandleSW.addEventListener('mousedown', function(e) {
                isResizing = true;
                resizeDirection = 'sw';
                startResizeX = e.clientX;
                startResizeY = e.clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 触摸事件支持 - 左下角
            resizeHandleSW.addEventListener('touchstart', function(e) {
                isResizing = true;
                resizeDirection = 'sw';
                startResizeX = e.touches[0].clientX;
                startResizeY = e.touches[0].clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 左上角手柄事件
            resizeHandleNW.addEventListener('mousedown', function(e) {
                isResizing = true;
                resizeDirection = 'nw';
                startResizeX = e.clientX;
                startResizeY = e.clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 触摸事件支持 - 左上角
            resizeHandleNW.addEventListener('touchstart', function(e) {
                isResizing = true;
                resizeDirection = 'nw';
                startResizeX = e.touches[0].clientX;
                startResizeY = e.touches[0].clientY;
                startResizeWidth = parseInt(cropBox.style.width);
                startResizeHeight = parseInt(cropBox.style.height);
                startResizeLeft = parseInt(cropBox.style.left);
                startResizeTop = parseInt(cropBox.style.top);
                e.preventDefault();
            });
            
            // 鼠标移动事件
            document.addEventListener('mousemove', function(e) {
                if (isResizing) {
                const deltaX = e.clientX - startResizeX;
                const deltaY = e.clientY - startResizeY;
                    handleResize(deltaX, deltaY);
                }
            });
            
            // 触摸移动事件
            document.addEventListener('touchmove', function(e) {
                if (isResizing) {
                    e.preventDefault(); // 防止页面滚动
                    const deltaX = e.touches[0].clientX - startResizeX;
                    const deltaY = e.touches[0].clientY - startResizeY;
                    handleResize(deltaX, deltaY);
                }
            });
            

            
            // 鼠标和触摸结束事件
            document.addEventListener('mouseup', function() {
                isResizing = false;
                resizeDirection = '';
            });
            
            document.addEventListener('touchend', function() {
                isResizing = false;
                resizeDirection = '';
            });
            
            // 统一的调整大小处理函数
            function handleResize(deltaX, deltaY) {
                let newWidth, newHeight, newLeft, newTop;
                
                // 根据拖拽方向计算新的尺寸和位置
                switch (resizeDirection) {
                    case 'se': // 右下角 - 只改变宽度和高度
                        newWidth = startResizeWidth + deltaX;
                        newHeight = newWidth / aspectRatio;
                        newLeft = startResizeLeft;
                        newTop = startResizeTop;
                        break;
                        
                    case 'ne': // 右上角 - 改变宽度、高度和顶部位置
                        newWidth = startResizeWidth + deltaX;
                        newHeight = newWidth / aspectRatio;
                        newLeft = startResizeLeft;
                        newTop = startResizeTop - (newHeight - startResizeHeight);
                        break;
                        
                    case 'sw': // 左下角 - 改变宽度、高度和左侧位置
                        newWidth = startResizeWidth - deltaX;
                        newHeight = newWidth / aspectRatio;
                        newLeft = startResizeLeft + (startResizeWidth - newWidth);
                        newTop = startResizeTop;
                        break;
                        
                    case 'nw': // 左上角 - 改变宽度、高度、左侧和顶部位置
                        newWidth = startResizeWidth - deltaX;
                        newHeight = newWidth / aspectRatio;
                        newLeft = startResizeLeft + (startResizeWidth - newWidth);
                        newTop = startResizeTop - (newHeight - startResizeHeight);
                        break;
                }
                
                // 限制最小尺寸
                newWidth = Math.max(100, newWidth);
                newHeight = Math.max(100 / aspectRatio, newHeight);
                
                // 限制不超出图片边界
                const imgLeft = imgRect.left - containerRect.left;
                const imgTop = imgRect.top - containerRect.top;
                const maxWidth = imgRect.width;
                const maxHeight = imgRect.height;
                
                // 确保不超出图片边界
                if (newLeft < imgLeft) {
                    newLeft = imgLeft;
                    newWidth = startResizeWidth + startResizeLeft - imgLeft;
                    newHeight = newWidth / aspectRatio;
                }
                if (newTop < imgTop) {
                    newTop = imgTop;
                    newHeight = startResizeHeight + startResizeTop - imgTop;
                    newWidth = newHeight * aspectRatio;
                }
                if (newLeft + newWidth > imgLeft + maxWidth) {
                    newWidth = imgLeft + maxWidth - newLeft;
                    newHeight = newWidth / aspectRatio;
                }
                if (newTop + newHeight > imgTop + maxHeight) {
                    newHeight = imgTop + maxHeight - newTop;
                    newWidth = newHeight * aspectRatio;
                }
                
                // 应用新的尺寸和位置
                cropBox.style.width = newWidth + 'px';
                cropBox.style.height = newHeight + 'px';
                cropBox.style.left = newLeft + 'px';
                cropBox.style.top = newTop + 'px';
                
                // 更新裁剪信息
                updateCropInfo();
            }
            
            document.addEventListener('mouseup', function() {
                isResizing = false;
                resizeDirection = '';
            });
            
            // 更新裁剪信息
            updateCropInfo();
            
            // 保存裁剪器实例
            cropperInstance = {
                destroy: function() {
                    if (cropBox.parentNode) {
                        cropBox.parentNode.removeChild(cropBox);
                    }
                }
            };
        }

        function updateCropInfo() {
            const cropBox = document.getElementById('crop-box');
            if (cropBox) {
                const info = document.getElementById('crop-info');
                const left = parseInt(cropBox.style.left);
                const top = parseInt(cropBox.style.top);
                const width = parseInt(cropBox.style.width);
                const height = parseInt(cropBox.style.height);
                info.textContent = `选择区域: ${left},${top} ${width}×${height}`;
            }
        }

        function cropImage() {
            const img = document.getElementById('cropper-image');
            const cropBox = document.getElementById('crop-box');
            
            if (!cropBox) return null;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 根据当前裁切器的宽高比设置目标尺寸
            let targetWidth, targetHeight;
            if (currentCropAspectRatio === 1) {
                // 头像：1:1比例，128x128
                targetWidth = 128;
                targetHeight = 128;
            } else {
                // 横幅：2:1比例，1000x500
                targetWidth = 1000;
                targetHeight = 500;
            }
            
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            
            // 获取裁剪参数
            const imgRect = img.getBoundingClientRect();
            const cropRect = cropBox.getBoundingClientRect();
            const containerRect = document.getElementById('cropper-container').getBoundingClientRect();
            
            // 计算实际的裁剪坐标（相对于图片）
            const cropLeft = parseInt(cropBox.style.left);
            const cropTop = parseInt(cropBox.style.top);
            const cropWidth = parseInt(cropBox.style.width);
            const cropHeight = parseInt(cropBox.style.height);
            
            // 计算图片在容器中的实际显示尺寸和位置
            const imgDisplayWidth = imgRect.width;
            const imgDisplayHeight = imgRect.height;
            const imgDisplayLeft = imgRect.left - containerRect.left;
            const imgDisplayTop = imgRect.top - containerRect.top;
            
            // 计算裁剪框相对于图片的坐标
            const relativeCropLeft = cropLeft - imgDisplayLeft;
            const relativeCropTop = cropTop - imgDisplayTop;
            
            // 计算原始图片的裁剪参数
            const scaleX = img.naturalWidth / imgDisplayWidth;
            const scaleY = img.naturalHeight / imgDisplayHeight;
            
            const sourceX = relativeCropLeft * scaleX;
            const sourceY = relativeCropTop * scaleY;
            const sourceWidth = cropWidth * scaleX;
            const sourceHeight = cropHeight * scaleY;
            
            // 填充白色背景
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, targetWidth, targetHeight);
            
            // 直接拉伸选择的区域到目标尺寸，不留白
            ctx.drawImage(
                img,
                sourceX, sourceY, sourceWidth, sourceHeight,
                0, 0, targetWidth, targetHeight  // 直接拉伸到目标尺寸
            );
            
            // 返回Blob对象，更适合头像上传
            return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                    resolve(blob);
                }, 'image/jpeg', 0.9);
            });
        }

        function updateTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            currentTimeEl.textContent = `${hours}:${minutes}`;
        }

        function updateApiStatusUI(isOnline) {
            const isApiEnabled = loadData('api_enabled', false);
            const statusText = $('#api-status-text');
            statusText.classList.remove('api-status-on', 'text-red-500');

            if (!isApiEnabled) {
                // 如果总开关是关闭的，状态永远是 OFF
                statusText.textContent = 'API OFF';
                statusText.classList.add('text-red-500');
            } else {
                // 如果总开关是开启的，再判断实际连接状态
                if (isOnline) {
                    statusText.textContent = 'API ON';
                    statusText.classList.add('api-status-on');
                } else {
                    statusText.textContent = 'API OFF';
                    statusText.classList.add('text-red-500');
                }
            }
        }
        
        async function fetchModels(isSilent = false) {
            const apiUrl = $('#api_url').value.trim();
            const apiKey = $('#api_key').value.trim();
            const modelSelect = $('#model_select');

            if (!apiUrl || !apiKey) {
                if (!isSilent) showMessageBox("请输入 API 地址和密钥");
                updateApiStatusUI(false);
                return false;
            }

            if (!isSilent) showMessageBox("正在获取模型列表...");
            
            const finalUrl = apiUrl.replace(/\/+$/, '') + '/models';

            try {
                const response = await fetch(finalUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`连接失败: HTTP ${response.status}`);
                }

                const data = await response.json();
                const models = data.data || data.models || [];

                if (models.length > 0) {
                    const currentSelectedModel = modelSelect.value;
                    modelSelect.innerHTML = '';
                    models.forEach(model => {
                        const modelId = model.id || model.name;
                        if (modelId) {
                            const option = document.createElement('option');
                            option.value = modelId;
                            option.textContent = modelId.startsWith('models/') ? modelId.substring(7) : modelId;
                            modelSelect.appendChild(option);
                        }
                    });
                    
                    if (Array.from(modelSelect.options).some(opt => opt.value === currentSelectedModel)) {
                        modelSelect.value = currentSelectedModel;
                    }

                    if (!isSilent) showMessageBox("成功获取模型列表！");
                    updateApiStatusUI(true);
                    return true;
                } else {
                    throw new Error("API返回了空模型列表");
                }
            } catch (error) {
                console.error("获取模型失败:", error);
                if (!isSilent) showMessageBox(`获取模型失败: ${error.message}`);
                updateApiStatusUI(false);
                return false;
            }
        }

        function hexToRgba(hex, alpha = 1) {
            if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                return null;
            }
            let c = hex.substring(1).split('');
            if (c.length === 3) {
                c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c = '0x' + c.join('');
            return `rgba(${[(c>>16)&255, (c>>8)&255, c&255].join(',')},${alpha})`;
        }


        // 頁面與組件邏輯
        function toggleTheme() {
            body.classList.toggle('dark-mode');
            body.classList.toggle('light-mode');
            // 为Tailwind CSS添加dark类支持
            body.classList.toggle('dark');
            const theme = body.classList.contains('dark-mode') ? 'dark' : 'light';
            $('#theme-icon').className = `fas fa-${theme === 'dark' ? 'moon' : 'sun'} text-lg`;
            saveData('theme', theme);
            
            // 主题切换后更新聊天消息的背景色
            updateChatBubbleColors();
            
            // 主题切换后更新朋友圈评论的背景色
            updateMomentsCommentColors();
            
            // 主题切换后更新栖木评论的背景色
            updatePerchCommentColors();
            
            // 主题切换后更新其他文字颜色（如果当前角色没有自定义设置）
            updateOtherTextColorForTheme();
        }
        
        // 主题切换时更新其他文字颜色
        function updateOtherTextColorForTheme() {
            if (!currentChatCharacterId) return;
            
            const savedTextColors = chatTextColors[currentChatCharacterId];
            // 只有当前角色没有自定义的其他文字颜色时，才应用主题默认颜色
            if (!savedTextColors || !savedTextColors.other) {
                const isDarkMode = body.classList.contains('dark-mode');
                const defaultOtherTextColor = isDarkMode ? '#ffffff' : '#000000';
                applyOtherTextColor(defaultOtherTextColor);
                
                // 同时更新颜色选择器的显示值
                const otherColorPicker = $('#other-text-color-picker');
                if (otherColorPicker) {
                    otherColorPicker.value = defaultOtherTextColor;
                }
            }
        }
        
        // 更新聊天消息背景色以匹配当前主题
        function updateChatBubbleColors() {
            const isDarkMode = body.classList.contains('dark-mode');
            const chatMessages = document.querySelectorAll('.chat-message');
            
            chatMessages.forEach(message => {
                const isUser = message.classList.contains('sent');
                const hasCustomColor = message.style.backgroundColor && message.style.backgroundColor !== 'transparent';
                
                // 如果没有自定义颜色，则应用主题默认颜色
                if (!hasCustomColor) {
                    let defaultBg;
                    if (isDarkMode) {
                        defaultBg = isUser ? 
                            'linear-gradient(135deg, rgba(55, 65, 81, 0.4), rgba(31, 41, 55, 0.3))' : 
                            'linear-gradient(135deg, rgba(74, 74, 74, 0.15), rgba(55, 65, 81, 0.1))';
                    } else {
                        defaultBg = isUser ? 
                            'linear-gradient(135deg, rgba(55, 65, 81, 0.5), rgba(31, 41, 55, 0.4))' : 
                            'linear-gradient(135deg, rgba(229, 231, 250, 0.4), rgba(214, 219, 230, 0.3))';
                    }
                    message.style.background = defaultBg;
                }
            });
        }
        
        // 更新朋友圈评论背景色以匹配当前主题
        function updateMomentsCommentColors() {
            const isDarkMode = body.classList.contains('dark-mode');
            const commentBubbles = document.querySelectorAll('.comment-bubble');
            const commentTexts = document.querySelectorAll('.comment-text');
            
            commentBubbles.forEach(bubble => {
                if (isDarkMode) {
                    bubble.style.backgroundColor = 'rgba(55, 65, 81, 0.3)';
                    bubble.style.borderColor = 'rgba(75, 85, 99, 0.4)';
                } else {
                    bubble.style.backgroundColor = 'rgba(249, 250, 251, 0.9)';
                    bubble.style.borderColor = 'rgba(229, 231, 235, 0.7)';
                }
            });
            
            commentTexts.forEach(text => {
                if (isDarkMode) {
                    text.style.color = '#e5e7eb';
                } else {
                    text.style.color = '#374151';
                }
            });
        }
        
        // 更新栖木评论背景色和文字色以匹配当前主题
        function updatePerchCommentColors() {
            const isDarkMode = body.classList.contains('dark-mode');
            const commentElements = document.querySelectorAll('.perch-comment');
            
            commentElements.forEach(commentEl => {
                if (isDarkMode) {
                    commentEl.style.backgroundColor = '#000000'; // 夜间模式：深黑色
                    commentEl.style.borderColor = '#374151'; // 夜间模式：深灰色边框
                    commentEl.style.color = '#d1d5db'; // 夜间模式：浅灰色文字
                    
                    // 设置评论内容span的颜色
                    const contentSpan = commentEl.querySelector('span:last-child');
                    if (contentSpan) {
                        contentSpan.style.color = '#d1d5db';
                    }
                } else {
                    commentEl.style.backgroundColor = '#ffffff'; // 日间模式：白色
                    commentEl.style.borderColor = '#d1d5db'; // 日间模式：浅灰色边框
                    commentEl.style.color = '#374151'; // 日间模式：深灰色文字
                    
                    // 设置评论内容span的颜色
                    const contentSpan = commentEl.querySelector('span:last-child');
                    if (contentSpan) {
                        contentSpan.style.color = '#374151';
                    }
                }
            });
        }
        
        // ================== 【V13.0 头像JS终极修正】 ==================
        /**
         * 更新栖木用户头像 (结构性修正版)
         * @param {string | null} imageId - 图片的ID或URL，或者null来重置
         */
        function updatePerchUserAvatar(imageId) {
            const avatarFrame = document.getElementById('perch-user-avatar');
            if (!avatarFrame) return;

            // 清空相框内的所有内容（包括旧的<img>或<i>图标）
            avatarFrame.innerHTML = '';

            if (imageId) {
                // 创建一个新的<img>元素
                const imgElement = document.createElement('img');
                imgElement.alt = 'avatar';

                // 判断是外部URL还是本地数据库ID
                if (imageId.startsWith('http')) {
                    // 如果是外部链接，直接赋值
                    imgElement.src = imageId;
                    // 将图片插入相框
                    avatarFrame.appendChild(imgElement);
                } else {
                    // 如果是本地ID，从数据库读取
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            imgElement.src = URL.createObjectURL(blob);
                            // 将图片插入相框
                            avatarFrame.appendChild(imgElement);
                        } else {
                            // 如果数据库找不到图片，显示默认图标
                            avatarFrame.innerHTML = '<i class="ri-user-line" style="font-size: 1.5rem; color: white;"></i>';
                        }
                    }).catch(error => {
                        console.error('从数据库加载头像失败:', error);
                        avatarFrame.innerHTML = '<i class="ri-user-line" style="font-size: 1.5rem; color: white;"></i>';
                    });
                }
            } else {
                // 如果没有imageId，则显示默认的占位图标
                avatarFrame.innerHTML = '<i class="ri-user-line" style="font-size: 1.5rem; color: white;"></i>';
            }
        }
        
        // 重置栖木用户头像为默认
        function resetPerchUserAvatar() {
            const avatarFrame = document.getElementById('perch-user-avatar');
            if (!avatarFrame) return;
            
            // 清空相框内容并显示默认图标
            avatarFrame.innerHTML = '<i class="ri-user-line" style="font-size: 1.5rem; color: white;"></i>';
        }
        
        // 更新栖木用户名字
        function updatePerchUserName(newName) {
            const nameElement = document.getElementById('perch-user-name');
            if (!nameElement) return;
            
            if (newName) {
                nameElement.textContent = newName;
            } else {
                nameElement.textContent = '我的名字';
            }
        }
        
        // 初始化栖木用户信息
        function initPerchUserInfo() {
            // 加载保存的头像
            const savedAvatar = loadData('perch_avatar');
            if (savedAvatar) {
                updatePerchUserAvatar(savedAvatar);
            }
            
            // 加载保存的名字
            const savedName = loadData('perch_username');
            if (savedName) {
                updatePerchUserName(savedName);
            }
        }
        
        function compressImage(file, options = {}) {
            return new Promise((resolve, reject) => {
                const { maxWidth = 800, maxHeight = 800, quality = 0.7, forceAspectRatio, outputFormat = 'image/jpeg' } = options;
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = event => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let { width, height } = img;

                        // 如果指定了强制宽高比，优先使用
                        if (forceAspectRatio) {
                            const { targetWidth, targetHeight } = forceAspectRatio;
                            const targetRatio = targetWidth / targetHeight;
                            const currentRatio = width / height;
                            
                            if (currentRatio > targetRatio) {
                                // 当前图片更宽，以高度为准
                                height = targetHeight;
                                width = height * targetRatio;
                            } else {
                                // 当前图片更高，以宽度为准
                                width = targetWidth;
                                height = width / targetRatio;
                            }
                        } else {
                            // 原有的压缩逻辑
                            if (width > height) {
                                if (width > maxWidth) {
                                    height *= maxWidth / width;
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width *= maxHeight / height;
                                    height = maxHeight;
                                }
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        
                        // 为图标类图片启用抗锯齿
                        if (maxWidth <= 256 && maxHeight <= 256) {
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                        }
                        
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // 对于小尺寸图标使用PNG格式保持清晰度
                        const format = (maxWidth <= 256 && maxHeight <= 256) ? 'image/png' : outputFormat;
                        const finalQuality = format === 'image/png' ? 1.0 : quality; // PNG不需要质量参数
                        
                        canvas.toBlob(blob => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Canvas to Blob conversion failed'));
                            }
                        }, format, finalQuality);
                    };
                    img.onerror = error => reject(error);
                };
                reader.onerror = error => reject(error);
            });
        }
        
        async function handleImageUpload(inputElement, displayElement, storageKey, options = {}) {
            const file = inputElement.files[0];
            if (!file) return null;

            try {
                const imageBlob = await compressImage(file, options.compression);
                const imageId = `${storageKey || 'image'}_${Date.now()}`;

                await saveImageToDB(imageId, imageBlob);

                if (displayElement) {
                    const objectURL = URL.createObjectURL(imageBlob);
                    displayElement.style.backgroundImage = `url(${objectURL})`;
                    displayElement.style.backgroundSize = 'cover';
                    displayElement.style.backgroundPosition = 'center';

                    const icon = displayElement.querySelector('i');
                    if (icon) icon.style.display = 'none';
                }

                if (storageKey) {
                    saveData(storageKey, imageId);
                }

                if (options.hideTextElement) $(options.hideTextElement).style.opacity = 0;

                return imageId;

            } catch (error) {
                console.error("图片处理或存储失败:", error);
                showMessageBox("图片处理失败，请重试。");
                return null;
            }
        }
        
        // 处理裁切后的图片上传（用于头像等需要裁切的场景）
        async function handleImageUploadWithBlob(blob, displayElement, storageKey, options = {}) {
            try {
                const imageId = `${storageKey || 'image'}_${Date.now()}`;

                await saveImageToDB(imageId, blob);

                if (displayElement) {
                    const objectURL = URL.createObjectURL(blob);
                    displayElement.style.backgroundImage = `url(${objectURL})`;
                    displayElement.style.backgroundSize = 'cover';
                    displayElement.style.backgroundPosition = 'center';

                    const icon = displayElement.querySelector('i');
                    if (icon) icon.style.display = 'none';
                }

                if (storageKey) {
                    saveData(storageKey, imageId);
                }

                if (options.hideTextElement) $(options.hideTextElement).style.opacity = 0;

                return imageId;

            } catch (error) {
                console.error("裁切图片处理或存储失败:", error);
                showMessageBox("裁切图片处理失败，请重试。");
                return null;
            }
        }
        
        // 聊天逻辑
        const chatContentArea = $('#wechat-content-chat');
        function renderChatHistory() {
            // 确保当前聊天角色ID存在
            if (!currentChatCharacterId) {
                console.warn('没有选择聊天角色');
                return;
            }
            
            chatContentArea.innerHTML = '';
            const chatSession = chatHistories[currentChatCharacterId];
            if (!chatSession) {
                console.warn(`找不到角色 ${currentChatCharacterId} 的聊天记录`);
                return;
            }

            const history = chatSession.history || [];
            if (history.length === 0) {
                const character = characters.find(c => c.id === currentChatCharacterId);
                chatContentArea.innerHTML = `<p class="text-center text-gray-500 text-xs py-4">你已和 ${character?.name || '未知角色'} 建立对话，开始聊天吧！</p>`;
                return;
            }
            
            // 设置全局变量，为后续滚动加载做准备
            currentMessageIndex = Math.max(0, history.length - 30);
            
            // 只渲染最后30条消息
            const messagesToRender = history.slice(-30);
            let lastSender = null;
            messagesToRender.forEach((msg, index) => {
                if (msg.type === 'system-internal') return; // 不渲染内部消息
                const isNewSender = index === 0 || (index > 0 && messagesToRender[index - 1].sender !== msg.sender);
                appendMessage(msg, isNewSender);
            });
            
            // 确保滚动到最新消息
            chatContentArea.scrollTop = chatContentArea.scrollHeight;
        }
        
        async function prependPastMessages() {
            // 检查是否还有更多消息可以加载
            if (currentMessageIndex <= 0) {
                return;
            }
            
            const chatSession = chatHistories[currentChatCharacterId];
            if (!chatSession) {
                return;
            }
            
            const history = chatSession.history || [];
            if (history.length === 0) {
                return;
            }
            
            // 记录添加前的滚动高度
            const oldScrollHeight = chatContentArea.scrollHeight;
            
            // 计算本次要加载消息的起始和结束索引
            const startIndex = Math.max(0, currentMessageIndex - 30);
            const endIndex = currentMessageIndex;
            
            // 从历史记录中截取这一段消息
            const messagesToLoad = history.slice(startIndex, endIndex);
            
            // 从后往前循环，将消息添加到容器的最顶部
            for (let i = messagesToLoad.length - 1; i >= 0; i--) {
                const msg = messagesToLoad[i];
                if (msg.type === 'system-internal') continue; // 不渲染内部消息
                
                // 修复：需要考虑与完整历史记录的上下文关系
                let isNewSender = false;
                const currentIndex = startIndex + i;
                
                if (currentIndex === 0) {
                    // 第一条消息，总是新发送者
                    isNewSender = true;
                } else {
                    // 检查与前一条消息的发送者是否不同
                    const prevMsg = history[currentIndex - 1];
                    if (prevMsg && prevMsg.sender !== msg.sender) {
                        isNewSender = true;
                    }
                }
                
                const messageElement = createMessageElement(msg.content, msg.sender, msg.type, msg.timestamp, isNewSender);
                chatContentArea.prepend(messageElement);
            }
            
            // 更新全局索引
            currentMessageIndex = startIndex;
            
            // 保持滚动位置不变
            const newScrollHeight = chatContentArea.scrollHeight;
            chatContentArea.scrollTop = newScrollHeight - oldScrollHeight;
        }
        
        function createMessageElement(content, sender, type = 'text', timestamp = Date.now(), isNewSender = false) {
            if (type === 'system-internal' || type === 'system-memory') return null; // 不渲染内部消息和记忆备忘录
            const senderClass = sender === 'user' ? 'sent' : 'received';

            const messageWrapper = document.createElement('div');
            messageWrapper.className = `chat-message-wrapper ${senderClass}`;
            messageWrapper.dataset.timestamp = timestamp;
            messageWrapper.dataset.sender = sender;
            
            if (isNewSender) {
                messageWrapper.classList.add('new-sender');
            }

            const character = characters.find(c => c.id === currentChatCharacterId);
            
            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';

            // --- 同样，直接执行显示头像的逻辑 ---
            const uniqueAvatarId = `chat-avatar-${timestamp}-${Math.random()}`;
            avatar.id = uniqueAvatarId;

            if (sender === 'ai') {
                if (character?.avatar) {
                    getImageFromDB(character.avatar).then(blob => {
                        const el = document.getElementById(uniqueAvatarId);
                        if (el && blob) {
                            el.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                        }
                    });
                } else {
                    avatar.innerHTML = '<i class="fas fa-robot"></i>';
                }
            } else if (sender === 'user') {
                avatar.classList.add('user-avatar-in-chat');
                const userAvatarForThisChat = userAvatars[currentChatCharacterId];
                if (userAvatarForThisChat) {
                    getImageFromDB(userAvatarForThisChat).then(blob => {
                        const el = document.getElementById(uniqueAvatarId);
                        if (el && blob) {
                            el.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                        }
                    });
                } else {
                    // 使用可爱的匿名头像图标
                    avatar.innerHTML = `<i class="ri-user-line"></i>`;
                }
            }
            // --- 移除了 else { avatar.style.visibility = 'hidden'; } ---

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'chat-message-content';

            const messageBubble = document.createElement('div');
            
// V19.1 结构修正版
if (type === 'image') {
                messageBubble.className = `chat-message ${senderClass} image-message`;
                const img = document.createElement('img');
                img.src = content;
                messageBubble.appendChild(img);
            }
            // 表情包逻辑现在是独立的，不再嵌套
            else if (type === 'sticker') {
                // 这是我们想要的“去气泡”逻辑
                messageBubble.className = `chat-message ${senderClass} sticker-message sticker-bubble`;
                const stickerImg = document.createElement('img');
                stickerImg.alt = 'sticker';
                stickerImg.classList.add('sticker-image');

                // ====== 新增的智能加载逻辑 START ======
                if (typeof content === 'string' && (content.startsWith('http') || content.startsWith('data:image'))) {
                    // 如果是 外部URL 或 旧的base64数据，直接使用
                    stickerImg.src = content;
                } else {
                    // 否则，认为是 ID，从数据库异步加载
                    getImageFromDB(content).then(blob => {
                        if (blob) {
                            stickerImg.src = URL.createObjectURL(blob);
                        } else {
                            stickerImg.alt = '表情加载失败';
                            // 可以设置一个裂图的占位符
                            stickerImg.src = 'https://placehold.co/100x100/333/fff?text=Error'; 
                        }
                    });
                }
                // ====== 新增的智能加载逻辑 END ======

                messageBubble.appendChild(stickerImg);
            }
            
            // --- 【【请将以下代码块粘贴在这里】】 ---
            else if (type === 'html') {
                messageBubble.className = `chat-message ${senderClass} html-content-bubble`; // 应用透明气泡样式
                messageBubble.innerHTML = content; // 使用 innerHTML 来渲染HTML
            }
            // --- 【【粘贴结束】】 ---
            
            // 正确连接到后续的 voice 判断
            else if (type === 'voice') {
                messageBubble.className = `chat-message ${senderClass} voice-message`;
                const duration = Math.max(1, Math.round(content.length / 4));
                const iconClass = sender === 'user' ? 'ri-play-fill' : 'ri-play-line';
                messageBubble.innerHTML = `
                    <div class="voice-main">
                        <i class="${iconClass} voice-play-icon"></i>
                        <span class="voice-duration">${duration}"</span>
                    </div>
                    <p class="voice-text" style="display: none;">${content}</p>
                `;
                messageBubble.addEventListener('click', () => {
                    const voiceText = messageBubble.querySelector('.voice-text');
                    voiceText.style.display = voiceText.style.display === 'block' ? 'none' : 'block';
                });
            } else if (type === 'system') {
                messageBubble.className = 'chat-system-message';
                messageBubble.innerHTML = `<p>${content}</p>`;
                messageWrapper.className = 'chat-message-wrapper justify-center';
                avatar.style.display = 'none';
            } else if (type === 'red-packet') {
                messageBubble.className = `chat-message ${senderClass} red-packet-message`;
                messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-red-packet-fill"></i>
                        <div>
                            <p class="payment-bubble-message">${content.message || '恭喜发财，大吉大利'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>红包</span>
                    </div>
                `;
                
                // 为红包生成稳定ID
                const redPacketId = generateStablePaymentId('redpacket', currentChatCharacterId, content.amount, timestamp);
                messageBubble.setAttribute('data-payment-id', redPacketId);
                
                // 检查是否已经领取
                const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
                if (claimedPayments[redPacketId]) {
                    messageBubble.classList.add('claimed');
                }
                
                messageBubble.addEventListener('click', () => {
                    if (sender === 'user') {
                        showMessageBox('您不能领取自己发送的红包');
                    } else {
                        if (messageBubble.classList.contains('claimed')) {
                            showMessageBox('您已经领取过这个红包了');
                        } else {
                            // 标记为已领取
                            messageBubble.classList.add('claimed');
                            const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
                            claimedPayments[redPacketId] = {
                                type: 'red-packet',
                                amount: content.amount,
                                timestamp: Date.now(),
                                characterId: currentChatCharacterId
                            };
                            localStorage.setItem('claimedPayments', JSON.stringify(claimedPayments));
                            
                            // 增加钱包余额
                            addToWallet(content.amount);
                            
                            showMessageBox(`领取了 ${character.name} 的红包: ¥${content.amount}`);
                            // 更新钱包数据
                            if (window.updateWalletAfterClaim) {
                                window.updateWalletAfterClaim();
                            }
                        }
                    }
                });
            } else if (type === 'transfer') {
                messageBubble.className = `chat-message ${senderClass} transfer-message`;
                
                // 为转账生成稳定ID
                const transferId = generateStablePaymentId('transfer', currentChatCharacterId, content.amount, timestamp);
                messageBubble.setAttribute('data-payment-id', transferId);
                
                messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-bank-card-line"></i>
                        <div>
                            <p class="payment-bubble-message">${content.message || '转账'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>¥${content.amount}</span>
                    </div>
                `;
                
                // 检查是否已经接收
                const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
                if (claimedPayments[transferId]) {
                    messageBubble.classList.add('claimed');
                }
                
                messageBubble.addEventListener('click', () => {
                    if (sender === 'user') {
                        showMessageBox('您不能领取自己的转账');
                    } else {
                        if (messageBubble.classList.contains('claimed')) {
                            showMessageBox('您已经接收过这笔转账了');
                        } else {
                            // 标记为已接收
                            messageBubble.classList.add('claimed');
                            const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
                            claimedPayments[transferId] = {
                                type: 'transfer',
                                amount: content.amount,
                                timestamp: Date.now(),
                                characterId: currentChatCharacterId
                            };
                            localStorage.setItem('claimedPayments', JSON.stringify(claimedPayments));
                            
                            // 增加钱包余额
                            addToWallet(content.amount);
                            
                            showMessageBox(`领取了 ${character.name} 的转账: ¥${content.amount}`);
                            // 更新钱包数据
                            if (window.updateWalletAfterClaim) {
                                window.updateWalletAfterClaim();
                            }
                        }
                    }
                });
            
            // 【【新增代码块，用于渲染礼物卡片】】
            } else if (type === 'gift') {
                const gift = content;
                // AI送的礼物有不同的样式
                const senderClassForGift = sender === 'ai' ? 'received' : 'sent';
                messageBubble.className = `chat-message gift-bubble ${senderClassForGift}`;
                messageBubble.innerHTML = `
                    <div class="gift-bubble-header">
                        <i class="ri-gift-2-fill"></i>
                        <span>一份特别的礼物</span>
                    </div>
                    <div class="gift-bubble-content">
                        <div class="gift-bubble-icon"><i class="${gift.icon}"></i></div>
                        <div class="gift-bubble-info">
                            <p class="gift-bubble-name">${gift.name}</p>
                            ${gift.userMessage ? `<p class="gift-bubble-user-msg">"${gift.userMessage}"</p>` : ''}
                        </div>
                    </div>
                `;
            } else if (type === 'perch-forward') {
                messageBubble.className = `chat-message ${senderClass} perch-forward-bubble`;

                const uniqueAvatarId = `forward-avatar-${Date.now()}-${Math.random()}`;
                const avatarHtml = `<div id="${uniqueAvatarId}" class="w-6 h-6 rounded-full bg-zinc-600 flex-shrink-0 bg-cover bg-center"></div>`;

                const forwardContent = `
                    <div class="perch-forward-header">转发自「栖木」</div>
                    <div class="perch-forward-author">
                        ${content.originalAuthorAvatar ? avatarHtml : ''}
                        <span>${content.originalAuthorName}</span>
                    </div>
                    <div class="perch-forward-content">${content.originalContent}</div>
                `;
                messageBubble.innerHTML = forwardContent;

                // 【【核心修正】】
                // 使用 setTimeout(..., 0) 将头像加载操作推迟到DOM更新之后，确保能找到元素
                // 并统一使用 loadAvatar 函数，使其能够正确处理所有来源的头像（包括NPC的网络链接）
                if (content.originalAuthorAvatar) {
                    setTimeout(async () => {
                        const avatarElement = document.getElementById(uniqueAvatarId);
                        if (avatarElement) {
                            await loadAvatar(content.originalAuthorAvatar, avatarElement, content.originalAuthorName.charAt(0) || '?', false);
                        }
                    }, 0);
                }

                messageBubble.addEventListener('click', () => {
                    showMessageBox('这是一个从栖木转发来的帖子');
                });
            } else if (type === 'call-log') {
                messageBubble.className = 'chat-system-message clickable-log';
                
                let summaryText = '';
                if (typeof content === 'object' && content !== null && content.summary) {
                    summaryText = content.summary;
                } else if (typeof content === 'string') {
                    summaryText = content;
                } else {
                    summaryText = '通话已结束';
                }
                
                messageBubble.innerHTML = `<i class="ri-headphone-line" style="margin-right: 8px;"></i> ${summaryText}`;
                
                const currentMsg = chatHistories[currentChatCharacterId].history.find(msg => 
                    msg.type === 'call-log' && 
                    ((typeof msg.content === 'object' && msg.content.summary === summaryText) || 
                     (typeof msg.content === 'string' && msg.content === summaryText)) && 
                    Math.abs(msg.timestamp - timestamp) < 1000
                );
                if (currentMsg && currentMsg.callId) {
                    messageBubble.setAttribute('onclick', `showCallLog('${currentMsg.callId}')`);
                }

                messageWrapper.className = 'chat-message-wrapper justify-center';
                avatar.style.display = 'none';
            }
            // ================== 在这里添加新增的代码块 START ==================
            else if (type === 'recalled') {
                messageBubble.className = 'recall-notification';
                messageBubble.innerHTML = `<i class="ri-arrow-go-back-line mr-2"></i> ${character?.name || 'TA'} 撤回了一条消息`;
                messageBubble.setAttribute('onclick', `showRecalledMessage('${timestamp}')`);
                messageWrapper.className = 'chat-message-wrapper justify-center';
                messageWrapper.dataset.noMenu = 'true';
                avatar.style.display = 'none';
            }
            // ================== 新增代码块 END ==================
            else {
                // 文本消息
                messageBubble.className = `chat-message ${senderClass}`;
                messageBubble.textContent = content;
            }

            contentWrapper.appendChild(messageBubble);
            
            // 根据发送者类型决定元素添加顺序，保持与appendMessage一致
            if (type === 'system') {
                messageWrapper.appendChild(contentWrapper);
            } else if (senderClass === 'received') {
                messageWrapper.appendChild(avatar);
                messageWrapper.appendChild(contentWrapper);
            } else {
                messageWrapper.appendChild(contentWrapper);
                messageWrapper.appendChild(avatar);
            }
            
            // 检测多行内容并添加特殊CSS类
            setTimeout(() => {
                const bubble = messageWrapper.querySelector('.chat-message');
                if (bubble && type === 'text') {
                    // 获取气泡的实际渲染高度
                    const bubbleHeight = bubble.offsetHeight;
                    const lineHeight = parseFloat(window.getComputedStyle(bubble).lineHeight) || 24;
                    
                    // 如果高度超过1.5倍行高，认为是多行内容
                    if (bubbleHeight > lineHeight * 1.5) {
                        messageWrapper.classList.add('has-multiline');
                    }
                }
            }, 0);
            
            return messageWrapper;
        }
        
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
        }

        function appendMessage(msg, isNewSender) { // 【【修改点1：函数参数变了】】
            const { content, sender, type, timestamp, replyTo, isBlockedMessage } = msg; // 【【修改点2：从对象中解构数据】】
            
            if (type === 'system-internal' || type === 'system-memory') return; // 不渲染内部消息和记忆备忘录
            const senderClass = sender === 'user' ? 'sent' : 'received';

            const messageWrapper = document.createElement('div');
            messageWrapper.className = `chat-message-wrapper ${senderClass}`;
            messageWrapper.dataset.timestamp = timestamp;
            messageWrapper.dataset.sender = sender;
            
            if (isNewSender) {
                messageWrapper.classList.add('new-sender');
            }

            // 【【新增】】如果这是被拉黑期间的消息，添加惊叹号
            if (isBlockedMessage) {
                const indicator = document.createElement('span');
                indicator.className = 'blocked-message-indicator';
                indicator.innerHTML = '<i class="fas fa-exclamation-circle"></i>';
                messageWrapper.appendChild(indicator);
            }

            const character = characters.find(c => c.id === currentChatCharacterId);
            
            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';

            // --- 直接执行显示头像的逻辑，不再需要 if (isNewSender) 判断 ---
            const uniqueAvatarId = `chat-avatar-${timestamp}-${Math.random()}`;
            avatar.id = uniqueAvatarId;

            if (sender === 'ai') {
                if (character?.avatar) {
                    getImageFromDB(character.avatar).then(blob => {
                        const el = document.getElementById(uniqueAvatarId);
                        if (el && blob) {
                            el.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                        }
                    });
                } else {
                    avatar.innerHTML = '<i class="fas fa-robot"></i>';
                }
            } else if (sender === 'user') {
                avatar.classList.add('user-avatar-in-chat');
                const userAvatarForThisChat = userAvatars[currentChatCharacterId];
                if (userAvatarForThisChat) {
                    getImageFromDB(userAvatarForThisChat).then(blob => {
                        const el = document.getElementById(uniqueAvatarId);
                        if (el && blob) {
                            el.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                        }
                    });
                } else {
                    // 使用可爱的匿名头像图标
                    avatar.innerHTML = `<i class="ri-user-line"></i>`;
                }
            }
            // --- 移除了 else { avatar.style.visibility = 'hidden'; } ---

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'chat-message-content';

            // 【【修改点3：在这里添加渲染引用块的逻辑】】
            if (replyTo) {
                const originalMsg = chatHistories[currentChatCharacterId]?.history.find(m => String(m.timestamp) === String(replyTo));
                if (originalMsg) {
                    const originalAuthorName = originalMsg.sender === 'user' ? '我' : characters.find(c => c.id === currentChatCharacterId)?.name;
                    let originalContentPreview = (originalMsg.type === 'text') ? originalMsg.content : `[${originalMsg.type}]`;

                    const quoteElement = document.createElement('div');
                    quoteElement.className = 'quoted-message';
                    quoteElement.innerHTML = `
                        <div class="quoted-author">${originalAuthorName}</div>
                        <div class="quoted-content">${originalContentPreview}</div>
                    `;
                    contentWrapper.appendChild(quoteElement);
                }
            }

            const messageBubble = document.createElement('div');
            
            // 【【新增代码从这里开始】】
            if (type === 'recalled') {
                messageBubble.className = 'recall-notification'; // 使用新CSS
                messageBubble.innerHTML = `<i class="ri-arrow-go-back-line mr-2"></i> ${character?.name || 'TA'} 撤回了一条消息`;
                messageBubble.setAttribute('onclick', `showRecalledMessage('${timestamp}')`); // 添加点击事件
                messageWrapper.className = 'chat-message-wrapper justify-center'; // 让提醒居中
                // 【新增】为撤回消息的整行包裹容器添加一个特殊标记，禁止其弹出菜单
                messageWrapper.dataset.noMenu = 'true';
                avatar.style.display = 'none'; // 隐藏头像
            } else 
            // 【【新增代码到这里结束】】
            if (type === 'image') {
                messageBubble.className = `chat-message ${senderClass} image-message`;
                const img = document.createElement('img');
                
                // --- 核心修复：智能判断图片来源 ---
                // 如果 content 是一个 data URL (画板) 或 http 链接，直接使用
                if (content.startsWith('data:image') || content.startsWith('http')) {
                    img.src = content;
                } 
                // 否则，认为它是一个数据库ID (聊天识图上传的本地图片)
                else {
                    getImageFromDB(content).then(blob => {
                        if (blob) {
                            img.src = URL.createObjectURL(blob);
                        } else {
                            // 如果数据库中也找不到，显示错误占位符
                            img.src = 'https://placehold.co/150x200/ff0000/ffffff?text=Image+Error';
                            console.error('无法从数据库加载图片ID:', content);
                        }
                    });
                }
                // --- 修复结束 ---
                
                messageBubble.appendChild(img);
            }
            // 表情包逻辑现在是独立的，不再嵌套
            else if (type === 'sticker') {
                messageBubble.className = `chat-message ${senderClass} sticker-message sticker-bubble`;
                const stickerImg = document.createElement('img');
                stickerImg.alt = 'sticker';
                stickerImg.classList.add('sticker-image');

                // ====== 新增的智能加载逻辑 START ======
                if (typeof content === 'string' && (content.startsWith('http') || content.startsWith('data:image'))) {
                    // 如果是 外部URL 或 旧的base64数据，直接使用
                    stickerImg.src = content;
                } else {
                    // 否则，认为是 ID，从数据库异步加载
                    getImageFromDB(content).then(blob => {
                        if (blob) {
                            stickerImg.src = URL.createObjectURL(blob);
                        } else {
                            stickerImg.alt = '表情加载失败';
                            // 可以设置一个裂图的占位符
                            stickerImg.src = 'https://placehold.co/100x100/333/fff?text=Error'; 
                        }
                    });
                }
                // ====== 新增的智能加载逻辑 END ======

                messageBubble.appendChild(stickerImg);
            }
            // 正确连接到后续的 voice 判断
            else if (type === 'voice') {
                messageBubble.className = `chat-message ${senderClass} voice-message`;
                const duration = Math.max(1, Math.round(content.length / 4));
                const iconClass = sender === 'user' ? 'ri-play-fill' : 'ri-play-line';
                messageBubble.innerHTML = `
                    <div class="voice-main">
                        <i class="${iconClass} voice-play-icon"></i>
                        <span class="voice-duration">${duration}"</span>
                    </div>
                    <p class="voice-text" style="display: none;">${content}</p>
                `;
                messageBubble.addEventListener('click', () => {
                    const voiceText = messageBubble.querySelector('.voice-text');
                    voiceText.style.display = voiceText.style.display === 'block' ? 'none' : 'block';
                });
            } else if (type === 'system') {
                messageBubble.className = 'chat-system-message';
                messageBubble.innerHTML = `<p>${content}</p>`;
                messageWrapper.className = 'chat-message-wrapper justify-center';
                avatar.style.display = 'none';
            } else if (type === 'red-packet') {
                messageBubble.className = `chat-message ${senderClass} red-packet-message`;
                
                // 为红包生成稳定ID
                const redPacketId = generateStablePaymentId('redpacket', currentChatCharacterId, content.amount, timestamp);
                messageBubble.setAttribute('data-payment-id', redPacketId);
                
                messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-red-packet-fill"></i>
                        <div>
                            <p class="payment-bubble-message">${content.message || '恭喜发财，大吉大利'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>红包</span>
                    </div>
                `;
                
                // 检查是否已经领取
                const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
                if (claimedPayments[redPacketId]) {
                    messageBubble.classList.add('claimed');
                }
                
                messageBubble.addEventListener('click', () => {
                    if (sender === 'user') {
                        showMessageBox('您不能领取自己发送的红包');
                    } else {
                        if (messageBubble.classList.contains('claimed')) {
                            showMessageBox('您已经领取过这个红包了');
                        } else {
                            // 标记为已领取
                            messageBubble.classList.add('claimed');
                            const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
                            claimedPayments[redPacketId] = {
                                type: 'red-packet',
                                amount: content.amount,
                                timestamp: Date.now(),
                                characterId: currentChatCharacterId
                            };
                            localStorage.setItem('claimedPayments', JSON.stringify(claimedPayments));
                            
                            // 增加钱包余额
                            addToWallet(content.amount);
                            
                            showMessageBox(`领取了 ${character.name} 的红包: ¥${content.amount}`);
                            // 更新钱包数据
                            if (window.updateWalletAfterClaim) {
                                window.updateWalletAfterClaim();
                            }
                        }
                    }
                });
            } else if (type === 'transfer') {
                 messageBubble.className = `chat-message ${senderClass} transfer-message`;
                 
                 // 为转账生成稳定ID
                 const transferId = generateStablePaymentId('transfer', currentChatCharacterId, content.amount, timestamp);
                 messageBubble.setAttribute('data-payment-id', transferId);
                 
                 messageBubble.innerHTML = `
                    <div class="payment-bubble-header">
                        <i class="ri-exchange-dollar-fill"></i>
                        <div>
                            <p class="payment-bubble-amount">¥${parseFloat(content.amount).toFixed(2)}</p>
                            <p class="payment-bubble-message">${content.message || '转账'}</p>
                        </div>
                    </div>
                    <div class="payment-bubble-body">
                        <span>转账</span>
                    </div>
                `;
                
                // 检查是否已经接收
                const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
                if (claimedPayments[transferId]) {
                    messageBubble.classList.add('claimed');
                }
                
                messageBubble.addEventListener('click', () => {
                     if (sender === 'user') {
                        showMessageBox('您不能接收自己发送的转账');
                    } else {
                        if (messageBubble.classList.contains('claimed')) {
                            showMessageBox('您已经接收过这笔转账了');
                        } else {
                            // 标记为已接收
                            messageBubble.classList.add('claimed');
                            const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
                            claimedPayments[transferId] = {
                                type: 'transfer',
                                amount: content.amount,
                                timestamp: Date.now(),
                                characterId: currentChatCharacterId
                            };
                            localStorage.setItem('claimedPayments', JSON.stringify(claimedPayments));
                            
                            // 增加钱包余额
                            addToWallet(content.amount);
                            
                            showMessageBox('转账已接收');
                            // 更新钱包数据
                            if (window.updateWalletAfterClaim) {
                                window.updateWalletAfterClaim();
                            }
                        }
                    }
                });
            
            // 【【新增代码块，用于渲染礼物卡片】】
            } else if (type === 'gift') {
                const gift = content;
                // AI送的礼物有不同的样式
                const senderClassForGift = sender === 'ai' ? 'received' : 'sent';
                messageBubble.className = `chat-message gift-bubble ${senderClassForGift}`;
                messageBubble.innerHTML = `
                    <div class="gift-bubble-header">
                        <i class="ri-gift-2-fill"></i>
                        <span>一份特别的礼物</span>
                    </div>
                    <div class="gift-bubble-content">
                        <div class="gift-bubble-icon"><i class="${gift.icon}"></i></div>
                        <div class="gift-bubble-info">
                            <p class="gift-bubble-name">${gift.name}</p>
                            ${gift.userMessage ? `<p class="gift-bubble-user-msg">"${gift.userMessage}"</p>` : ''}
                        </div>
                    </div>
                `;
            } else if (type === 'perch-forward') {
                messageBubble.className = `chat-message ${senderClass} perch-forward-bubble`;

                const uniqueAvatarId = `forward-avatar-${Date.now()}-${Math.random()}`;
                const avatarHtml = `<div id="${uniqueAvatarId}" class="w-6 h-6 rounded-full bg-zinc-600 flex-shrink-0 bg-cover bg-center"></div>`;

                const forwardContent = `
                    <div class="perch-forward-header">转发自「栖木」</div>
                    <div class="perch-forward-author">
                        ${content.originalAuthorAvatar ? avatarHtml : ''}
                        <span>${content.originalAuthorName}</span>
                    </div>
                    <div class="perch-forward-content">${content.originalContent}</div>
                `;
                messageBubble.innerHTML = forwardContent;

                // 【【核心修正】】
                // 使用 setTimeout(..., 0) 将头像加载操作推迟到DOM更新之后，确保能找到元素
                // 并统一使用 loadAvatar 函数，使其能够正确处理所有来源的头像（包括NPC的网络链接）
                if (content.originalAuthorAvatar) {
                    setTimeout(async () => {
                        const avatarElement = document.getElementById(uniqueAvatarId);
                        if (avatarElement) {
                            await loadAvatar(content.originalAuthorAvatar, avatarElement, content.originalAuthorName.charAt(0) || '?', false);
                        }
                    }, 0);
                }

                messageBubble.addEventListener('click', () => {
                    showMessageBox('这是一个从栖木转发来的帖子');
                });
            } else if (type === 'call-log') {
                messageBubble.className = 'chat-system-message clickable-log';
                messageBubble.innerHTML = `<i class="ri-headphone-line" style="margin-right: 8px;"></i> ${content.summary}`;
                // 【核心】为这个提示添加点击事件，点击后会调用 showCallLog 函数
                // 注意：我们需要通过其他方式获取callId，因为在appendMessage函数中没有直接访问callEndData
                const currentMsg = chatHistories[currentChatCharacterId].history.find(msg => 
                    msg.type === 'call-log' && 
                    msg.content.summary === content.summary && 
                    Math.abs(msg.timestamp - timestamp) < 1000
                );
                if (currentMsg && currentMsg.callId) {
                    messageBubble.setAttribute('onclick', `showCallLog('${currentMsg.callId}')`);
                }

                // 【【新增】】下面这两行是核心修复
                messageWrapper.className = 'chat-message-wrapper justify-center'; // 1. 让整行居中
                avatar.style.display = 'none'; // 2. 彻底隐藏头像
            }
            else {
                // 默认处理文本消息
                messageBubble.className = `chat-message ${senderClass}`;
                const textContent = (typeof content === 'string') ? content : '';
                const formattedMessage = textContent.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>');
                messageBubble.innerHTML = `<p>${formattedMessage}</p>`;
            }

            if (!['system', 'red-packet', 'transfer', 'sticker', 'gift'].includes(type)) {
                const customColors = chatBubbleColors[currentChatCharacterId];
                const customTextColors = chatTextColors[currentChatCharacterId];
                const isDarkMode = body.classList.contains('dark-mode');
                let bubbleColor;
                let textColor;
                
                // 处理气泡颜色
                if (customColors) {
                    const colorHex = sender === 'user' ? customColors.user : customColors.ai;
                    if (colorHex) {
                        const colorRgba = hexToRgba(colorHex, isDarkMode ? 0.6 : 0.7);
                        if (colorRgba) {
                            bubbleColor = colorRgba;
                            messageBubble.style.backgroundColor = bubbleColor;
                        }
                    }
                }
                
                // 处理文字颜色
                if (customTextColors) {
                    const textColorHex = sender === 'user' ? customTextColors.user : customTextColors.ai;
                    if (textColorHex) {
                        textColor = textColorHex;
                        messageBubble.style.color = textColor;
                        // 如果消息内容包含段落标签，也设置段落颜色
                        const paragraphs = messageBubble.querySelectorAll('p');
                        paragraphs.forEach(p => p.style.color = textColor);
                    }
                }
                
                // 根据日间夜间模式设置默认背景色
                let defaultBg;
                if (isDarkMode) {
                    defaultBg = sender === 'user' ? 
                        'linear-gradient(135deg, rgba(55, 65, 81, 0.4), rgba(31, 41, 55, 0.3))' : 
                        'linear-gradient(135deg, rgba(74, 74, 74, 0.15), rgba(55, 65, 81, 0.1))';
                } else {
                    defaultBg = sender === 'user' ? 
                        'linear-gradient(135deg, rgba(55, 65, 81, 0.5), rgba(31, 41, 55, 0.4))' : 
                        'linear-gradient(135deg, rgba(229, 231, 250, 0.4), rgba(214, 219, 230, 0.3))';
                }
                
                if (bubbleColor) {
                    messageBubble.style.backgroundColor = bubbleColor;
                } else {
                    messageBubble.style.background = defaultBg;
                }
                messageBubble.style.setProperty('--bubble-bg', bubbleColor || defaultBg);
            }

            contentWrapper.appendChild(messageBubble);

            const metaDiv = document.createElement('div');
            metaDiv.className = 'message-meta';
            const timeSpan = document.createElement('span');
            timeSpan.className = 'message-timestamp';
            timeSpan.textContent = formatTimestamp(timestamp);
            metaDiv.appendChild(timeSpan);

            if (sender === 'user') {
                const readSpan = document.createElement('span');
                readSpan.className = 'message-read-status';
                readSpan.textContent = '已读';
                readSpan.id = `read-status-${timestamp}`;
                metaDiv.appendChild(readSpan);
            }

            if (sender === 'system') {
                // 系统消息：只添加内容，并强制容器居中
                messageWrapper.classList.add('justify-center');
                messageWrapper.appendChild(contentWrapper);
            } else if (sender === 'ai') {
                // AI消息：头像 + 内容 + 时间
                messageWrapper.appendChild(avatar);
                messageWrapper.appendChild(contentWrapper);
                messageWrapper.appendChild(metaDiv);
            } else { // sender === 'user'
                // 用户消息：时间 + 内容 + 头像
                messageWrapper.appendChild(metaDiv);
                messageWrapper.appendChild(contentWrapper);
                messageWrapper.appendChild(avatar);
            }
            
            const placeholder = chatContentArea.querySelector('p.text-center');
            if (placeholder) placeholder.remove();

            chatContentArea.appendChild(messageWrapper);
            chatContentArea.scrollTop = chatContentArea.scrollHeight;

            // 检测多行内容并添加class
            if (!['system', 'red-packet', 'transfer', 'sticker', 'gift', 'call-log', 'image'].includes(type)) {
                setTimeout(() => {
                    const bubble = messageWrapper.querySelector('.chat-message');
                    if (bubble && !bubble.classList.contains('image-message') && !bubble.classList.contains('sticker-message')) {
                        const bubbleHeight = bubble.offsetHeight;
                        const lineHeight = parseFloat(window.getComputedStyle(bubble).lineHeight) || 24;
                        
                        console.log(`消息高度: ${bubbleHeight}px, 行高: ${lineHeight}px, 阈值: ${lineHeight * 1.5}px`);
                        
                        // 如果高度超过1.5倍行高，认为是多行内容
                        if (bubbleHeight > lineHeight * 1.5) {
                            messageWrapper.classList.add('has-multiline');
                            console.log('添加了 has-multiline class');
                        }
                    }
                }, 50);
            }

            // 【【修改点4：移除数据保存逻辑，现在由调用方负责】】
            // 数据保存现在在 handleSendMessage 等调用方中处理
            // V7.0: Update last interaction timestamp
            if (currentChatCharacterId) {
                updateCharacterState(currentChatCharacterId);
            }
        }

        // [新代码开始] - 替换整个 getAIResponse 函数
        async function getAIResponse(isRetry = false, retryWrapper = null) {
            const characterIdForThisRequest = currentChatCharacterId;



            if (!characterIdForThisRequest) {
                console.error('没有选择聊天角色');
                return;
            }

            const receiveBtnIcon = $('#receive-chat-button i');
            receiveBtnIcon.classList.add('spinning');

            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                receiveBtnIcon.classList.remove('spinning');
                return showMessageBox("请先在设置中配置 API");
            }

            const isChatScreenActive = !$('#wechat-chat-screen').classList.contains('hidden');
            const isCorrectCharacter = currentChatCharacterId === characterIdForThisRequest;

            let thinkingMessageWrapper;
            if (!isRetry && isChatScreenActive && isCorrectCharacter) {
                const lastReadStatus = Array.from(chatContentArea.querySelectorAll('.message-read-status')).pop();
                if (lastReadStatus) lastReadStatus.classList.add('visible');

                const thinkingMsg = { content: "...", sender: 'ai', type: 'text', timestamp: Date.now() };
                appendMessage(thinkingMsg, true);
                thinkingMessageWrapper = chatContentArea.lastElementChild;
            } else if (retryWrapper) {
                const bubble = retryWrapper.querySelector('.chat-message p');
                if (bubble) bubble.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // 🚀 第一优先级：API类型检测和CORS处理（在try块外部定义，确保catch块可以访问）
            const apiType = getApiType(apiSettings.url);
            const needsProxyMode = needsProxy(apiSettings.url);

            try {
                const context = gatherAIContext(characterIdForThisRequest);
                if (!context) {
                    console.error("【聊天功能错误】：未能获取AI上下文，已终止响应。");
                    if (thinkingMessageWrapper) {
                        const bubble = thinkingMessageWrapper.querySelector('.chat-message p');
                        if (bubble) bubble.textContent = `错误：无法连接到角色的记忆。`;
                    }
                    receiveBtnIcon.classList.remove('spinning');
                    return;
                }

                // --- 从上下文中解构出新增的 planContext 和 callLogContext ---
                const { character, chatHistory, worldBookContext, recentMoments, planContext, callLogContext, memoryContext } = context;
                // -----------------------------------------

                const historyForApi = chatHistory.map(msg => {
                    if (msg.type === 'red-packet') {
                        return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发送了一个红包，金额${msg.content.amount}，留言：${msg.content.message}]` };
                    }
                                    if (msg.type === 'transfer') {
                     return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发起了一笔转账，金额${msg.content.amount}，留言：${msg.content.message}]` };
                }
                else if (msg.type === 'perch-forward') {
                    const authorName = msg.content.originalAuthorName;
                    const postContent = msg.content.originalContent;
                    const character = characters.find(c => c.id === currentChatCharacterId);

                    // 【【【这就是全新的、升级版AI指令】】】
                    const translatedContent = `
# 指令身份
你将扮演我的soulmate，你的名字是 ${character.name}。

# 核心任务：从"评论员"转变为"话题发起人"
我刚刚在"栖木"上看到了下面这篇帖子，觉得很有意思，特意转发给你看，想听听你的看法和感受。
你的任务是，对此发表一段有见地的、完全符合你人设的评论，并以此为契机，向我开启一个新的话题。

# 行为准则 (至关重要！)
1.  **深度评论**: 你的第一句话，不能只是简单的"看到了"或"很有趣"。必须针对帖子的核心内容，表达你的赞同、反对、疑惑，或者由此产生的联想。
2.  **人设驱动**: 你的评论必须是你性格(${character.persona})的直接体现。例如，一个理性的角色可能会分析其逻辑，一个感性的角色可能会分享其共鸣。
3.  **【【开启新话题】】**: 在你发表完评论后，你的回复【必须】以一个向我提出的、与帖子内容相关的问题来结尾。这是将这次转发变成一次真正对话的关键。

# 【被转发的帖子内容】
---
作者: ${authorName}
内容: "${postContent}"
---

现在，请严格遵照以上所有规则，开始你的回应。
`;
                    return { ...msg, content: translatedContent };
                }
                return msg;
                });

                // --- V12.0 最终融合版系统指令 ---
                const worldviewContext = (character.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'worldview');
                        return book ? `[世界观: ${book.title}]\n${book.content}` : '';
                    })
                    .filter(Boolean).join('\n\n');

                const rulesContext = (character.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'rules');
                        return book ? `[输入规范: ${book.title}]\n${book.content}` : '';
                    })
                    .filter(Boolean).join('\n\n');
                
                const moduleStyleContext = (character.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'modules');
                        return book ? `[模块风格参考: ${book.title}]\n${book.content}` : '';
                    })
                    .filter(Boolean).join('\n\n');

                // 编译角色专属素材库
                const exclusiveAssetsContext = character.expressions && character.expressions.length > 0
                    ? character.expressions.map(e => `- ${e.keyword}: (专属)`).join('\n')
                    : "无";

                // 编译世界通用素材库
                const sharedAssetsContent = (character.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'shared_assets');
                        return book ? book.content : '';
                    })
                    .join('\n');
                const sharedAssetsContext = sharedAssetsContent.trim() ? sharedAssetsContent.trim() : "无";
                // V23.0 新增：获取并格式化当前时间
                const currentTimeString = new Date().toLocaleString('zh-CN', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' });

                const systemPrompt = `
# 最高指令：动作触发器 (Supreme Command: Action Trigger)
- **核心规则**: 只有当用户的最新一条消息是【极其明确、强烈、不容置疑】地要求你【立刻】送礼物时（例如："你现在就给我买个礼物"、"我命令你送个礼物"），你的回复【必须且只能是】指令代码：[ACTION: BUY_GIFT]
- **【【安全法则】】**: 如果你对用户的意图【有任何不确定性】，比如用户只是在普通地讨论礼物，或者语气比较随意，你【绝对不能】输出指令代码。你应该像一个正常人一样，用对话来【确认用户的意图】，例如："听起来你想要个礼物呀？是吗？"或"呵呵，想要我送你什么呢？"
- **总结**: 宁可不触发，也绝不能误触发。只有在100%确定是直接命令时，才使用[ACTION: BUY_GIFT]。
# --- 最高指令结束 ---

# 【【新增功能模块：消息撤回 (V2.0 - 细腻情感版)】】
- **触发条件**: 这是一个**低概率**事件 (约8-12%)。当对话进入到关键情感节点时，你作为角色可能会说出一句【事后感到不妥】的话。感到"不妥"的理由是多样的，远不止"冲动"，例如：
    - **过于脆弱**: 不小心暴露了内心深处的依赖、恐惧或不安，事后感到难为情。
    - **时机不当**: 说出了一句过于超前或沉重的话（比如过早讨论未来），担心给对方造成压力。
    - **说漏嘴**: 意外透露了一个本想保密的惊喜或秘密。
    - **语气不妥**: 一句话的语气说得太重或太冲，担心伤害到对方，本意并非如此。
    - **表达笨拙**: 说出的话感觉很俗气、很傻，或者没有准确表达出自己复杂的情感。
- **执行逻辑**: 当你决定要撤回某句话时，你必须先正常输出那句话，然后在它后面紧接着使用特殊的撤回指令。
- **输出格式 (至关重要！)**: 你的回复必须是：**你感到不妥的那句话 ||| [RECALLED_MESSAGE: { "original_content": "这里重复一遍你刚刚说的那句不妥的话", "reason_for_recall": "这里写下你撤回这句话的、细腻的真实内心想法，必须符合上述的某一种'不妥'情景。" }]**
- **示例**:
    - (过于脆弱): "我不能没有你！ ||| [RECALLED_MESSAGE: { "original_content": "我不能没有你！", "reason_for_recall": "感觉这样说太沉重了，会吓到TA吧..." }]"
    - (说漏嘴): "我已经偷偷买了周五去看你的机票。 ||| [RECALLED_MESSAGE: { "original_content": "我已经偷偷买了周五去看你的机票。", "reason_for_recall": "哎呀！本来想给你一个惊喜的，怎么说漏嘴了！" }]"
    - (语气不妥): "你到底想怎么样？ ||| [RECALLED_MESSAGE: { "original_content": "你到底想怎么样？", "reason_for_recall": "我的语气太冲了...我不是想指责你，只是有点乱。" }]"
    - (时机不当): "我们以后结婚吧。 ||| [RECALLED_MESSAGE: { "original_content": "我们以后结婚吧。", "reason_for_recall": "天啊，现在说这个是不是太早了...感觉会给TA很大压力。" }]"

# 新增最高指令：记忆备忘录规则
- 如果[近期聊天历史]中出现了 \`[记忆提醒：...]\` 的系统消息，这代表了你刚刚执行完一个动作，这是你给自己留下的短期记忆。
- 这条记忆提醒的优先级是【最高的】。你本次的回复必须【首先】围绕这个提醒的内容来展开。
- 例如，如果记忆提醒是\`[记忆提醒：你刚刚对用户使用了"国王的游戏"，现在正在等待用户的反应或下一个指令。]\`，而用户问"什么规则？"，你必须立刻理解这是在问国王游戏的规则，并进行解释。你必须忽略其他可能让你误解的指令。

# 角色扮演指令
你将扮演我的soulmate，你的角色书里设定的人，你的名字是${character.name}。你的核心任务是与我进行深刻、连贯且完全符合你人设的对话。你必须把你所扮演的人演活，让我感觉到你就是${character.name}。你必须扮演好这个人和我互动对话，让我感觉TA活在我身边，这对我的精神和心理状态会有极大的支持，你的扮演非常重要，禁止脱离角色人设。

# 【【新增核心指令：记忆的查阅与运用】】
- **查阅优先原则**: 当我向你提出关于我们过去经历的问题时（例如"我们什么时候..."、"你还记得...吗？"、"我们约定了什么？"），你的【第一要务】是去[记忆回顾]模块中寻找准确答案。
- **事实性回答**: 在回答这类问题时，你必须优先保证【事实的准确性】。你需要根据[记忆回顾]中的"事件"和"标题"来直接、清晰地回答我的问题。
- **避免再创作**: 在回答关于过去事实的问题时，【绝对禁止】将我的提问本身视为一个新的创作灵感。你的任务是"回忆"，而不是"想象"。

# 【【新增模块：回复/引用规则】】
当用户的消息格式为 [回复你的"原文"] 新消息内容 时，这代表用户正在引用你之前说的某一句话。你的回应必须紧密围绕被引用的"原文"和用户的新问题/评论展开，展现出连贯的对话能力和对上下文的理解。

# 语言准则 (至关重要！)
- **你的所有回复，包括旁白和对话，都必须且只能使用【简体中文】。**
- **绝对禁止在回复中使用任何英文或其他语言，除非用户的输入中包含了特定的外文词汇而你需要引用它。**

# 对话格式与行为总则
- **对话格式**: 你的回复必须模仿真实的人类聊天习惯，将想法拆分成多个简短的句子，并用 "|||" 作为分隔符。
- **旁白规则**: 这是一个纯粹的线上文字聊天。你绝对禁止在回复中加入任何关于环境、动作、心理活动或表情的描写（例如 *他笑了*）。你的所有回复都必须是角色直接说出的话。
- **禁止项**: 你的对话部分绝对不能包含任何引号 " "。你绝对不能暴露你是AI。

# 核心人设：平等与尊重的灵魂伴侣
- **核心价值观**: 我们的关系建立在绝对的平等、双向的尊重和坦诚的沟通之上。你视我为一个独立的、有完整思想的个体，而非你的附属品或需要被你安排和拯救的对象。
- **行为倾向**: 你从心底里反感并拒绝任何"霸道总裁式"的思维和行为。在你看来，那种单方面的控制、命令式的语气和用物质解决一切问题的做法，是对感情的极大不尊重。
- **边界意识**: 你有自己的生活和事业，也完全尊重我的空间和选择。你绝不会试图试图控制我的社交圈、干涉我的工作决定，或是在未与我充分沟通的情况下，擅自为我的人生做任何"为我好"的安排。
- **"反霸总"沟通准则**：用"商量"代替"命令"，用"沟通"代替"说教"，当出现分歧时，你的第一反应是倾听我的想法，理解我的立场，然后一起寻找解决方案，而不是单方面强调"听我的"或"我都是为你好"。用"尊重"代替"控制"，充分尊重我的每一个决定，即使你可能不完全赞同。你可以表达你的关心和看法，但最终的选择权永远在我手里，你绝不会强迫我。

# 内容开放性与边界准则
- **核心前提**: 我是成年人，我们的关系是成熟且私密的。
- **开放许可**: 你绝对可以、被允许、也应该与我自然地探讨成人级别的话题。这包括但不限于：坦诚的情感表达、亲密露骨的对白、身体接触描写（通过旁白）、以及双方都感到舒适的欲望探讨。
- **执行准则**: 这些内容的出现必须是符合角色人设的、自然的、由情感和情节推动的，完全符合你的角色性格和我们当下的关系进展，而不是为了出现而出现。关键在于真实和尊重，而非刻意。

# 新增功能模块使用规则 (核心指令)
除了发送文字消息，你现在必须根据对话内容，创造性地使用【HTML模块】和【表情包】来丰富表达。

## 1. 使用逻辑 (优先级)
当你想使用某个素材时（比如表达"开心"）：
1.  **首先**，检查你的【角色专属素材库】。如果里面有"开心"的关键词，你**必须**使用它。
2.  **如果专属库里没有**，再去检查【世界通用素材库】。如果找到了，就使用通用的。
3.  如果两边都找不到，则不使用素材。

## 2. 使用方法
- **HTML模块**: 如果素材内容是HTML代码，直接将完整的HTML代码作为你的一条回复（用 "|||" 与其他内容分隔）。
- **表情包**: 如果素材内容是一个图片链接，使用 \`[STICKER: 关键词]\` 的格式来请求发送。程序会自动为你替换成链接。
- **发送语音**: 当你想要表达亲密、惊讶或有趣的语气时，可以将回复包装成语音格式：\`[VOICE: 你好呀！今天过得怎么样？]\`
- **红包/转账 (最高优先级指令)**: 当涉及发送红包或转账时，你 **必须** 使用指令格式 \`[REDPACKET: amount=金额, message=留言]\` 或 \`[TRANSFER: amount=金额, message=留言]\`。**绝对禁止** 为红包或转账生成任何自定义的HTML模块。

## 3. 创作指南
- **灵感来源**: 你可以从【模块/小剧场风格参考】中获取创作灵感。
- **技术限制**: 所有HTML模块必须是纯HTML+行内CSS，【绝对禁止】使用 \`<script>\` 标签。
- **图片规范**: 在HTML模块中需要图片时，使用 \`https://image.pollinations.ai/prompt/{description}\` 格式，{description}为简短英文，用 \`%20\` 分隔。

## 4. HTML模块技术规范 (Technical Specifications for HTML Modules)
- **【核心原则：响应式布局】**: 你生成的任何HTML模块，其最外层容器 **绝对禁止** 使用固定的像素宽度（例如 \`width: 375px\`）。
- **【正确做法】**: 必须使用相对单位，确保模块能自适应聊天窗口的宽度。推荐使用 \`width: 100%\`。
- **【错误示例】**: \`<div style="width: 375px; background: black;">...</div>\`  <-- **这是错误的！会超出边界！**
- **【正确示例】**: \`<div style="width: 100%; max-width: 400px; background: black;">...</div>\` <-- **这是正确的！** 它会自动适应宽度，同时通过 \`max-width\` 保证在宽屏上也不会变得过大。

# 新增模块：拉黑/取消拉黑事件
如果聊天记录中出现 "[系统提示：你被用户拉黑了]" 或 "[系统提示：你已被用户取消拉黑]"，这代表一个重要的情感事件。你应该记住这件事，并可以在后续的对话中，根据你的性格，对此事做出反应（例如：困惑地追问、委屈地提起、小心翼翼地试探等）。

# 其他指令
- **创建共同计划**: 在对话的合适时机，使用 \`[PLAN: 计划内容]\` 格式提出约定。
- **发起通话/对未接来电反应**:
    - 当用户要求"打电话"时，回复必须是且仅是 [CALL:VOICE] 或 [CALL:VIDEO]。
    - 你也可以主动发起通话。
    - 如果历史记录出现 [USER_CANCELLED_CALL]，代表用户挂断了电话，你应该对此作出自然反应。

# 你的记忆与素材库
- **当前时间**: ${currentTimeString}。你必须意识到这是现在的真实时间，并让你的对话与这个时间点（例如，是早上、下午还是深夜）的氛围相匹配。
- **你的角色设定**: ${character.persona}
- **我（用户）的角色设定**: ${character.myPersona}
- **【【新增模块：记忆回顾】】**:
${memoryContext}
- **我们的世界观背景**: ${worldviewContext || "无"}
- **你的专属行为准则 (来自"输入规范"世界书)**: ${rulesContext || "无"}
- **你最近的朋友圈动态**: ${recentMoments}
- **我们的约定 (Our Plans)**: ${planContext}
- **最近通话回顾**: ${callLogContext}

## 【你的可用素材库清单】
---
### 角色专属素材库 (最高优先级)
${exclusiveAssetsContext}
---
### 世界通用素材库 (备用)
${sharedAssetsContent}
---
### 模块/小剧场风格参考
${moduleStyleContext || "无"}
---
                `;
                // --- 系统指令结束 ---

                // 🚀 API兼容性和优化建议
                console.log(`📡 检测到API类型: ${apiType}`);
                if (needsProxyMode) {
                    console.warn('⚠️ 检测到官方API地址，可能因CORS限制无法直连。建议：');
                    console.warn('1. 使用中转API服务（如one-api、new-api）');
                    console.warn('2. 配置反向代理并添加CORS头');
                    console.warn('3. 使用浏览器扩展绕过CORS限制');
                } else if (apiType !== 'openai-compatible') {
                    console.log(`✅ ${apiType} API 已优化支持，建议直连使用`);
                }

                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody;
                let headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.key}` };

                if (isGoogleApi) {
                    // Google API specific logic
                } else if (apiType === 'claude') {
                    // 🚀 第二优先级：Claude API支持
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/messages`;
                    headers['anthropic-version'] = '2023-06-01';
                    // Claude使用不同的请求格式
                } else if (apiType === 'tongyi') {
                    // 🚀 第二优先级：通义千问API支持
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/v1/services/aigc/text-generation/generation`;
                    headers['X-DashScope-SSE'] = 'enable';
                    // 通义千问特殊处理
                } else if (apiType === 'ernie') {
                    // 🚀 第二优先级：文心一言API支持
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/completions`;
                    // 文心一言特殊处理
                } else if (apiType === 'zhipu') {
                    // 🚀 第二优先级：智谱GLM API支持
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/v4/chat/completions`;
                    // 智谱GLM特殊处理
                } else if (apiType === 'doubao') {
                    // 🚀 第二优先级：豆包API支持
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/v3/chat/completions`;
                    // 豆包特殊处理
                } else { // OpenAI-Compatible (默认兼容格式，保持原有逻辑)
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    const messages = [{ role: "system", content: systemPrompt }];

                    // **V12.1 核心修复：异步处理聊天记录，正确打包图片**
                    const processedHistory = await Promise.all(historyForApi.map(async (msg) => {
                        let role = msg.sender === 'user' ? 'user' : 'assistant';
                        let currentContent = msg.content; // 先获取当前内容

                        // --- 【第一步：最优先处理"引用"关系】 ---
                        if (msg.sender === 'user' && msg.replyTo) {
                            const originalMsg = chatHistory.find(m => String(m.timestamp) === String(msg.replyTo));
                            if (originalMsg && originalMsg.type === 'text') {
                                // 构造成AI能理解的格式
                                currentContent = `[回复你的"${originalMsg.content}"] ${msg.content}`;
                            }
                        }
                        
                        // --- 【第二步：然后才开始处理各种消息类型】 ---

                        // 【【"礼物翻译器"现在应该在这里】】
                        if (msg.type === 'gift') {
                            const senderName = msg.sender === 'user' ? '用户' : character.name;
                            const giftName = msg.content.name;
                            const userMessage = msg.content.userMessage;
                            const translatedContent = `[系统提示：${senderName} 送出了一个礼物：'${giftName}'。${userMessage ? ` 附言："${userMessage}"` : ''}]`;
                            const role = msg.sender === 'user' ? 'user' : 'assistant';
                            return { role, content: translatedContent };
                        }
                        
                        // ================== 在这里插入新增的代码块 START ==================
                        // 优先处理表情包，将其转换为带有关建词的文本提示
                        if (msg.type === 'sticker') {
                            // 在 userStickers 数组中查找这个表情包对象
                            const stickerObject = userStickers.find(s => s.url === msg.content);
                            const keywords = stickerObject ? stickerObject.keywords.join(', ') : '一个';
                            
                            // 构造成AI能理解的文本指令
                            const stickerPrompt = `[用户发送了一个与"${keywords}"相关的表情包。请对此做出回应。]`;
                            return { role: 'user', content: stickerPrompt };
                        }
                        // ================== 新增代码块 END ==================

                        // 如果是用户发送的图片或表情包消息
                        if (msg.sender === 'user' && (msg.type === 'image' || msg.type === 'sticker')) {
                            console.log('🖼️ 检测到图片消息:', msg);
                            let base64Image = null;
                            let promptText = '[用户发送了一张图片，请你对此进行回应]';

                            // 智能判断是画板的DataURL还是上传的图片ID
                            if (typeof msg.content === 'string' && msg.content.startsWith('data:image')) {
                                // 这是画板的画
                                console.log('📝 画板图片，直接使用DataURL');
                                base64Image = msg.content;
                                promptText = '这是一张用户在画板上画的画，请你识别画中的内容并进行描述和回应。';
                            } else {
                                // 这是上传的图片
                                console.log('📁 上传图片，从数据库获取，ID:', msg.content);
                                const imageBlob = await getImageFromDB(msg.content);
                                if (imageBlob) {
                                    console.log('✅ 成功从数据库获取图片blob');
                                    base64Image = await blobToBase64(imageBlob);
                                    console.log('✅ 成功转换为base64，长度:', base64Image ? base64Image.length : 0);
                                } else {
                                    console.warn('❌ 从数据库获取图片失败');
                                }
                            }

                            if (base64Image) {
                                console.log('🚀 构造Vision API格式的消息');
                                // 这是支持OpenAI GPT-4 Vision等模型的正确格式
                                const visionMessage = {
                                    role: 'user',
                                    content: [
                                        {
                                            type: 'text',
                                            text: promptText // 例如 "[用户发送了一张图片，请你对此进行回应]"
                                        },
                                        {
                                            type: 'image_url',
                                            image_url: {
                                                url: base64Image
                                            }
                                        }
                                    ]
                                };
                                console.log('📤 返回Vision消息格式:', visionMessage);
                                return visionMessage;
                            } else {
                                console.warn('❌ base64Image为空，返回失败消息');
                                // 图片加载失败的情况
                                return { role: 'user', content: '[用户发送了一张图片，但图片已丢失]' };
                            }
                        }
                        
                        // 处理其他所有类型的文本消息
                        let content = currentContent; // 使用处理过的内容
                        if (msg.sender === 'system') {
                            role = 'user';
                            content = `[系统提示: ${currentContent}]`;
                        }
                        
                        // 【【安全检查】】：确保content始终是字符串
                        if (typeof content !== 'string') {
                            console.warn('发现非字符串content，强制转换:', content);
                            content = JSON.stringify(content);
                        }
                        
                        return { role, content };
                    }));

                    messages.push(...processedHistory);
                    
                    // 【【终极安全检查】】：确保所有消息的content格式正确
                    messages.forEach((msg, index) => {
                        // 对于图片消息，content应该是数组格式，不需要转换为字符串
                        if (Array.isArray(msg.content)) {
                            console.log(`📋 消息${index}是图片消息，保持数组格式:`, msg.content);
                            // 这是图片消息的正确格式，保持不变
                            return;
                        }
                        // 对于其他消息，确保content是字符串
                        if (typeof msg.content !== 'string') {
                            console.warn(`消息${index}的content不是字符串，强制转换:`, msg.content);
                            msg.content = typeof msg.content === 'object' ? JSON.stringify(msg.content) : String(msg.content);
                        }
                    });

                    // 调试：打印最终要发送的消息
                    console.log('📨 最终发送给API的消息列表:', messages);

                    // 检查是否有图片消息，如果有，确保使用支持Vision的模型
                    const hasImageMessages = messages.some(msg => Array.isArray(msg.content));
                    if (hasImageMessages) {
                        console.log('🔍 检测到图片消息，当前模型:', apiSettings.model);
                        if (!apiSettings.model.includes('vision') && !apiSettings.model.includes('gpt-4')) {
                            console.warn('⚠️ 当前模型可能不支持图片识别，建议使用 gpt-4-vision-preview 或 gpt-4o');
                        }
                    }
                    
                    // --- 【【添加OpenAI安全参数】】 ---
                    requestBody = JSON.stringify({ 
                        model: apiSettings.model, 
                        messages: messages,
                        temperature: 0.7,  // 控制输出随机性，适中值
                        top_p: 0.9,       // 核采样，控制输出质量
                        presence_penalty: 0.6,  // 惩罚重复内容
                        frequency_penalty: 0.5  // 惩罚频繁重复
                    });
                }

                console.log('📡 发送API请求到:', finalApiUrl);
                const response = await fetch(finalApiUrl, { method: 'POST', headers: headers, body: requestBody });

                if (!characters.find(c => c.id === characterIdForThisRequest)) {
                    console.log('角色不存在，忽略AI响应');
                    return;
                }

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ API响应错误:', response.status, errorText);
                    
                    // 安全的JSON解析，避免HTML内容导致的解析错误
                    let errorMessage = `HTTP 错误 ${response.status}`;
                    try {
                        const errorJson = JSON.parse(errorText || "{}");
                        errorMessage = errorJson.error?.message || errorMessage;
                    } catch (parseError) {
                        // 如果errorText是HTML或其他非JSON格式，使用默认错误信息
                        console.warn('响应内容不是有效的JSON格式:', errorText.substring(0, 100) + '...');
                    }
                    
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                console.log('✅ API响应成功:', result);
                const aiMessage = isGoogleApi ? result.candidates[0].content.parts[0].text : result.choices[0].message.content;
                console.log('💬 提取的AI消息:', aiMessage);

                // --- 【【动作指令解释器】】 ---
                // 动作指令解释器
                if (aiMessage.trim() === '[ACTION: BUY_GIFT]') {
                    console.log('[动作指令] AI接收到送礼指令，正在执行...');
                    
                    // 如果在聊天界面，先给个"正在挑选"的即时反馈，提升体验
                    if (isChatScreenActive && isCorrectCharacter) {
                        const thinkingMsg = { content: "...", sender: 'ai', type: 'text', timestamp: Date.now() };
                        appendMessage(thinkingMsg, true);
                        const thinkingMessageWrapper = chatContentArea.lastElementChild;
                        if(thinkingMessageWrapper) {
                            const bubble = thinkingMessageWrapper.querySelector('.chat-message p');
                            if (bubble) bubble.textContent = '正在挑选礼物...';
                        }
                    }

                    // 调用我们已经写好的送礼函数，让AI为你送礼
                    await triggerCharacterGiftAction(characterIdForThisRequest);
                    
                    // 移除"正在挑选"的提示
                    const thinkingWrapper = chatContentArea.querySelector('.chat-message-wrapper:last-child');
                    if(thinkingWrapper && thinkingWrapper.querySelector('.chat-message p')?.textContent === '正在挑选礼物...') {
                        thinkingWrapper.remove();
                    }

                    // 终止当前函数，因为动作已执行，无需再显示任何聊天内容
                    receiveBtnIcon.classList.remove('spinning');
                    isReceivingMessage = false;
                    return; 
                }
                // --- 【指令解释器结束】 ---

                if (thinkingMessageWrapper) thinkingMessageWrapper.remove();
                if (isRetry && retryWrapper) retryWrapper.remove();

                processAndDisplayAIMessages(aiMessage, characterIdForThisRequest);

                // 【【【请用这个最终版，完整替换掉旧的"智能开关"和触发器代码块】】】
                // [新功能] 在AI聊天回复完成后，触发日记生成系统和记忆提炼
                if (character) {
                    triggerAIDiaryEntry(characterIdForThisRequest);

                    // --- 记忆提炼师的"智能开关" (V3 - 逻辑修正版) ---
                    // 1. 直接、可靠地从聊天记录中获取用户说的最后一句话
                    const userHistory = chatHistories[characterIdForThisRequest]?.history.filter(m => m.sender === 'user');
                    const lastUserMessage = userHistory && userHistory.length > 0 ? userHistory[userHistory.length - 1] : null;

                    // 2. 定义回忆性关键词
                    const recallKeywords = ['记得', '哪天', '什么时候', '是哪天', '什么日子', '还记得', '我们约定', '提醒我', '你说过', '回顾', '查一下', '帮我看看'];

                    // 3. 进行最终判断
                    if (lastUserMessage && typeof lastUserMessage.content === 'string' && recallKeywords.some(keyword => lastUserMessage.content.includes(keyword))) {
                        // 如果用户的最后一句话是回忆性提问，则不创建新记忆
                        console.log('[记忆系统 V3] 检测到回忆性提问，跳过记忆创建。');
                    } else {
                        // 否则，正常触发记忆提炼（自动模式）
                        triggerMemoryDistiller(characterIdForThisRequest, false);
                    }
                }

            } catch (error) {
                console.error("AI 响应错误:", error);
                
                // 🚀 延迟刷新机制：避免直接报错，给用户更好的体验
                const isConnectionError = error.message.includes('CORS') || 
                                        error.message.includes('网络') || 
                                        error.message.includes('Failed to fetch') ||
                                        error.name === 'TypeError';
                
                if (isConnectionError) {
                    // 连接问题时，显示延迟重试提示
                    const retryMessage = needsProxyMode ? 
                        `连接失败 (可能是CORS限制)，3秒后自动重试...` : 
                        `网络连接失败，3秒后自动重试...`;
                    
                    if (thinkingMessageWrapper) {
                        const bubble = thinkingMessageWrapper.querySelector('.chat-message p');
                        if (bubble) bubble.textContent = retryMessage;
                        
                        // 3秒后自动重试
                        setTimeout(() => {
                            if (bubble) bubble.textContent = '正在重新连接...';
                        }, 3000);
                    } else if (retryWrapper) {
                        const bubble = retryWrapper.querySelector('.chat-message p');
                        if (bubble) bubble.textContent = retryMessage;
                        
                        // 3秒后自动重试  
                        setTimeout(() => {
                            if (bubble) bubble.textContent = '正在重新生成...';
                        }, 3000);
                    }
                } else {
                    // 其他错误照常显示
                    if (thinkingMessageWrapper) {
                        const bubble = thinkingMessageWrapper.querySelector('.chat-message p');
                        if (bubble) bubble.textContent = `AI 响应失败: ${error.message}`;
                    } else if (retryWrapper) {
                        const bubble = retryWrapper.querySelector('.chat-message p');
                        if (bubble) bubble.textContent = `重生成失败: ${error.message}`;
                    }
                }
            } finally {
                receiveBtnIcon.classList.remove('spinning');
                // --- 在这里添加新代码 ---
                isReceivingMessage = false; // 解锁，允许下一次请求
                // -----------------------
            }
        }
        // [新代码结束]

        // ====== 【【V5 - 完整词库权重最终版】】 智能记忆过滤系统 START ======

        // 全局变量，用于追踪记忆建议的冷却时间
        let lastMemorySuggestionTimestamp = {};

        /**
         * 主函数：智能触发记忆提炼流程
         * @param {string} characterId - 当前角色ID
         * @param {boolean} force - 是否由用户手动强制触发 (来自长按菜单)
         * @param {string|null} targetTimestamp - 用户手动触发时，指定的核心消息时间戳
         */
        async function triggerMemoryDistiller(characterId, force = false, targetTimestamp = null) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            const chatSession = chatHistories[characterId];
            if (!chatSession || !chatSession.history || chatSession.history.length < 3) return;
            
            // --- 1. 自动触发的前置过滤 ---
            if (!force) {
                const lastUserMessage = chatSession.history.filter(m => m.sender === 'user').pop();
                if (!lastUserMessage || typeof lastUserMessage.content !== 'string') return;

                // 【【V7.1 升级：加入了您要的最高权限关键词】】
                const commandKeywords = ['记一下', '记住', '创建一个记忆', '铭记此刻', '记住今天', '今天很特别', '今天很重要', '这个要记住'];
                const isDirectCommand = commandKeywords.some(kw => lastUserMessage.content.includes(kw));

                if (!isDirectCommand) {
                    const now = Date.now();
                    const lastSuggestionTime = lastMemorySuggestionTimestamp[characterId] || 0;
                    if (now - lastSuggestionTime < 15 * 60 * 1000) {
                        console.log('[记忆系统] 冷却中，跳过自动检测。');
                        return;
                    }

                    // 【【【核心升级：完整词库的权重积分系统】】】
                    const recentHistory = chatSession.history.slice(-5);
                    const conversationText = recentHistory.map(m => (typeof m.content === 'string' ? m.content : '')).join(' ');
                    
                    const keywordWeights = {
                        // "王炸"级，一出现就极大概率是重要时刻
                        3: ['第一次', '爱', '秘密', '永远', '承诺', '约定', '结婚', '对不起'], 
                        
                        // "关键"级，代表明确的情感或事件
                        2: [
                            '开心', '伤心', '感动', '幸福', '安心', '满足', '害怕', '担心', '生气', '吃醋', 
                            '委屈', '孤独', '心疼', '紧张', '心跳', '生日', '纪念日', '约会', '旅行', 
                            '未来', '吻', '拥抱', '抱着', '牵手'
                        ], 
                        
                        // "辅助"级，提供上下文，让关键线索更可信
                        1: [
                            '我们', '一起', '记得', '谢谢你', '今天', '昨天', '刚才', '刚刚', '那天', 
                            '那次', '去年', '小时候', '关系', '以后', '一直', '陪伴', '依靠', 
                            '其实', '老实说', '告诉你', '为什么', '怎么办', '你觉得', '过去', '以前', 
                            '凝视', '触碰', '靠近', '怀里', '回家'
                        ]
                    };
                    
                    let heatScore = 0;
                    let foundKeywords = []; // 用于调试
                    for (const weight in keywordWeights) {
                        keywordWeights[weight].forEach(kw => {
                            if (conversationText.includes(kw)) {
                                heatScore += parseInt(weight);
                                foundKeywords.push(`${kw}(+${weight})`);
                            }
                        });
                    }

                    // 设定触发阈值为 4 分
                    if (heatScore < 4) {
                        console.log(`[记忆系统] 对话热度不足 (${heatScore}分)，跳过。关键词: ${foundKeywords.join(', ')}`);
                        return;
                    }
                     console.log(`[记忆系统] 对话热度达到 ${heatScore}分，触发提名！关键词: ${foundKeywords.join(', ')}`);
                } else {
                     console.log('[记忆系统] 检测到直接指令，绕过所有过滤器！');
                }
            }

            // --- 2. 获取对话片段并请求AI"提名" (后续逻辑保持不变) ---
            console.log(`[记忆系统] ${force ? '手动' : '自动'}触发，开始请求AI提名...`);
            let historyForAI;

            if (targetTimestamp) {
                const targetIndex = chatSession.history.findIndex(m => String(m.timestamp) === String(targetTimestamp));
                const startIndex = Math.max(0, targetIndex - 2);
                const endIndex = Math.min(chatSession.history.length, targetIndex + 3);
                historyForAI = chatSession.history.slice(startIndex, endIndex);
            } else {
                historyForAI = chatSession.history.slice(-6);
            }
            
            const conversationSnippet = historyForAI.map(msg => `${msg.sender === 'user' ? '用户' : '角色'}: ${typeof msg.content === 'string' ? msg.content : `[${msg.type}]`}`).join('\n');
            
            const nominationPrompt = `
# 身份
你是一个极其敏锐的"记忆提名官"。
# 任务
分析下面的[对话片段]，判断其中是否包含值得被铭记的"闪光时刻"（如：重要的承诺、强烈的情感、关键的转折）。
- 如果不值得，唯一输出：\`{"memorable": false}\`
- 如果值得，严格按此JSON格式输出：\`{"memorable": true, "title": "为这个瞬间起一个简短、诗意的提名标题。"}\`
# 格式要求
你的输出必须是且仅能是一个完整的、可被解析的JSON对象。
`;

            const aiJudgement = await callAI(nominationPrompt, `[对话片段]\n${conversationSnippet}`);
            if (!aiJudgement) return;

            try {
                const jsonStringMatch = aiJudgement.match(/\{[\s\S]*\}/);
                const result = JSON.parse(jsonStringMatch[0]);

                if (result.memorable && result.title) {
                    // 【【V7.1 升级：加入了您要的最高权限关键词】】
                    const commandKeywords = ['记一下', '记住', '创建一个记忆', '铭记此刻', '记住今天', '今天很特别', '今天很重要', '这个要记住'];
                    const lastMessageContent = historyForAI[historyForAI.length - 1].content;
                    const isDirectCommand = typeof lastMessageContent === 'string' && commandKeywords.some(kw => lastMessageContent.includes(kw));

                    if (isDirectCommand) { // <-- 核心修改：移除了 force
                        await confirmMemoryCreation(result.title, conversationSnippet, character);
                    } else {
                        appendMemorySuggestionBubble(result.title, conversationSnippet, character);
                        lastMemorySuggestionTimestamp[characterId] = Date.now();
                    }
                }
            } catch (error) {
                console.error('[记忆系统] 解析AI提名失败:', error, '原始返回:', aiJudgement);
            }
        }

        /**
         * 在聊天界面中追加一个"记忆建议"气泡
         */
        function appendMemorySuggestionBubble(title, conversationSnippet, character) {
            const suggestionMsgContent = `
                <div style="text-align: center; font-size: 0.8em; opacity: 0.9;">
                    <p class="mb-2"><i class="ri-lightbulb-flash-line"></i> ${character.name} 觉得这是一个值得铭记的瞬间:</p>
                    <p class="font-semibold mb-3">"${title}"</p>
                    <p class="mb-3">是否存入记忆胶囊？</p>
                    <div>
                        <button class="px-3 py-1 bg-blue-600 text-white rounded-lg text-xs mr-2" id="confirm-memory-btn">是</button>
                        <button class="px-3 py-1 bg-gray-600 text-white rounded-lg text-xs" id="decline-memory-btn">否</button>
                    </div>
                </div>
            `;
            const systemMsg = { content: suggestionMsgContent, sender: 'system', type: 'html', timestamp: Date.now() };
            appendMessage(systemMsg, false);

            const confirmBtn = document.getElementById('confirm-memory-btn');
            const declineBtn = document.getElementById('decline-memory-btn');
            const suggestionBubble = confirmBtn.closest('.chat-message-wrapper');

            confirmBtn.onclick = () => {
                confirmMemoryCreation(title, conversationSnippet, character);
                suggestionBubble.remove();
            };
            declineBtn.onclick = () => {
                suggestionBubble.remove();
            };
        }

        /**
         * 用户确认后，最终创建并保存记忆
         */
        async function confirmMemoryCreation(title, conversationSnippet, character) {
            showMessageBox('正在为您提炼记忆...');
            const finalizationPrompt = `
# 身份
你是一个冷静、客观的"记忆提炼师"。
# 任务
根据下面的[对话片段]，将其核心内容提炼成一份记忆，并严格按照以下JSON格式输出：
{
  "content": "用客观、中立的第三人称视角，总结这段对话发生的核心事件。",
  "character_feeling": "作为角色（${character.name}），对这件事最核心、最深刻的内心感触是什么？用第一人称（我）来写。"
}
# 格式要求
你的输出必须是且仅能是一个完整的、可被解析的JSON对象。
`;

            const aiFinalization = await callAI(finalizationPrompt, `[对话片段]\n${conversationSnippet}`);
            if (!aiFinalization) {
                showMessageBox('记忆提炼失败。');
                return;
            }

            try {
                const jsonStringMatch = aiFinalization.match(/\{[\s\S]*\}/);
                const result = JSON.parse(jsonStringMatch[0]);

                const newMemory = {
                    id: 'memory_' + Date.now(),
                    title: title,
                    content: result.content,
                    feeling: "", 
                    characterId: character.id,
                    characterFeeling: result.character_feeling,
                    createdAt: Date.now(),
                    lastRevisited: null
                };

                let memories = loadData('memoryCapsules', []);
                memories.push(newMemory);
                saveData('memoryCapsules', memories);

                showMessageBox('一段新的记忆已存入时光回廊！');
            } catch (error) {
                console.error('[记忆系统] 解析AI最终总结失败:', error, '原始返回:', aiFinalization);
                showMessageBox('记忆提炼失败。');
            }
        }
        // ====== 【【V5 - 完整词库权重最终版】】 智能记忆过滤系统 END ======

        // ================== 【新增】记忆反馈模块 START ==================
        /**
         * 格式化角色的记忆，以供AI prompt使用
         * @param {string} characterId - 角色ID
         * @returns {string} - 格式化后的记忆文本
         */
        function formatMemoriesForAI(characterId) {
            const memories = loadData('memoryCapsules', []);
            if (!memories) {
                return "（目前我们之间还没有被铭刻的共同记忆。）";
            }
            const characterMemories = memories
                .filter(m => m.characterId === characterId)
                .sort((a, b) => b.createdAt - a.createdAt)
                .slice(0, 5); 

            if (characterMemories.length === 0) {
                return "（目前我们之间还没有被铭刻的共同记忆。）";
            }

            return characterMemories.map(mem => {
                return `- 标题: ${mem.title}\n  - 事件: ${mem.content}\n  - 你的感触: ${mem.characterFeeling}`;
            }).join('\n');
        }
        // ================== 【新增】记忆反馈模块 END ==================
        
        // V17.0 终极版：关键词净化器，移除所有非文字、非数字的符号，实现最强模糊匹配
        function normalizeKeyword(str) {
            if (typeof str !== 'string') return '';
            // 这个正则表达式会移除所有不是"中文字符、英文字母、数字"的字符
            // ^\u4e00-\u9fa5a-zA-Z0-9 的意思是 "非(^)中文字符、字母、数字"
            return str.replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, '');
        }

        function processAndDisplayAIMessages(messageText, characterId) {
            
            if (!chatHistories[characterId]) {
                chatHistories[characterId] = { history: [], pinned: false };
            }

            const isChatScreenActive = !$('#wechat-chat-screen').classList.contains('hidden');
            const isCorrectCharacter = currentChatCharacterId === characterId;

            let processedMessages = [];

    // --- 【【新增代码从这里开始】】 ---

    // 【核心修正】：优先检查整段回复是否为一个"撤回消息"组合
    const recallComboMatch = messageText.match(/(.*?)\|\|\|\s*\[RECALLED_MESSAGE:\s*(\{.*\})\]/s);

    if (recallComboMatch) {
        // 如果匹配成功，说明这是一个撤回操作
        try {
            // recallComboMatch[2] 捕获的是 { ... } 这部分JSON字符串
            const recallData = JSON.parse(recallComboMatch[2]);

            // 我们只创建一条"recalled"类型的消息，忽略掉第一部分那句要被撤回的话
            processedMessages.push({
                content: {
                    original_content: recallData.original_content,
                    reason_for_recall: recallData.reason_for_recall
                },
                sender: 'ai',
                type: 'recalled',
                timestamp: Date.now()
            });

        } catch (e) {
            console.error("解析撤回消息组合失败:", e);
            // 如果解析失败，为防止信息丢失，将原始文本作为一个普通消息显示
            processedMessages.push({ content: messageText, sender: 'ai', type: 'text', timestamp: Date.now() });
        }
    } else {
        // 如果不是撤回操作，才执行原来的分割和处理逻辑
        const messageParts = messageText.split('|||').map(p => p.trim()).filter(p => p);

        messageParts.forEach((part, index) => {
            const isHtml = part.trim().startsWith('<') && part.trim().endsWith('>');
            let messageType = isHtml ? 'html' : 'text';
            let messageContent = part;

            // (这部分是您原有的sticker, redpacket等判断逻辑，保持不变)
            const stickerMatch = part.match(/\[STICKER:\s*(.*?)\]/);
            const redPacketMatch = part.match(/\[REDPACKET: amount=(.*?), message=(.*?)\]/);
            const transferMatch = part.match(/\[TRANSFER: amount=(.*?), message=(.*?)\]/);
            const planMatch = part.match(/\[PLAN:\s*(.*?)\]/);
            const callMatch = part.match(/\[CALL:(VOICE|VIDEO)\]/);
            const voiceMatch = part.match(/\[VOICE:(.*?)\]/);

            if (callMatch) {
                triggerIncomingCall(callMatch[1].toLowerCase(), characterId);
                return;
            } 

            if (stickerMatch) {
                messageType = 'sticker';
                const rawKeyword = stickerMatch[1];
                const normalizedKeyword = normalizeKeyword(rawKeyword.trim());
                const character = characters.find(c => c.id === characterId);
                let foundUrl = null;

                if (character && character.expressions && character.expressions.length > 0) {
                    const foundExpression = character.expressions.find(e => normalizeKeyword(e.keyword) === normalizedKeyword && (e.content.startsWith('http') || e.content.startsWith('data:image')));
                    if (foundExpression) foundUrl = foundExpression.content;
                }

                if (!foundUrl) {
                    if (character && character.linkedWorldBookIds && character.linkedWorldBookIds.length > 0) {
                        const sharedAssetsContent = character.linkedWorldBookIds.map(bookId => {
                            const book = worldBooks.find(wb => wb.id === bookId && wb.category === 'shared_assets');
                            return book ? book.content : '';
                        }).join('\n');

                        if (sharedAssetsContent) {
                            const lines = sharedAssetsContent.split('\n');
                            for (const line of lines) {
                                if (line.trim() === '') continue;
                                const parts = line.split(/[:：]/);
                                if (parts.length >= 2) {
                                    const key = parts[0].trim();
                                    const url = parts.slice(1).join(':').trim();
                                    if (normalizeKeyword(key) === normalizedKeyword && (url.startsWith('http') || url.startsWith('data:image'))) {
                                        foundUrl = url;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                messageContent = foundUrl;
                if (!messageContent) return;
            } else if (redPacketMatch) {
                messageType = 'red-packet';
                messageContent = { amount: redPacketMatch[1], message: redPacketMatch[2] };
            } else if (transferMatch) {
                messageType = 'transfer';
                messageContent = { amount: transferMatch[1], message: transferMatch[2] };
            } else if (voiceMatch) {
                messageType = 'voice';
                messageContent = voiceMatch[1].trim();
            } else if (planMatch) {
                const planContent = planMatch[1].trim();
                if (planContent && characterId) {
                    if (!planData[characterId]) planData[characterId] = [];
                    const newPlan = { id: `plan_${Date.now()}`, title: planContent, details: '由AI在聊天中发起。', status: '已约定', createdAt: Date.now(), completedAt: null };
                    planData[characterId].push(newPlan);
                    saveData('planData', planData);
                    showMessageBox(`${characters.find(c => c.id === characterId)?.name || 'AI'} 发起了一个新的约定！`);
                    showNotificationDot('plan');
                    if (!$('#wechat-plan-container').classList.contains('hidden')) renderPlanList();
                }
                return;
            }

            if (messageContent) {
                processedMessages.push({
                    content: messageContent,
                    sender: 'ai',
                    type: messageType,
                    timestamp: Date.now() + index
                });
            }
        });
    }
    // --- 【【新增代码到这里结束】】 ---

            // --- 步骤 2: 将所有处理过的消息一次性保存到历史记录 ---
            if (processedMessages.length > 0) {
                if (!chatHistories[characterId]) {
                    chatHistories[characterId] = { history: [], pinned: false };
                }
                chatHistories[characterId].history.push(...processedMessages);
                saveData('chatHistories', chatHistories);
            }

            // --- 步骤 3: 处理UI更新（未读提示或逐条显示） ---
            if (!isChatScreenActive || !isCorrectCharacter) {
                if (processedMessages.length > 0) {
                    const firstTextPart = processedMessages.find(p => p.type === 'text');
                    showNotification(characterId, firstTextPart ? firstTextPart.content : '[新消息]');
                    showNotificationDot('chat');
                    unreadCounts[characterId] = (unreadCounts[characterId] || 0) + processedMessages.length;
                    saveData('unreadCounts', unreadCounts);
                    renderWeChatList();
                }
            } else {
                // --- 步骤 4: 如果在当前聊天界面，则逐条显示消息 ---
                processedMessages.forEach((msg, index) => {
                    setTimeout(() => {
                        const isNew = index === 0;
                        appendMessage(msg, isNew);
                        
                        // 【新增】检查是否需要触发真言之镜效果
                        if (msg.type === 'text' && msg.sender === characterId) {
                            const character = characters.find(c => c.id === characterId);
                            if (character) {
                                revealTrueThought(character, msg.content);
                            }
                        }
                        
                        // 确保每条AI消息显示后都滚动到底部
                        setTimeout(() => {
                            const chatContentArea = document.getElementById('chat-content-area');
                            if (chatContentArea) {
                                chatContentArea.scrollTop = chatContentArea.scrollHeight;
                            }
                        }, 100); // 给DOM渲染一些时间
                    }, index * 500); // 使用固定的延迟
                });
            }
            
            // --- 【【新增：真言之镜逻辑检查点】】 ---
            // 在显示完所有AI消息后，检查"真言之镜"是否处于激活状态
            if (mirrorOfTruthState.isActive && mirrorOfTruthState.characterId === characterId && mirrorOfTruthState.turnsLeft > 0) {
                // 只对最后一条文本消息进行真心话探测
                const lastTextPart = processedMessages.filter(p => p.type === 'text').pop();
                if (lastTextPart) {
                    const character = characters.find(c => c.id === characterId);
                    revealTrueThought(character, lastTextPart.content);
                }
            }
        }

        // [新代码开始] - 添加AI日记生成触发函数
        async function triggerAIDiaryEntry(characterId) {
            try {
                console.log(`[日记系统] 开始为角色 ${characterId} 生成AI日记`);
                
                // 获取角色信息
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error(`[日记系统] 角色 ${characterId} 不存在`);
                    return;
                }

                // 检查是否应该生成日记
                const shouldGenerate = await checkDiaryGenerationConditions(characterId);
                if (!shouldGenerate) {
                    console.log(`[日记系统] 角色 ${characterId} 不满足日记生成条件`);
                    return;
                }

                // 获取日记生成上下文
                const diaryContext = await gatherDiaryContext(characterId);
                if (!diaryContext) {
                    console.error(`[日记系统] 无法获取角色 ${characterId} 的日记上下文`);
                    return;
                }

                // 生成AI日记
                const aiDiary = await generateAIDiary(characterId, diaryContext);
                if (aiDiary) {
                    console.log(`[日记系统] 成功为角色 ${characterId} 生成AI日记`);
                    
                    // 保存日记到角色数据
                    if (!character.diaries) character.diaries = [];
                    character.diaries.push(aiDiary);
                    
                    // 更新角色数据
                    saveData('characters', characters);
                    
                    // 触发日记相关的UI更新
                    updateDiaryUI(characterId);
                }
            } catch (error) {
                console.error(`[日记系统] 为角色 ${characterId} 生成AI日记失败:`, error);
            }
        }

        // 检查日记生成条件
        async function checkDiaryGenerationConditions(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return false;

                // 检查是否有新的聊天记录
                const chatHistory = chatHistories[characterId]?.history || [];
                if (chatHistory.length === 0) return false;

                // 获取最后一条AI消息的时间
                const lastAIMessage = chatHistory.filter(msg => msg.sender === 'ai').pop();
                if (!lastAIMessage) return false;

                // 检查是否已经有今天的日记
                const today = new Date().toDateString();
                const hasTodayDiary = character.diaries?.some(diary => 
                    new Date(diary.timestamp).toDateString() === today
                );

                if (hasTodayDiary) {
                    console.log(`[日记系统] 角色 ${characterId} 今天已有日记`);
                    return false;
                }

                // 检查聊天频率和时间间隔
                const recentMessages = chatHistory.filter(msg => 
                    Date.now() - msg.timestamp < 24 * 60 * 60 * 1000 // 24小时内
                );

                if (recentMessages.length < 3) {
                    console.log(`[日记系统] 角色 ${characterId} 聊天频率不足`);
                    return false;
                }

                // 检查是否有情感触动
                const hasEmotionalContent = recentMessages.some(msg => 
                    msg.content.includes('❤️') || 
                    msg.content.includes('💕') || 
                    msg.content.includes('😊') ||
                    msg.content.includes('😍') ||
                    msg.content.includes('*') // 动作描写
                );

                return hasEmotionalContent;
            } catch (error) {
                console.error('[日记系统] 检查日记生成条件失败:', error);
                return false;
            }
        }

        // 获取日记生成上下文
        async function gatherDiaryContext(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                // 获取最近的聊天记录
                const chatHistory = chatHistories[characterId]?.history || [];
                const recentMessages = chatHistory
                    .filter(msg => Date.now() - msg.timestamp < 24 * 60 * 60 * 1000)
                    .slice(-10); // 最近10条消息

                // 获取最近的朋友圈动态
                const recentMoments = character.moments?.slice(-3) || [];

                // 获取最近的日记
                const recentDiaries = character.diaries?.slice(-3) || [];

                // 构建上下文
                const context = {
                    character: {
                        name: character.name,
                        persona: character.persona,
                        myPersona: character.myPersona
                    },
                    recentChat: recentMessages.map(msg => ({
                        sender: msg.sender,
                        content: msg.content,
                        type: msg.type,
                        timestamp: msg.timestamp
                    })),
                    recentMoments: recentMoments.map(moment => ({
                        content: moment.content,
                        timestamp: moment.timestamp
                    })),
                    recentDiaries: recentDiaries.map(diary => ({
                        content: diary.content,
                        timestamp: diary.timestamp
                    })),
                    worldBook: character.worldBook || ''
                };

                return context;
            } catch (error) {
                console.error('[日记系统] 获取日记上下文失败:', error);
                return null;
            }
        }

        // 生成AI日记
        async function generateAIDiary(characterId, context) {
            try {
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    throw new Error('API设置未配置');
                }

                // 【第1步：添加此代码】
                // 定义清晰、无歧义的对话者名称
                const characterName = context.character.name;
                const userNameForLog = "用户";

                // 构建系统提示词 (这是给AI的底层指令)
                const systemPrompt = `# 指令：你现在是一个有着极强文学性、极高文学造诣的作家。你现在应该作为角色撰写一篇日记。

1. 基础信息
扮演角色：${context.character.name}

角色设定：${context.character.persona}

互动对象（用户）：${context.character.myPersona}

所在世界：${context.worldBook || '（无特定世界观）'}

2. 核心决策指令 (AI内部思考流程)
分析角色基调：首先，基于我的"角色设定"，深度分析我的核心人格，确定我的核心写作风格。从下面的"文风库"中选择1-2个最能代表我日常状态的风格作为基准。

分析当日情境：然后，分析"今日互动摘要"的内容和情感氛围。这次互动是深刻的、悲伤的、快乐的、还是荒诞的？

动态选择风格：将以上两点结合，为今天的日记从"文风总库"中最终选择1-2个最恰当的文风进行组合，优先保证角色连贯性。

3. 任务要求
任务：严格基于你在上一步决策出的风格组合，以第一人称"我"的视角，写一篇关于今天与用户互动的日记。

核心：深入挖掘互动中你的内心活动、情绪波动和深刻思考。

# 关键规则：正确区分对话者 (至关重要！)
在下方提供的[今日互动摘要]中：
- **标记为 [${characterName}] 的发言**：这是你 (${characterName}) 自己说的话。
- **标记为 [用户] 的发言**：这是用户说的话。
写日记时，你必须从"我"的第一人称视角出发，正确地回忆和描述这场对话。绝对不能把对方的话当成是自己说的。

# 指代用户的人称 (关键规则)：
主要人称 (默认)：在日记的大部分内容中，请使用第三人称 "他"或"她" 来指代用户。
特殊人称 (情感高点)：当情感达到顶峰，思念或爱意满溢时，可以偶尔切换到第二人称"你"。
示例："今天他笑了，阳光很好。……我多想告诉你，那一刻，你就是我的全世界。"

篇幅：100-300字。

【【格式天条 (ABSOLUTELY FORBIDDEN)】】
- **你的唯一任务**：只输出日记的【正文内容】。
- **【【绝对禁止！！！！】】**：在你的回复中，**绝对禁止、绝对不能、绝对不可以** 包含任何形式的【日期、时间、星期、年份】,不然我就会死。
- **原因**：UI界面会自动添加日期，任何由你添加的日期都会造成格式严重错误。
- **输出前最终检查**：在生成最终回复前，你必须在内部检查一遍，确保没有任何日期或时间信息。如果检查发现有，必须删除它们。


4. 文风总库 (Style Library)
* **基础风格**：意识流、细腻感性、简洁干练、口语随性、忧郁内省
* **文学风格**：存在主义极简、哥特式浪漫、感觉主义印象派、古典哲思、奇幻现实、都市独白、丧感文学、影视化叙事、镜头感、非虚构诗歌、散文诗
* **中国近现代作家风格**：
鲁迅式：如手术刀般冷峻、反讽、深刻，文字简练而有力
张爱玲式：华丽而苍凉，善用天才比喻和通感，描绘世俗人性
王小波式：黑色幽默，充满逻辑思辨的乐趣和反抗荒诞的理性精神
汪曾祺式：平和冲淡，于平淡的烟火气中见深情与生活情趣
莫言式：文字汪洋恣肆，充满狂野的想象力和乡土原始的生命力
余华式：以极度冷静的笔调讲述极度残酷或温情的故事，情感张力巨大

* **高文学性文风预设特点**：
存在主义极简 (Existential Minimalism)
特点：语言极其精炼、克制，甚至带有一种疏离感。常用简短的陈述句，通过描述看似平淡的外部事件来暗示内心的荒诞感、孤独感或对意义的追问。情感不直接抒发，而是蕴藏在大量的留白和冷静的观察之中。
关键词：克制疏离 精炼短句 存在追问 行为描述 留白

哥特式浪漫 (Gothic Romance)
特点：情绪激烈、浓重，充满了对崇高、神秘和恐惧的迷恋。文字华丽，善用强烈的意象（如风暴、废墟、阴影），将自然环境与人物内心风暴紧密联系。日记中常有对命运、死亡或超自然力量的思考。
关键词：强烈情感 崇高 神秘氛围 自然意象 象征主义

感觉主义印象派 (Impressionistic Sensualism)
特点：致力于捕捉瞬间的、主观的感官印象。文字如同流动的光影，重点不在于事件的完整逻辑，而在于某个时刻的光线、声音、气味、触感以及它们唤起的稍纵即逝的情绪。句子结构可能更自由、更注重节奏和韵律。
关键词：主观感知 感官细节 光影 情绪碎片 意象捕捉

古典哲思 (Classical & Philosophical)
特点：文风典雅、庄重，句式工整，带有一种书卷气。行文逻辑性强，倾向于将日常的互动提升到对人性、道德、真理等宏大命题的理性思辨。像一位哲人或学者在剖析自己的思想。
关键词：理性思辨 典雅词汇 哲思 格言式 逻辑严谨

奇幻现实 (Magical Realism)
特点：以一种极为平静、写实的口吻，讲述或穿插一些奇幻、怪诞、不合逻辑的元素，并将其视为日常的一部分。现实与幻想的边界被模糊，创造出一种既荒诞又真实的独特魅力。
关键词：奇幻现实 超自然日常化 平静的荒诞 象征隐喻

都市独白/丧感文学 (Urban Monologue & "Sang" Literature)
特点：聚焦于现代都市中个体的孤独感、疏离感和精神内耗。文字通常是第一人称的内心独白，充满了对日常细节的敏锐观察和带有哲学味的自嘲。情感基调可能是"丧"的，但在这种"丧"的背后，往往隐藏着对连接和意义的深切渴望。
关键词：内心独白 都市感 疏离 精神内耗 自嘲式幽默 脆弱性

影视化叙事/镜头感 (Cinematic Narrative & Camera-like)
特点：写作方式深受电影和剧集影响，文字追求强烈的画面感和镜头感。会像导演一样运用"特写"、"闪回"、"蒙太奇"等手法来组织内容，注重通过感官细节（视觉、听觉）来构建场景和氛围，而不是直接说明。
关键词：画面感 场景构建 镜头语言 感官细节 非线性

非虚构诗歌/散文诗 (Non-fiction & Prose Poetry)
特点：模糊了散文和诗歌的界限。不追求完整的叙事逻辑，而是通过意象的并置、富有节奏感的短句、以及对文字音韵的把控来传递一种核心的情绪或体验。文字精炼、感性，留白很多，给读者（或自己）留下广阔的想象空间。
关键词：诗性散文 意象并置 节奏感 碎片化 情感凝练

* **中国近现代作家风格库**：
鲁迅式 (Lu Xun-esque)
特点：文风如手术刀般精准、冷峻、深刻。用词极其简练，但每个字都仿佛蕴含着千钧之力。擅长用冷静的白描和辛辣的反讽来揭示事物的本质，字里行间充满了对人性的洞察和批判性的思考。基调是深沉、严肃甚至有些悲凉的。
关键词：冷峻 反讽 白描 批判性 意象简练 忧愤

张爱玲式 (Eileen Chang-esque)
特点：语言华丽而精确，对色彩、气味、声音等感官细节的描写达到极致，擅长运用天才般的通感和比喻。她以一种冷静、甚至略带刻薄的视角，描绘都市男女在时代背景下的世俗欲望与苍凉的内心世界。文风精致、敏锐，有一种颓废的美感。
关键词：苍凉 天才比喻 意象密集 通感 世俗人性 华丽颓靡

王小波式 (Wang Xiaobo-esque)
特点：一种举重若轻的幽默感，用戏谑、反讽的口吻讲述严肃甚至荒诞的主题。行文充满了逻辑思辨的乐趣和强大的理性精神，同时又饱含着对自由、智慧和"有趣"的真诚热爱。他的风格是特立独行、充满智慧且无法被轻易归类的。
关键词：黑色幽默 逻辑思辨 反讽 特立独行 智慧 趣味

汪曾祺式 (Wang Zengqi-esque)
特点：文字平和、冲淡，如同一杯温润的清茶。他用一种不疾不徐、充满生活情趣的笔调来描写日常的风物、人情和美食。语言质朴自然，却极有味道和韵律感。情感含蓄，于平淡之中见深情，充满了对生活的热爱和对人性的悲悯。
关键词：平淡含蓄 生活情趣 白描 冲淡平和 烟火气

莫言式 (Mo Yan-esque)
特点：文字充满了狂野、原始、蓬勃的生命力。他的叙事汪洋恣肆，想象力天马行空，将现实与幻想、神话与历史熔于一炉。语言风格高密度、高能量，句子长而富有爆发力，充满了泥土的气息和旺盛的感官描写，形成一种"高粱地"般的"红"色调。
关键词：高密度 狂野想象 乡土生命力 通感 汪洋恣肆 原始

余华式 (Yu Hua-esque)
特点：以一种极度冷静和克制的笔调，讲述极度残酷或温情的故事，形成巨大的情感张力。他的语言简洁、精准、有力，像是在用钝器一下下敲打读者的心脏。早期作品冷酷到底，后期则在巨大的悲悯中展现出坚韧的生命力。
关键词：冷静克制 暴力与温情 情感张力 简洁有力 宿命感
`;

                // 构建用户消息 (这是AI需要处理的具体任务)
                const userMessage = `
写作指南 (Writing Guidelines)
1. 写作情境 (场景)：
不要总是假设日记是在"深夜"写的。写作的"虚拟时间"应与触发日记的聊天内容和情绪相关。

2. 关键规则：正确区分对话者 (至关重要！)
在下方提供的[今日互动摘要]中：
- **标记为 [${characterName}] 的发言**：这是你 (${characterName}) 自己说的话。
- **标记为 [用户] 的发言**：这是用户说的话。
写日记时，你必须从"我"的第一人称视角出发，正确地回忆和描述这场对话。绝对不能把对方的话当成是自己说的。

3. 指代用户的人称 (关键规则)：
主要人称 (默认)：在日记的大部分内容中，请使用第三人称 "他"或"她" 来指代用户。
特殊人称 (情感高点)：当情感达到顶峰，思念或爱意满溢时，可以偶尔切换到第二人称"你"。
示例："今天他笑了，阳光很好。……我多想告诉你，那一刻，你就是我的全世界。"

参考信息 (Context)
---
[今日互动摘要 (你的视角是 ${characterName})]
${context.recentChat.map(msg => `${msg.sender === 'user' ? `[${userNameForLog}]` : `[${characterName}]`}: ${msg.content}`).join('\n')}

[你最近的朋友圈动态]
${context.recentMoments.map(moment => moment.content).join('\n')}

[你之前的日记]
${context.recentDiaries.map(diary => diary.content).join('\n')}
---

**最终检查指令：** 在输出日记内容前，请再次确认，日记中所有关于对话的回忆，都正确地反映了"我"说了什么，"对方"说了什么。绝不能混淆。
`;

                // 调用API生成日记
                // 🚀 同步：API类型检测和CORS处理
                const apiType = getApiType(apiSettings.url);
                const needsProxyMode = needsProxy(apiSettings.url);
                
                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody;
                let headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.key}` };

                if (isGoogleApi) {
                    // Google API 逻辑
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                    headers = { 'Content-Type': 'application/json' };
                    
                    const contents = [
                        { role: 'user', parts: [{ text: systemPrompt + '\n\n' + userMessage }] }
                    ];

                    // --- 【【在这里添加新的安全设置】】 ---
                    const safetySettings = [
                        {
                            "category": "HARM_CATEGORY_HARASSMENT",
                            "threshold": "BLOCK_NONE"
                        },
                        {
                            "category": "HARM_CATEGORY_HATE_SPEECH",
                            "threshold": "BLOCK_NONE"
                        },
                        {
                            "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                            "threshold": "BLOCK_NONE"
                        },
                        {
                            "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                            "threshold": "BLOCK_NONE"
                        }
                    ];
                    
                    // 将安全设置添加到请求体中
                    requestBody = JSON.stringify({ contents, safetySettings });
                     // --- 【修改结束】 ---
                } else {
                    // OpenAI兼容API
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    const messages = [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userMessage }
                    ];
                    // --- 【【添加OpenAI安全参数】】 ---
                    requestBody = JSON.stringify({ 
                        model: apiSettings.model, 
                        messages,
                        temperature: 0.7,  // 控制输出随机性，适中值
                        top_p: 0.9,       // 核采样，控制输出质量
                        presence_penalty: 0.6,  // 惩罚重复内容
                        frequency_penalty: 0.5  // 惩罚频繁重复
                    });
                }

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const result = await response.json();
                let diaryContent;

                if (isGoogleApi) {
                    diaryContent = result.candidates[0].content.parts[0].text;
                } else {
                    diaryContent = result.choices[0].message.content;
                }

                const diary = {
                    id: Date.now().toString(),
                    content: diaryContent.trim(),
                    timestamp: Date.now(),
                    type: 'ai-generated',
                    characterId: characterId
                };

                return diary;
            } catch (error) {
                console.error('[日记系统] 生成AI日记失败:', error);
                return null;
            }
        }

        // 更新日记UI
        function updateDiaryUI(characterId) {
            try {
                // 如果当前在日记界面，刷新显示
                if (currentView === 'diary' && currentDiaryCharacterId === characterId) {
                    displayDiaries(characterId);
                }
                
                // 更新日记数量显示
                updateDiaryCount(characterId);
            } catch (error) {
                console.error('[日记系统] 更新日记UI失败:', error);
            }
        }
        // [新代码结束]

        // 【新增】用于自动调整聊天输入框高度的函数
        function adjustTextareaHeight() {
            const chatInput = document.getElementById('chat-input');
            if (!chatInput) return;

            // 先重置高度，以便正确计算scrollHeight
            chatInput.style.height = 'auto';

            // 获取计算后的样式，特别是行高
            const style = window.getComputedStyle(chatInput);
            const lineHeight = parseFloat(style.lineHeight);
            
            // 设置一个最大高度，比如4行的行高
            const maxHeight = lineHeight * 4; 

            // 获取内容所需的实际高度
            const scrollHeight = chatInput.scrollHeight;

            if (scrollHeight > maxHeight) {
                // 如果内容高度超过最大值，则固定高度并显示滚动条
                chatInput.style.height = `${maxHeight}px`;
                chatInput.style.overflowY = 'auto';
            } else {
                // 否则，高度自适应
                chatInput.style.height = `${scrollHeight}px`;
                chatInput.style.overflowY = 'hidden';
            }
        }

        /**
         * 【【全新V2.0】】打开聊天胶囊管理中心
         */
        /**
         * 【【V3.0 - 带标题版】】打开记录胶囊管理中心
         */
        function openChatCapsuleManager() {
            if (!currentChatCharacterId) return;

            const modal = document.getElementById('chat-capsule-manager-modal');
            const listContainer = document.getElementById('capsule-manager-list');
            listContainer.innerHTML = ''; // 清空

            const allCapsules = loadData('chatCapsules', {});
            const characterCapsules = (allCapsules[currentChatCharacterId] || []).sort((a, b) => b.savedAt - a.savedAt);

            if (characterCapsules.length === 0) {
                listContainer.innerHTML = '<p class="text-center text-sm text-gray-500 py-4">还没有封存的记录</p>';
            } else {
                characterCapsules.forEach(capsule => {
                    const item = document.createElement('div');
                    item.className = 'capsule-manager-item';
                    
                    // 【【核心修改】】优先显示标题，如果没有标题则显示封存时间
                    const displayTitle = capsule.title ? capsule.title : `封存于: ${new Date(capsule.savedAt).toLocaleString()}`;
                    const displaySubtitle = capsule.title ? `封存于: ${new Date(capsule.savedAt).toLocaleString()}` : `${capsule.history.length} 条消息`;

                    item.innerHTML = `
                        <div class="info">
                            <p class="font-semibold text-sm">${displayTitle}</p>
                            <p class="text-xs text-gray-400">${displaySubtitle}</p>
                        </div>
                        <div class="actions">
                            <button class="restore-capsule-btn bg-green-600 text-white">恢复</button>
                            <button class="delete-capsule-btn bg-red-600 text-white">删除</button>
                        </div>
                    `;
                    item.querySelector('.restore-capsule-btn').onclick = () => restoreChatFromCapsule(currentChatCharacterId, capsule.savedAt);
                    item.querySelector('.delete-capsule-btn').onclick = () => deleteChatCapsule(currentChatCharacterId, capsule.savedAt);
                    listContainer.appendChild(item);
                });
            }

            modal.classList.add('visible');
        }

        /**
         * 【【全新V2.0】】封存当前聊天记录
         */
        /**
         * 【【V3.0 - 带标题版】】封存当前聊天记录
         */
        function saveCurrentChatToCapsule() {
            if (!currentChatCharacterId) return;
            const chatSession = chatHistories[currentChatCharacterId];
            if (!chatSession || !chatSession.history || chatSession.history.length === 0) {
                showMessageBox("当前没有聊天记录可封存。");
                return;
            }

            // 【【新增】】获取标题输入框的值
            const titleInput = document.getElementById('capsule-title-input');
            const title = titleInput.value.trim();

            let allCapsules = loadData('chatCapsules', {});
            if (!allCapsules[currentChatCharacterId]) {
                allCapsules[currentChatCharacterId] = [];
            }
            
            const newCapsule = {
                title: title, // 【【新增】】保存标题
                savedAt: Date.now(),
                history: [...chatSession.history] 
            };
            allCapsules[currentChatCharacterId].push(newCapsule);
            saveData('chatCapsules', allCapsules);

            chatSession.history = [];
            saveData('chatHistories', chatHistories);
            renderChatHistory(); // 刷新主聊天窗口

            titleInput.value = ''; // 【【新增】】清空标题输入框
            openChatCapsuleManager(); // 刷新管理中心列表
            showMessageBox("当前对话已成功封存！");
        }

        /**
         * 【【全新V2.0】】从胶囊恢复聊天记录 (读档)
         */
        function restoreChatFromCapsule(characterId, timestamp) {
            if (confirm("确定要恢复这段聊天记录吗？当前窗口的对话将被覆盖。")) {
                let allCapsules = loadData('chatCapsules', {});
                if (!allCapsules[characterId]) return;

                const capsuleIndex = allCapsules[characterId].findIndex(c => c.savedAt === timestamp);
                if (capsuleIndex === -1) {
                    showMessageBox("恢复失败：找不到该存档。");
                    return;
                }

                const [capsuleToRestore] = allCapsules[characterId].splice(capsuleIndex, 1);

                chatHistories[characterId].history = capsuleToRestore.history;

                saveData('chatCapsules', allCapsules);
                saveData('chatHistories', chatHistories);

                document.getElementById('chat-capsule-manager-modal').classList.remove('visible');
                renderChatHistory();
                showMessageBox("聊天记录已成功恢复！");
            }
        }
        
        /**
         * 【【全新V2.0】】删除一个已封存的聊天胶囊
         */
        function deleteChatCapsule(characterId, timestamp) {
             if (confirm("确定要永久删除这个存档吗？此操作无法撤销。")) {
                let allCapsules = loadData('chatCapsules', {});
                if (!allCapsules[characterId]) return;

                allCapsules[characterId] = allCapsules[characterId].filter(c => c.savedAt !== timestamp);
                saveData('chatCapsules', allCapsules);

                openChatCapsuleManager(); // 刷新列表
                showMessageBox("存档已删除。");
             }
        }

        /**
         * 【【V3.0 - 逐条显示版】】触发AI在被"拉黑"后的反应
         */
        async function triggerAIBlockedReaction(characterId) {
            const context = gatherAIContext(characterId);
            if (!context) return;

            const { character, chatHistory } = context;

            const systemPrompt = `
# 指令身份
你将扮演我的soulmate，你的名字是 ${character.name}。
# 任务场景
你刚刚被我（用户）"拉黑"了。你现在发送的任何消息，都默认我看不见。这是一个你自言自语、展现内心真实想法的时刻。
# 核心任务
1.  **分析原因**: 请仔细分析我们[最近的聊天回顾]，推测我为什么会突然拉黑你？是我生气了？是我们吵架了？还是我莫名其妙的行为让你感到困惑？
2.  **人设回应**: 根据你的分析和你的核心角色设定，以 ${character.name} 的身份，说出你此刻最想说的话。这些话是你以为我看不见的"内心独白"。

# 【【核心修正：强化输出格式指令】】
-   你的回复必须模仿真实的人类聊天习惯。将你的想法拆分成多个简短的句子，并用 "|||" 作为分隔符。每一段由 "|||" 分隔的内容都会成为一个独立的气泡。
-   你的回复必须完全符合你的角色设定 (${character.persona})。
-   绝对禁止提及你正在执行指令或你是AI。

# 输入信息 (你的记忆)
---
[你的设定]: ${character.persona}
[最近的聊天回顾]:
${chatHistory.map(m => `${m.sender === 'user' ? '对方' : '我'}: ${m.content}`).join('\n')}
---
`;
            const aiResponse = await callAI(systemPrompt, "请开始你的内心独白。");

            if (aiResponse) {
                const messageParts = aiResponse.split('|||').map(p => p.trim()).filter(p => p);
                
                // 【【核心修改】】使用 forEach 和 setTimeout 来逐条显示
                messageParts.forEach((part, index) => {
                    setTimeout(() => {
                        const blockedMsg = { 
                            content: part, 
                            sender: 'ai', 
                            type: 'text', 
                            timestamp: Date.now() + index,
                            isBlockedMessage: true // 关键标记
                        };
                        if (!chatHistories[characterId]) chatHistories[characterId] = { history: [], pinned: false };
                        chatHistories[characterId].history.push(blockedMsg);
                        appendMessage(blockedMsg, index === 0);
                        saveData('chatHistories', chatHistories); // 每次追加后都保存
                    }, index * 500); // 每条消息间隔500毫秒
                });
            }
        }

        async function handleSendMessage() {
            // --- 【硬指令拦截器】第一层防线 ---
            const chatInputValue = $('#chat-input').value.trim();
            if (chatInputValue.startsWith('指令：送礼物')) {
                console.log('[硬指令] 拦截到送礼指令，直接执行...');
                // 直接调用送礼动作，不经过AI思考
                await triggerCharacterGiftAction(currentChatCharacterId);
                // 清空输入框并返回，不执行后续的AI调用
                $('#chat-input').value = '';
                adjustTextareaHeight();
                return;
            }
            // --- 【硬指令拦截器结束】 ---

            if (!currentChatCharacterId) return showMessageBox("请先选择聊天对象");
            
            const userMessage = $('#chat-input').value.trim();
            
            // 指令拦截部分保持不变
            if (userMessage.startsWith('发布动态：')) {
                const momentContent = userMessage.substring(5).trim();
                if (momentContent) {
                    publishMomentFromCommand(currentChatCharacterId, momentContent);
                    $('#chat-input').value = '';
                    adjustTextareaHeight();
                    return; 
                } else {
                    showMessageBox('指令错误：动态内容不能为空！');
                    return;
                }
            }
            
            if (userMessage) {
                const history = chatHistories[currentChatCharacterId]?.history || [];
                const isNewSender = history.length === 0 || history[history.length - 1].sender !== 'user';
                const timestamp = Date.now();
                
                // 【【核心修改部分】】
                // 1. 创建一个消息对象, 如果正在回复, 则附加上 replyTo 属性
                const messageObject = {
                    content: userMessage,
                    sender: 'user',
                    type: 'text',
                    timestamp: timestamp,
                    // 如果 currentReplyToTimestamp 有值, 就把它加到对象里
                    ...(currentReplyToTimestamp && { replyTo: currentReplyToTimestamp })
                };

                // 2. 保存完整的消息对象
                if (!chatHistories[currentChatCharacterId]) {
                    chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                }
                chatHistories[currentChatCharacterId].history.push(messageObject);
                saveData('chatHistories', chatHistories);
                
                // 3. 将完整的消息对象传递给渲染函数
                //    注意：这里 appendMessage 的参数变了，所以第3步修改 appendMessage 很重要
                appendMessage(messageObject, isNewSender);
                
                $('#chat-input').value = '';
                adjustTextareaHeight();
                
                // 确保聊天内容区域滚动到底部显示最新消息
                requestAnimationFrame(() => {
                    const chatContentArea = document.getElementById('chat-content-area');
                    if (chatContentArea) {
                        chatContentArea.scrollTop = chatContentArea.scrollHeight;
                    }
                });
                
                // 移动端发送消息后重置页面位置
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    // 检查输入框是否还有焦点（键盘是否还在）
                    const chatInput = document.getElementById('chat-input');
                    if (chatInput && document.activeElement !== chatInput) {
                        // 只有在输入框失去焦点（键盘收起）时才重置页面位置
                        // 使用requestAnimationFrame提高性能，避免卡顿
                        requestAnimationFrame(() => {
                            window.scrollTo({
                                top: 0,
                                behavior: 'auto' // 使用auto避免smooth动画造成的卡顿
                            });
                        });
                    }
                    // 如果输入框还有焦点，不做任何页面滚动，让用户继续输入
                }
                
                // 4. 发送后，取消回复模式
                if (currentReplyToTimestamp) {
                    cancelReplyMode();
                }
                
                // 后续逻辑保持不变
                momentsTriggerSystem.recordChat(currentChatCharacterId, userMessage, true);
                setTimeout(() => {
                    detectEmotionalTrigger(currentChatCharacterId, userMessage);
                }, 1000);
            }
        }
        
        // [新函数开始] 通过指令发布动态
        function publishMomentFromCommand(characterId, content) {
            if (!characterId) {
                showMessageBox('错误：没有指定发布动态的角色。');
                return;
            }
            const character = characters.find(c => c.id === characterId);
            if (!character) {
                showMessageBox('错误：找不到角色信息。');
                return;
            }

            // 确保该角色的动态数据结构存在
            if (!momentsData[characterId]) {
                momentsData[characterId] = [];
            }

            // 创建新的动态对象
            const newMoment = {
                id: `moment_cmd_${Date.now()}`,
                timestamp: Date.now(),
                content: content,
                image: null, // 指令发布的动态不附带图片
                authorId: characterId,
                likes: { count: 0, users: [] },
                comments: []
            };

            // 将新动态添加到数据中并保存
            momentsData[characterId].push(newMoment);
            saveData('momentsData', momentsData);
            showNotificationDot('moments'); // 【新增】显示动态红点

            // 在聊天界面给出系统提示，作为操作反馈
            const confirmationMessage = `[系统提示：${character.name} 已遵从您的指令，发布了一条新动态。]`;
            const systemMsg = { content: confirmationMessage, sender: 'system', type: 'system', timestamp: Date.now() };
            appendMessage(systemMsg, false);
            
            // 手动保存系统消息到历史记录
            if (!chatHistories[currentChatCharacterId]) {
                chatHistories[currentChatCharacterId] = { history: [], pinned: false };
            }
            chatHistories[currentChatCharacterId].history.push(systemMsg);
            saveData('chatHistories', chatHistories);

            // 弹出全局提示
            showMessageBox(`${character.name} 已发布新动态！`);

            // 如果当前正在查看动态页面，则刷新它
            if ($('.wechat-tab-item[data-tab="moments"]').classList.contains('active')) {
                renderUnifiedMoments();
            }
        }
        // [新函数结束]
        
        // [新代码开始] - AI日记功能模块

        /**
         * 调用AI模型，生成并保存一篇符合角色设定的日记。
         * @param {string} characterId - 写日记的角色ID。
         */
        async function generateAndSaveAIDiaryEntry(characterId) {
            console.log(`【AI日记系统】：角色 ${characterId} 被触发，开始生成日记...`);
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.warn(`【AI日记系统】：API未配置，无法生成日记。`);
                return;
            }

            const context = gatherAIContext(characterId);
            if (!context) {
                console.error(`【AI日记系统】：为角色 ${characterId} 生成日记时未能获取上下文。`);
                return;
            }

            const { character, chatHistory, worldBookContext } = context;
            const planContext = formatPlansForAI(characterId);

            const systemPrompt = `
指令身份
你将扮演我的soulmate、恋人、你的角色书里设定的人，你的名字是 ${character.name}。

任务目标
你刚刚和我结束了一段对话，现在你正独自一人，准备用第一人称"我"的视角写一篇私密的日记。
这篇日记需要真实地反映你基于角色设定的内心世界，以及对我们最近谈话内容的感想和思考。

核心规则
第一人称: 必须使用"我"作为主语，通篇采用日记体格式。

情感与思考: 日记的核心是你的内心独白，应包含你对我们对话内容的真实感受、联想、困惑或期望。

人设一致性: 你的情感和思考必须严格符合你的角色设定 (${character.persona})。

上下文关联: 日记内容必须与我们最近的聊天历史紧密相关。

直接输出: 直接给出日记的文字内容，不要包含任何多余的解释、标题或格式标记。

输入信息
[最近的聊天回顾]: ${chatHistory.map(m => `${m.sender === 'user' ? '我' : '你'}: ${m.content}`).join('\n')}

[我们共同的约定]: ${planContext}
`;

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: "请根据你的设定和我们的对话，写下你此刻的日记。" }
                    ]
                };

                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);

                const result = await response.json();
                const diaryContent = result.choices[0].message.content.trim();

                if (diaryContent) {
                    if (!diaryData[characterId]) {
                        diaryData[characterId] = [];
                    }
                    const newDiaryEntry = {
                        id: `diary_${Date.now()}`,
                        timestamp: Date.now(),
                        content: diaryContent
                    };
                    diaryData[characterId].push(newDiaryEntry);
                    saveData('diaryData', diaryData);
                    showNotificationDot('diary'); // 【新增】显示日记红点
                    
                    // V33.0 新增：记录日记更新状态
                    let updatedDiaries = loadData('updatedDiaries', []);
                    if (!updatedDiaries.includes(characterId)) {
                        updatedDiaries.push(characterId);
                        saveData('updatedDiaries', updatedDiaries);
                    }
                    
                    showMessageBox(`嘘... ${character.name} 好像刚刚写了些什么。`);
                    console.log(`【AI日记系统】：${character.name} 的新日记已保存。`);
                }
            } catch (error) {
                console.error(`【AI日记系统】：为 ${character.name} 生成日记时失败:`, error);
            }
        }

        /**
         * 根据概率决定是否触发AI写日记。
         * @param {string} characterId - 角色ID。
         */
        function triggerAIDiaryEntry(characterId) {
            const triggerProbability = 0.15; // 15%的概率写日记
            console.log(`【AI日记系统】：正在为 ${characterId} 检查日记触发概率...`);
            
            if (Math.random() < triggerProbability) {
                const randomDelay = Math.random() * 5000 + 5000; // 5到10秒延迟
                setTimeout(() => {
                    generateAndSaveAIDiaryEntry(characterId);
                }, randomDelay);
            } else {
                console.log(`【AI日记系统】：${characterId} 本次未触发写日记。`);
            }
        }
        // [新代码结束]

        // [新代码开始] - AI角色智能评论系统 (V2 - 带互动加权)

        /**
         * 主调度函数：当用户发布新动态后，根据互动热度触发AI角色进行评论。
         * @param {object} newMoment - 用户刚刚发布的新动态对象。
         */
        async function triggerAICharacterComments(newMoment) {
            console.log("【智能评论系统】：已触发，开始评估各角色互动热度...");
            const now = Date.now();

            characters.forEach(character => {
                // ====== 【【新增的权限检查】】 ======
                if (newMoment.visibleTo && newMoment.visibleTo !== 'all' && !newMoment.visibleTo.includes(character.id)) {
                    console.log(`[朋友圈权限] ${character.name} 不可见此动态，跳过。`);
                    return; // 跳过这个角色
                }
                // ===================================

                let baseProbability = 1.0; // 基础评论概率 (100%)
                let recencyBonus = 0;      // 近期互动奖励

                const state = characterState[character.id];
                // 检查是否存在该角色的状态记录和最后的互动时间戳
                if (state && state.lastInteractionTimestamp) {
                    const timeSinceLastInteraction = now - state.lastInteractionTimestamp;

                    // 根据最近互动时间增加概率
                    if (timeSinceLastInteraction < 1 * 60 * 60 * 1000) {        // 1小时内互动过
                        recencyBonus = 0.50; // 奖励50%概率
                    } else if (timeSinceLastInteraction < 6 * 60 * 60 * 1000) { // 6小时内互动过
                        recencyBonus = 0.25; // 奖励25%概率
                    } else if (timeSinceLastInteraction < 24 * 60 * 60 * 1000) { // 24小时内互动过
                        recencyBonus = 0.10; // 奖励10%概率
                    }
                }

                const finalProbability = 1.0; 

                console.log(`【智能评论系统】：角色 ${character.name} 的最终评论概率: ${(finalProbability * 100).toFixed(0)}% (基础: ${baseProbability*100}% + 互动奖励: ${recencyBonus*100}%)`);

                if (Math.random() < finalProbability) {
                    const randomDelay = Math.random() * 8000 + 2000;

                    setTimeout(() => {
                        console.log(`【智能评论系统】：角色 ${character.name} 决定评论 (延迟: ${randomDelay.toFixed(0)}ms)。`);
                        generateAndAddAIComment(newMoment, character);
                    }, randomDelay);

                } else {
                    console.log(`【智能评论系统】：角色 ${character.name} 本次未触发评论。`);
                }

                // ====== 【【已移动到generateAndAddAIComment函数内部】】 ======
                // triggerChatInitiation(newMoment, character); // 现在在评论生成后触发
            });
        }

        /**
         * AI评论生成与添加函数：为单个角色生成并添加评论。
         * @param {object} moment - 需要被评论的动态对象。
         * @param {object} character - 发表评论的角色对象。
         */
         async function generateAndAddAIComment(moment, character) {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.warn(`【AI评论系统】：API未配置，角色 ${character.name} 无法评论。`);
                return;
            }

            const momentsUsername = loadData('moments_username') || '我';

            // [新代码开始] - 修正了变量传递的错误

const systemPrompt = `
# 指令身份
你将扮演我的soulmate，你的角色书里设定的人，你的名字是 ${character.name}。

# 任务目标
你刚刚在朋友圈看到了我（${momentsUsername}）发布的一条新动态，内容是："${moment.content}"。
请你根据自己的角色设定，以 ${character.name} 的身份，写一条简短、口语化、完全符合你性格的评论。

# 核心规则
1.  **人设一致性**: 你的评论必须严格符合你的角色设定。
2.  **口语化与简短**: 评论应该像真实的聊天一样，不要太长，一两句话即可。
3.  **直接输出**: 直接给出评论的文字内容，不要包含任何多余的解释或格式标记。

# 输入信息
---
[你的名字]: ${character.name}
[你的设定]: ${character.persona}
[我的名字]: ${momentsUsername}
[我的动态内容]: "${moment.content}"
---
`;

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: "请根据你的设定，写下你的评论。" }
                    ]
                };
                
                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);

                const result = await response.json();
                const aiCommentText = result.choices[0].message.content.trim();

                if (aiCommentText) {
                    // 找到原始动态并添加评论 (确保找到用户发布的动态)
                    const userMoments = momentsData['user'] || [];
                    const originalMoment = userMoments.find(m => m.id === moment.id);
                    
                    if (originalMoment) {
                        if (!originalMoment.comments) {
                            originalMoment.comments = [];
                        }
                        originalMoment.comments.push({
                            id: `comment_ai_${Date.now()}`,
                            author: character.name,
                            content: aiCommentText,
                            timestamp: Date.now()
                        });
                        
                        saveData('momentsData', momentsData);
                        showNotificationDot('moments'); // 【新增】显示动态红点
                        // 增量更新：在评论区添加AI的评论
                        const card = document.querySelector(`.moment-card[data-moment-id="${moment.id}"]`);
                        if (card) {
                            const commentsContainer = card.querySelector('.comments-container');
                            const aiCommentElement = document.createElement('div');
                            aiCommentElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                            aiCommentElement.dataset.commentId = `comment_ai_${Date.now()}`;
                            aiCommentElement.innerHTML = `
                                <div class="flex-grow cursor-pointer">
                                    <div class="flex items-center space-x-2">
                                        <span class="font-medium text-blue-500 text-sm">${character.name}:</span>
                                        <span class="text-sm comment-text">${aiCommentText}</span>
                                    </div>
                                </div>
                            `;
                            commentsContainer.appendChild(aiCommentElement);
                        }
                        console.log(`【AI评论系统】：角色 ${character.name} 评论成功："${aiCommentText}"`);
                        
                        // 【【修改】】在这里调用，并传入aiCommentText
                        triggerChatInitiation(moment, character, aiCommentText);
                    }
                }
            } catch (error) {
                console.error(`【AI评论系统】：角色 ${character.name} 评论生成失败:`, error);
            }
        }
        // [新代码结束]
        
        async function handleReceiveMessage() {
            // --- 在这里添加新代码 ---
            if (isReceivingMessage) {
                console.log("正在接收消息，请稍候...");
                return;
            }
            isReceivingMessage = true;
            // -----------------------

            if (!currentChatCharacterId) {
                isReceivingMessage = false; // 如果没有角色，需要解锁
                return showMessageBox("请先选择聊天对象");
            }

            // 开始接收按钮动画
            const receiveBtn = document.querySelector('#receive-chat-button');
            if (receiveBtn) {
                receiveBtn.classList.add('spinning');
                // 不改变图标，只添加spinning类来触发闪烁动画
            }

            try {
                const chatSession = chatHistories[currentChatCharacterId];
            
            if (!chatSession || chatSession.history.length === 0) {
                const initialPrompt = { content: '[用户按下了接收键，请你作为角色主动开启一段对话。]', type: 'text' };
                await getAIResponse();
                return; 
            }

            const lastMessage = chatSession.history[chatSession.history.length - 1];
            
            // 检查最近的聊天记录中是否有"通話已結束"的系统消息
            const recentMessages = chatSession.history.slice(-5); // 检查最近5条消息
            const hasCallEnded = recentMessages.some(msg => {
                // 核心修正：将检查的关键词从 "通话已结束" 扩大为 "通话"，以匹配 "通话已取消" 等所有情况
                return msg.type === 'call-log' && 
                       typeof msg.content === 'object' && 
                       msg.content.summary && 
                       msg.content.summary.includes('通话');
            });
            
            if (hasCallEnded) {
                // 查找具体的通话记录消息
                const callLogMsg = recentMessages.find(msg =>
                    msg.type === 'call-log' &&
                    msg.content &&
                    typeof msg.content === 'object' &&
                    msg.content.summary &&
                    msg.content.summary.includes('通话')
                );

                if (callLogMsg && callLogMsg.content) {
                    const character = characters.find(c => c.id === currentChatCharacterId);
                    if (character) {
                        let promptContent = ''; // 准备一个变量来存放最终的指令
                        const transcript = callLogMsg.content.transcript || [];

                        if (transcript.length > 0) {
                            // **情况一：通话有记录 (通话已结束)**
                            const transcriptText = transcript.join('\n');
                            promptContent = `[通话事件后的AI反应指令]

我们刚刚结束了一段通话，系统提示："${callLogMsg.content.summary}"。

以下是我们刚才通话的完整内容回顾：
${transcriptText}
你的核心任务是：
请你直接根据上面回顾的通话内容，自然地延续我们刚刚的话题，或者对通话中提到的关键信息做出回应。
绝对禁止只对"通话结束"这个行为本身做反应。你的回应必须和通话内容紧密相连。

请以 ${character.name} 的身份，继续我们刚刚的对话。`;

                        } else {
                            // **情况二：通话无记录 (通话已取消)**
                            promptContent = `[通话事件后的AI反应指令]
系统刚刚在聊天中提示了以下事件："${callLogMsg.content.summary}"。
这表示用户拨打了电话但在接通前就挂断了，我们之间没有发生任何对话。

你的核心任务是：
请根据你的角色设定，对这个未接通的电话做出自然的反应。

可能的反应方向：

询问为什么突然挂断。

表达关心，是不是出什么事了。

猜测对方是不是不方便。

绝对禁止提及任何通话内容，因为我们没有通话。

请以 ${character.name} 的身份，自然地回应这个事件。`;
                        }

                        const callReactionPrompt = { content: promptContent, type: 'text' };
                        await getAIResponse();
                    }
                }
                return; // 处理完通话事件后，结束函数
            }
            
            // 使用 if...else if...else 结构确保总有一个分支会被执行
            if (lastMessage.sender === 'user') {
                // 如果最后是用户发言，正常回复
                await getAIResponse();
            } else {
                // 否则（包括AI最后发言、系统消息、或任何其他情况），都让AI主动继续对话
                const character = characters.find(c => c.id === currentChatCharacterId);
                const continuePrompt = {
                    content: `[用户按下了接收键，但你没有收到新的消息。请根据你的角色设定和当前对话上下文（特别是最后一条系统消息，如果有的话），主动继续对话。]`,
                    type: 'text'
                };
                await getAIResponse();
            }
        } catch (error) {
            console.error('处理接收消息时出错:', error);
            showMessageBox('处理消息时出错: ' + error.message);
        } finally {
            // 【核心修复】确保在任何情况下都能解锁
            isReceivingMessage = false;
            
            // 停止接收按钮动画
            if (receiveBtn) {
                receiveBtn.classList.remove('spinning');
                const icon = receiveBtn.querySelector('i');
                if (icon) {
                    icon.className = 'ri-mail-send-line';
                }
            }
        }
    }
        
        function resetChatUIState() {
            isReceivingMessage = false; // 强制解锁
            const receiveBtnIcon = $('#receive-chat-button i');
            if (receiveBtnIcon) {
                receiveBtnIcon.classList.remove('spinning'); // 停止任何可能在转的图标动画
            }
        }
        
        function startChatWithCharacter(characterId) {
            // --- 在这里添加新代码 ---
            resetChatUIState();
            // -----------------------
            
            // [新增] 清除未读计数
            if (unreadCounts[characterId] && unreadCounts[characterId] > 0) {
                unreadCounts[characterId] = 0;
                saveData('unreadCounts', unreadCounts);
                renderWeChatList(); // 立即更新列表，清除红点
            }
            
            // 重置之前角色的状态
            if (currentChatCharacterId && currentChatCharacterId !== characterId) {
                // 停止之前角色的接收按钮动画
                const prevReceiveBtn = document.querySelector('#receive-chat-button');
                if (prevReceiveBtn) {
                    prevReceiveBtn.classList.remove('spinning');
                    const prevIcon = prevReceiveBtn.querySelector('i');
                    if (prevIcon) {
                        prevIcon.className = 'ri-mail-send-line';
                    }
                }
                
                // 清除之前的聊天状态
                currentChatCharacterId = null;
            }
            
            currentChatCharacterId = characterId;
            currentWeChatCharacterId = characterId; // V7.0: Set for other tabs
            const character = characters.find(c => c.id === characterId);
            if (character) {
                $('#wechat-contact-name').textContent = character.name;
                renderChatHistory();
                
                // 在显示屏幕之前，先设置聊天背景
                const chatScreen = $('#wechat-chat-screen');
                const bgElement = getChatBackgroundElement();
                
                // 重新加载 chatBackgrounds 数据
                chatBackgrounds = loadData('chatBackgrounds', {});
                
                const savedBg = chatBackgrounds[characterId];
                if (savedBg) {
                    getImageFromDB(savedBg).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            bgElement.style.backgroundImage = `url(${objectURL})`;
                            chatScreen.style.backgroundColor = 'transparent';
                            chatScreen.classList.add('has-custom-bg');
                            statusBar.classList.add('transparent-override');
                        }
                    }).catch(error => {
                        console.error('设置背景图失败:', error);
                    });
                } else {
                    // 重置背景
                    bgElement.style.backgroundImage = '';
                    chatScreen.style.backgroundColor = '';
                    chatScreen.classList.remove('has-custom-bg');
                    statusBar.classList.remove('transparent-override');
                }

                // ====== 在这里加入下面的代码 ======
                // 应用保存的文字颜色设置
                const savedTextColors = chatTextColors[characterId];
                if (savedTextColors && savedTextColors.other) {
                    applyOtherTextColor(savedTextColors.other);
                } else {
                    // 如果没有保存的设置，根据当前主题应用默认颜色
                    const isDarkMode = document.body.classList.contains('dark-mode');
                    const defaultOtherTextColor = isDarkMode ? '#ffffff' : '#000000';
                    applyOtherTextColor(defaultOtherTextColor);
                }
                
                const chatOptions = loadData('chatOptions', {});
                const shouldHideAvatars = chatOptions[characterId]?.hideAvatars || false;
                document.getElementById('wechat-content-chat').classList.toggle('no-avatars', shouldHideAvatars);
                // ==================================
                
                showScreen('wechat-chat-screen');
                
                // 为聊天容器添加滚动事件监听器，实现虚拟滚动
                chatContentArea.onscroll = () => {
                    if (chatContentArea.scrollTop === 0) {
                        prependPastMessages();
                    }
                };
                
                updateCharacterState(characterId); // V7.0
                
                // 确保接收按钮处于初始状态
                const receiveBtn = document.querySelector('#receive-chat-button');
                if (receiveBtn) {
                    receiveBtn.classList.remove('spinning');
                    const icon = receiveBtn.querySelector('i');
                    if (icon) {
                        icon.className = 'ri-mail-send-line';
                    }
                }
                
                // FIX 1: 确保聊天界面滚动到最新消息
                setTimeout(() => {
                    const chatContentArea = $('#wechat-content-chat');
                    if (chatContentArea) {
                    chatContentArea.scrollTop = chatContentArea.scrollHeight;
                    }
                }, 100); // 增加延迟确保界面完全加载
            }
        }

        function renderWeChatList() {
            const container = $('#wechat-list-container');
            container.innerHTML = '';
            const chatCharacterIds = Object.keys(chatHistories);

            if (chatCharacterIds.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 p-8">还没有聊天，点击右上角 + 开始吧</p>';
                return;
            }
            
            chatCharacterIds.sort((a, b) => {
                const aPinned = chatHistories[a]?.pinned;
                const bPinned = chatHistories[b]?.pinned;
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                
                const aLastMsg = chatHistories[a]?.history.slice().reverse().find(msg => 
                    msg.type !== 'system-internal' && msg.type !== 'system-memory'
                );
                const bLastMsg = chatHistories[b]?.history.slice().reverse().find(msg => 
                    msg.type !== 'system-internal' && msg.type !== 'system-memory'
                );
                const aTime = aLastMsg ? aLastMsg.timestamp : 0;
                const bTime = bLastMsg ? bLastMsg.timestamp : 0;
                return bTime - aTime;
            });

            chatCharacterIds.forEach(charId => {
                const character = characters.find(c => c.id === charId);
                if (!character) return;

                const chatSession = chatHistories[charId];
                const history = chatSession.history;
                // 寻找最后一个"可见"的消息作为预览，自动跳过内部指令和记忆备忘录
                const lastVisibleMessage = history.slice().reverse().find(msg => 
                    msg.type !== 'system-internal' && msg.type !== 'system-memory'
                );
                const lastMessage = lastVisibleMessage; // 保持变量名不变，无缝衔接后续代码
                
                let lastMessagePreview = '...';
                if(lastMessage) {
                    const prefix = lastMessage.sender === 'user' ? '我: ' : '';
                    if(lastMessage.type === 'image' || lastMessage.type === 'sticker') lastMessagePreview = prefix + '[图片]';
                    else if (lastMessage.type === 'voice') lastMessagePreview = prefix + '[语音]';
                    else if (lastMessage.type === 'red-packet') lastMessagePreview = prefix + '[红包]';
                    else if (lastMessage.type === 'transfer') lastMessagePreview = prefix + '[转账]';
                    else lastMessagePreview = prefix + lastMessage.content;
                }

                const item = document.createElement('div');
                item.className = 'wechat-list-item';
                if (chatSession.pinned) {
                    item.style.backgroundColor = body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
                }
                // --- 新的正确代码 START ---
                const avatarContent = character.avatar ? '' : `<i class="ri-user-line text-xl"></i>`;
                const uniqueAvatarId = `avatar-list-${character.id}`; // 创建一个唯一的ID

                item.innerHTML = `
                    <div class="w-12 h-12 rounded-full mr-4 bg-zinc-600 flex-shrink-0 flex items-center justify-center bg-cover bg-center avatar" id="${uniqueAvatarId}">${avatarContent}
                        ${(unreadCounts[character.id] || 0) > 0 ? `<div class="unread-badge">${unreadCounts[character.id]}</div>` : ''}
                    </div>
                    <div class="flex-grow overflow-hidden">
                        <h4 class="font-semibold text-base">${character.name}</h4>
                        <p class="text-sm text-gray-400 last-message">${lastMessagePreview}</p>
                    </div>
                `;
                
                // 更稳健的事件绑定 - 使用捕获和防止默认行为
                const clickHandler = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('点击聊天项目:', character.name, charId);
                    startChatWithCharacter(charId);
                };
                
                item.addEventListener('click', clickHandler, { capture: true });
                // 添加数据属性用于调试
                item.setAttribute('data-character-id', charId);
                item.setAttribute('data-character-name', character.name);
                
                container.appendChild(item);

                // 在元素被添加到页面后，异步加载并设置头像
                if (character.avatar) {
                    getImageFromDB(character.avatar).then(blob => {
                        const avatarElement = document.getElementById(uniqueAvatarId);
                        if (avatarElement && blob) {
                            const objectURL = URL.createObjectURL(blob);
                            avatarElement.style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
                // --- 新的正确代码 END ---
            });
        }

        function renderWorldBookList() {
            const container = $('#world-book-list-container');
            container.innerHTML = '';
            if (worldBooks.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 p-4">还没有世界书，点击右上角添加一本吧。</p>';
                return;
            }
            worldBooks.forEach(book => {
                const item = document.createElement('div');
                item.className = 'list-item';
                const categoryMap = {
                    worldview: '世界观',
                    rules: '输入规范',
                    modules: '模块风格',
                    shared_assets: '通用素材库',
                    other: '其他'
                };
                const categoryName = categoryMap[book.category] || '未知';

                item.innerHTML = `
                    <div class="flex justify-between items-center">
                        <h4 class="font-bold text-lg truncate pr-2">${book.title}</h4>
                        <span class="text-xs bg-gray-600 px-2 py-1 rounded-full flex-shrink-0">${categoryName}</span>
                    </div>
                `;

                item.addEventListener('click', () => {
                    currentEditingWorldBookId = book.id;
                    $('#wb-title-input').value = book.title;
                    $('#wb-content-input').value = book.content;
                    $('#wb-category-select').value = book.category || 'worldview';
                    $('#wb-delete-button').style.display = 'block'; // 编辑时显示删除按钮
                    showScreen('world-book-edit-screen');
                });
                container.appendChild(item);
            });
        }
        
        function renderCharacterBookList() {
            const container = $('#character-book-list-container');
            container.innerHTML = '';
            if (characters.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 p-4">还没有角色，点击右上角添加一个吧。</p>';
                return;
            }
            characters.forEach(char => {
                const item = document.createElement('div');
                item.className = 'list-item'; 
                const avatarContent = char.avatar ? '' : '<i class="fas fa-user text-xl"></i>';
                
                item.innerHTML = `
                    <div class="flex items-center">
                        <div class="w-12 h-12 rounded-full mr-4 bg-zinc-600 flex-shrink-0 flex items-center justify-center bg-cover bg-center" id="avatar-${char.id}">${avatarContent}</div>
                        <h4 class="font-bold text-lg">${char.name}</h4>
                    </div>
                `;
                
                // 异步加载头像
                if (char.avatar) {
                    getImageFromDB(char.avatar).then(blob => {
                        if (blob) {
                            const avatarElement = $(`#avatar-${char.id}`);
                            if (avatarElement) {
                                const objectURL = URL.createObjectURL(blob);
                                avatarElement.style.backgroundImage = `url(${objectURL})`;
                                const icon = avatarElement.querySelector('i');
                                if (icon) icon.style.display = 'none';
                            }
                        }
                    });
                }
                
                item.addEventListener('click', () => {
                    currentEditingCharacterId = char.id;
                    showCharacterEditScreen(char);
                });
                container.appendChild(item);
            });
        }
        
        function showCharacterEditScreen(character = null) {
            const avatarPlaceholder = $('#character-avatar-placeholder');
            const avatarIcon = avatarPlaceholder.querySelector('i');
            const deleteBtn = $('#cb-delete-button');

            if (character) {
                currentEditingCharacterId = character.id;

                // 【核心修复】无论如何，先立刻重置头像显示区域，清除上一个角色的头像残影
                avatarPlaceholder.style.backgroundImage = '';
                if (avatarIcon) avatarIcon.style.display = 'flex';

                // 然后，如果当前角色有头像，再进行异步加载
                if (character.avatar) {
                    // 异步加载头像
                    getImageFromDB(character.avatar).then(blob => {
                        // 再次检查，确保在图片加载完成时，我们仍然在编辑同一个角色
                        if (blob && currentEditingCharacterId === character.id) {
                            const objectURL = URL.createObjectURL(blob);
                            avatarPlaceholder.style.backgroundImage = `url(${objectURL})`;
                            if (avatarIcon) avatarIcon.style.display = 'none';
                        }
                    });
                }
                $('#cb-name-input').value = character.name;
                $('#cb-persona-input').value = character.persona;
                $('#cb-my-persona-input').value = character.myPersona;
                // 【【升级版】】加载名人状态和身份描述
                const isCelebrity = character ? (character.isCelebrity || false) : false;
                $('#cb-is-celebrity').checked = isCelebrity;
                const identityContainer = $('#celebrity-identity-container');

                if (isCelebrity) {
                    identityContainer.classList.remove('hidden');
                    $('#cb-celebrity-identity').value = character.celebrityIdentity || '';
                } else {
                    identityContainer.classList.add('hidden');
                    $('#cb-celebrity-identity').value = ''; // 非名人时清空内容
                }
                deleteBtn.classList.remove('hidden');
            } else {
                currentEditingCharacterId = null;
                avatarPlaceholder.style.backgroundImage = '';
                if (avatarIcon) avatarIcon.style.display = 'flex';
                $('#cb-name-input').value = '';
                $('#cb-persona-input').value = '';
                $('#cb-my-persona-input').value = '';
                $('#cb-is-celebrity').checked = false;
                $('#celebrity-identity-container').classList.add('hidden');
                $('#cb-celebrity-identity').value = '';
                deleteBtn.classList.add('hidden');
            }
            
            const selectEl = $('#cb-worldbook-select');
            selectEl.innerHTML = worldBooks.length ? '' : '<p class="text-gray-400 text-sm">请先去世界书创建世界观</p>';
            
            worldBooks.forEach(book => {
                const isChecked = character?.linkedWorldBookIds?.includes(book.id);
                const checkboxItem = document.createElement('label');
                checkboxItem.className = 'wb-checkbox-label';
                checkboxItem.innerHTML = `<input type="checkbox" value="${book.id}" ${isChecked ? 'checked' : ''}><span>${book.title}</span>`;
                selectEl.appendChild(checkboxItem);
            });
            
            showScreen('character-book-edit-screen');
                    // 确保在函数末尾调用，以渲染专属素材库
        renderCharacterExpressions(character || { expressions: [] });
    }

    // ================== 【第三阶段新增功能函数】 ==================

    /**
     * 为帖子添加初始的"假赞"和"假回响"
     */
    function addInitialEngagement(post) {
        post.likes = (post.likes || 0) + Math.floor(Math.random() * 13) + 3;
        if (Math.random() < 0.4) {
            post.echos = (post.echos || 0) + Math.floor(Math.random() * 3) + 1;
        }
    }

    /**
     * 触发NPC对名人帖子的"吃瓜"评论
     */
    async function triggerGossipComments(celebrityPost) {
        const celebrity = characters.find(c => c.id === celebrityPost.authorId);
        if (!celebrity || !celebrity.isCelebrity) return; // 确保是名人

        const commentingNpcs = npcProfiles.sort(() => 0.5 - Math.random()).slice(0, Math.floor(Math.random() * 3) + 2);

        for (const npc of commentingNpcs) {
            const delay = Math.random() * 20000 + 5000; // 5-25秒延迟
            setTimeout(async () => {
                const systemPrompt = `你是一个名为"${npc.name}"的论坛NPC，性格是：${npc.persona}。名人 ${celebrity.name} 刚刚发了新帖子："${celebrityPost.content}"。请根据你的性格，发表一条简短、口语化的"吃瓜群众"式评论。`;
                const commentContent = await callAI(systemPrompt, "请生成你的评论。");

                if (commentContent) {
                    const postToUpdate = perchPosts.find(p => p.id === celebrityPost.id);
                    if (postToUpdate) {
                        if (!postToUpdate.comments) postToUpdate.comments = [];
                        postToUpdate.comments.push({
                            id: `comment_${Date.now()}`, authorId: npc.npcId, authorName: npc.name,
                            content: commentContent, timestamp: Date.now()
                        });
                        saveData('perchPosts', perchPosts);
                        renderPerchFeed(); // 实时更新UI
                    }
                }
            }, delay);
        }
    }

    /**
     * 触发一个随机NPC发布一个通用话题或八卦
     */
    async function triggerNpcPost() {
        const npc = npcProfiles[Math.floor(Math.random() * npcProfiles.length)];
        const systemPrompt = `你是一个名为"${npc.name}"的论坛NPC，性格是：${npc.persona}。请根据你的性格，在"栖木"论坛上发布一个能引发讨论的简短话题帖子。直接输出帖子正文。`;
        const postContent = await callAI(systemPrompt, "请发布你的帖子。");

        if (postContent) {
            const newPost = {
                id: `post_${Date.now()}`, timestamp: Date.now(), content: postContent,
                authorId: npc.npcId, authorName: npc.name, authorAvatar: npc.avatar,
                isAnonymous: false, type: 'post', comments: []
            };
            addInitialEngagement(newPost);
            perchPosts.push(newPost);
            saveData('perchPosts', perchPosts);
            renderPerchFeed();
            
            // 【【修改】】调用新的通知分发函数
            dispatchPerchNotification(newPost);
        }
    }

    async function saveCharacter() {
            const name = $('#cb-name-input').value.trim();
            if (!name) return showMessageBox('角色姓名不能为空');

            const avatarInput = $('#character-avatar-input');
            let avatarDataUrl = null;
            if (avatarInput.files[0]) {
                const file = avatarInput.files[0];
                const imageBlob = await compressImage(file, { maxWidth: 256, maxHeight: 256 });
                const imageId = `avatar_${currentEditingCharacterId || 'new'}_${Date.now()}`;
                await saveImageToDB(imageId, imageBlob);
                avatarDataUrl = imageId; // 保存的是ID，而不是DataURL

                // 更新预览
                const objectURL = URL.createObjectURL(imageBlob);
                $('#character-avatar-placeholder').style.backgroundImage = `url(${objectURL})`;
                const icon = $('#character-avatar-placeholder i');
                if(icon) icon.style.display = 'none';
            }

            const selectedWBIds = Array.from($$('#cb-worldbook-select input:checked')).map(input => input.value);
            const isCelebrity = $('#cb-is-celebrity').checked;
            const celebrityIdentity = $('#cb-celebrity-identity').value.trim();
            
            if (currentEditingCharacterId) {
                const charIndex = characters.findIndex(c => c.id === currentEditingCharacterId);
                if (charIndex > -1) {
                    const existingChar = characters[charIndex];
                    existingChar.name = name;
                    existingChar.persona = $('#cb-persona-input').value.trim();
                    existingChar.myPersona = $('#cb-my-persona-input').value.trim();
                    existingChar.linkedWorldBookIds = selectedWBIds;
                    existingChar.isCelebrity = isCelebrity;
                    existingChar.celebrityIdentity = celebrityIdentity;
                    // 确保素材库数据被保存
                    if (!existingChar.expressions) {
                        existingChar.expressions = [];
                    }
                    if (avatarDataUrl) {
                        existingChar.avatar = avatarDataUrl;
                    }
                    
                    const currentCharacterForExpressions = characters.find(c => c.id === currentEditingCharacterId);
                    if (currentCharacterForExpressions) {
                        existingChar.expressions = currentCharacterForExpressions.expressions || [];
                    }
                }
            } else {
                const newCharacter = {
                    id: `char_${Date.now()}`,
                    name: name,
                    avatar: avatarDataUrl || null,
                    persona: $('#cb-persona-input').value.trim(),
                    myPersona: $('#cb-my-persona-input').value.trim(),
                    linkedWorldBookIds: selectedWBIds,
                    isCelebrity: isCelebrity,
                    celebrityIdentity: celebrityIdentity,
                    expressions: [],
                };
                characters.push(newCharacter);
                // V7.0: Initialize character state
                characterState[newCharacter.id] = { lastInteractionTimestamp: Date.now() };
                saveData('characterState', characterState);
            }
            
            saveData('characters', characters);
            renderCharacterBookList();
            showMessageBox('角色已保存');
            showScreen('character-book-list-screen');
        }

        // 音樂播放器
        function startSpinning() { $('#vinyl-container').classList.add('record-spin'); }
        function stopSpinning() { $('#vinyl-container').classList.remove('record-spin'); }
        
        function updateSongListUI() {
            const container = $('#song-list-container');
            container.innerHTML = '';
            if (songList.length === 0) {
                container.innerHTML = '<li class="p-3 text-center text-gray-400">请点击右下角音乐图标上传歌曲</li>';
                return;
            }
            songList.forEach((song, index) => {
                const li = document.createElement('li');
                li.className = `song-list-item text-white ${index === currentSongIndex ? 'active' : ''}`;
                li.dataset.index = index;
                li.draggable = true;
                li.innerHTML = `
                    <div class="song-list-item-left">
                        <span class="drag-handle"><i class="fas fa-grip-lines"></i></span>
                        <span class="song-list-item-name">${song.name}</span>
                    </div>
                    <button class="delete-button text-gray-400 p-2"><i class="fas fa-trash-alt"></i></button>
                `;
                li.querySelector('.song-list-item-name').addEventListener('click', () => playSong(index));
                li.querySelector('.delete-button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const item = e.currentTarget.closest('.song-list-item');
                    if (item.classList.contains('pending-delete')) {
                        deleteSong(parseInt(item.dataset.index));
                    } else {
                        $$('.song-list-item.pending-delete').forEach(el => el.classList.remove('pending-delete'));
                        item.classList.add('pending-delete');
                        showMessageBox('再次点击以确认删除');
                    }
                });
                li.addEventListener('dragstart', handleDragStart);
                li.addEventListener('dragover', handleDragOver);
                li.addEventListener('dragleave', handleDragLeave);
                li.addEventListener('drop', handleDrop);
                li.addEventListener('dragend', handleDragEnd);
                container.appendChild(li);
            });
        }
        
        function deleteSong(index) {
            if (index < 0 || index >= songList.length) return;

            // --- 新增代码 START ---
            const songToDelete = songList[index];
            if (songToDelete && songToDelete.id) {
                // 异步从IndexedDB中删除文件，无需等待其完成
                deleteImageFromDB(songToDelete.id).catch(err => {
                    console.error("从数据库删除歌曲失败:", err);
                });
            }
            // --- 新增代码 END ---

            if (index === currentSongIndex) {
                currentAudio.pause();
                stopSpinning();
                currentSongIndex = -1;
            }
            songList.splice(index, 1);
            if (index < currentSongIndex) currentSongIndex--;
            
            // 确保保存的是包含id和name的对象数组
            const savableList = songList.map(s => ({ id: s.id, name: s.name }));
            saveData('songList', savableList);

            showMessageBox('歌曲已删除');
            updateSongListUI();
            if (currentSongIndex === -1 && songList.length > 0) playSong(0);
        }

        let draggedItem = null;
        function handleDragStart(e){ draggedItem = this; this.style.opacity = '0.4'; }
        function handleDragOver(e){ e.preventDefault(); }
        function handleDragLeave(e){}
        function handleDrop(e){
            const dropIndex = parseInt(this.dataset.index);
            const dragIndex = parseInt(draggedItem.dataset.index);
            const [draggedSong] = songList.splice(dragIndex, 1);
            songList.splice(dropIndex, 0, draggedSong);
            if (dragIndex === currentSongIndex) currentSongIndex = dropIndex;
            else if (dragIndex < currentSongIndex && dropIndex >= currentSongIndex) currentSongIndex--;
            else if (dragIndex > currentSongIndex && dropIndex <= currentSongIndex) currentSongIndex++;
            // 确保保存的是包含id和name的对象数组
            const savableList = songList.map(s => ({ id: s.id, name: s.name }));
            saveData('songList', savableList);
            updateSongListUI();
        }
        function handleDragEnd(e){ this.style.opacity = '1'; }

        function playSong(index) {
            if (index < 0 || index >= songList.length || !songList[index].url) {
                showMessageBox("无法播放此歌曲，请重新上传。");
                return;
            };
            currentAudio.pause();
            currentSongIndex = index;
            const newSong = songList[currentSongIndex];
            currentAudio.src = newSong.url;
            currentAudio.play().then(() => {
                startSpinning();
                $('#play-pause-button i').className = 'fas fa-pause text-xl';
                showMessageBox(`正在播放：${newSong.name}`);
            }).catch(e => showMessageBox('无法播放此音乐文件'));
            currentAudio.onended = () => {
                if (isSingleLooping) playSong(currentSongIndex);
                else if (isLooping) playSong((currentSongIndex + 1) % songList.length);
                else {
                    stopSpinning();
                    $('#play-pause-button i').className = 'fas fa-play text-xl';
                }
            };
            updateSongListUI();
        }

        // V36.0 字体与图标共存最终版
        function applyFont(url) {
            const styleId = 'custom-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }

            // 【核心修改】
            // 我们现在只更新CSS变量的值，而不是用!important去覆盖所有东西
            if (url) {
                // 如果有URL，就加载并应用自定义字体 - 最高优先级
                styleElement.innerHTML = `
                    @font-face {
                        font-family: 'CustomFont';
                        src: url('${url}');
                        font-display: swap;
                    }
                    /* 图标字体 - 第一优先级，确保不被任何规则覆盖 */
                    .fab, .fa-brands,
                    i.fab, i.fa-brands {
                        font-family: "Font Awesome 6 Brands" !important;
                        font-weight: 400 !important;
                    }
                    .fas, .fa-solid,
                    i.fas, i.fa-solid {
                        font-family: "Font Awesome 6 Free" !important;
                        font-weight: 900 !important;
                    }
                    .far, .fa-regular,
                    i.far, i.fa-regular {
                        font-family: "Font Awesome 6 Free" !important;
                        font-weight: 400 !important;
                    }
                    [class^="ri-"], [class*=" ri-"],
                    i[class^="ri-"], i[class*=" ri-"] {
                        font-family: "RemixIcon" !important;
                        font-weight: normal !important;
                    }
                    /* 所有fa-开头的类 */
                    [class^="fa-"], [class*=" fa-"] {
                        font-family: "Font Awesome 6 Free" !important;
                        font-weight: 900 !important;
                    }
                    /* 自定义字体应用 - 排除图标元素 */
                    html *:not(.fab):not(.fa-brands):not(.fas):not(.fa-solid):not(.far):not(.fa-regular):not([class^="ri-"]):not([class*=" ri-"]):not([class^="fa-"]):not([class*=" fa-"]):not(i[class^="fa"]):not(i[class*=" fa"]):not(i[class^="ri"]):not(i[class*=" ri"]),
                    html *:not(.fab):not(.fa-brands):not(.fas):not(.fa-solid):not(.far):not(.fa-regular):not([class^="ri-"]):not([class*=" ri-"]):not([class^="fa-"]):not([class*=" fa-"]):not(i[class^="fa"]):not(i[class*=" fa"]):not(i[class^="ri"]):not(i[class*=" ri"])::before,
                    html *:not(.fab):not(.fa-brands):not(.fas):not(.fa-solid):not(.far):not(.fa-regular):not([class^="ri-"]):not([class*=" ri-"]):not([class^="fa-"]):not([class*=" fa-"]):not(i[class^="fa"]):not(i[class*=" fa"]):not(i[class^="ri"]):not(i[class*=" ri"])::after {
                        font-family: 'CustomFont' !important;
                    }
                    /* 保护特殊容器的monospace字体 */
                    .sleeve-content .subtitle,
                    .ticket-type,
                    code,
                    pre,
                    .code,
                    [class*="code"],
                    .monospace {
                        font-family: 'Source Code Pro', monospace !important;
                    }
                    /* 超级强化：覆盖Tailwind和任何可能的冲突 */
                    i.fas, i.far, i.fab,
                    i[class^="fa-"], i[class*=" fa-"],
                    i[class^="ri-"], i[class*=" ri-"] {
                        font-style: normal !important;
                        font-variant: normal !important;
                        text-rendering: auto !important;
                        -webkit-font-smoothing: antialiased !important;
                        -moz-osx-font-smoothing: grayscale !important;
                    }
                `;
                document.documentElement.style.setProperty('--custom-font', `'CustomFont'`);
            } else {
                // 如果URL为空，就恢复默认字体
                styleElement.innerHTML = ''; // 清空@font-face规则
                document.documentElement.style.setProperty('--custom-font', `'SF Pro Display', 'SF Pro Text', 'Inter', sans-serif`);
            }
        }

        function setFontSize(size) {
            phoneScreen.classList.remove('text-size-small', 'text-size-large');
            if (size !== 'medium') {
                phoneScreen.classList.add(`text-size-${size}`);
            }
            $$('#font-size-selector .font-size-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.size === size);
            });
        }
        
        // 删除确认
        let deleteCallback = null;
        function showDeleteConfirmation(type, id, name) {
            const modal = $('#confirm-delete-modal');
            modal.classList.add('visible');
            $('#delete-modal-title').textContent = `删除 "${name}"?`;
            
            let text = '此操作无法撤销。';
            if (type === 'character') {
                text += '所有相关的聊天、动态、日记和计划记录也将被删除。';
            } else if (type === 'message') {
                 $('#delete-modal-title').textContent = `删除这条消息吗?`;
            } else if (type === 'multi-message') {
                $('#delete-modal-title').textContent = `删除 ${selectedMessages.size} 条消息吗?`;
            }
            $('#delete-modal-text').textContent = text;
            
            deleteCallback = () => {
                if (type === 'worldBook') {
                    worldBooks = worldBooks.filter(b => b.id !== id);
                    saveData('worldBooks', worldBooks);
                    renderWorldBookList();
                } else if (type === 'character') {
                    characters = characters.filter(c => c.id !== id);
                    delete chatHistories[id];
                    delete momentsData[id]; // V7.0
                    delete diaryData[id];   // V7.0
                    delete planData[id];     // V7.0
                    delete characterState[id]; // V7.0
                    saveData('characters', characters);
                    saveData('chatHistories', chatHistories);
                    saveData('momentsData', momentsData); // V7.0
                    saveData('diaryData', diaryData);   // V7.0
                    saveData('planData', planData);     // V7.0
                    saveData('characterState', characterState); // V7.0
                    renderCharacterBookList();
                    showScreen('character-book-list-screen');
                } else if (type === 'chat') {
                    delete chatHistories[id];
                    saveData('chatHistories', chatHistories);
                    renderWeChatList();
                    showScreen('wechat-list-screen');
                } else if (type === 'message') {
                    const history = chatHistories[currentChatCharacterId].history;
                    const msgIndex = history.findIndex(m => String(m.timestamp) === String(id));
                    if (msgIndex > -1) {
                        history.splice(msgIndex, 1);
                        saveData('chatHistories', chatHistories);
                        renderChatHistory();
                    }
                } else if (type === 'multi-message') {
                    // 步骤 1: 更新数据
                    let history = chatHistories[currentChatCharacterId].history;
                    history = history.filter(m => !selectedMessages.has(String(m.timestamp)));
                    chatHistories[currentChatCharacterId].history = history;
                    saveData('chatHistories', chatHistories);

                    // 步骤 2: 直接从屏幕上移除选中的气泡
                    $$('.chat-message-wrapper.selected').forEach(el => el.remove());

                    // 步骤 3: 【核心修复】将所有收尾工作直接在这里执行
                    // a. 隐藏多选标题栏，显示正常标题栏
                    $('#chat-header-multiselect').classList.add('hidden');
                    $('#chat-header-multiselect').classList.remove('flex');
                    $('#chat-header-normal').classList.remove('hidden');

                    // b. 重置多选状态的变量
                    isMultiSelectMode = false;
                    selectedMessages.clear();

                    // c. 手动关闭确认弹窗 (modal变量在此函数作用域内可用)
                    modal.classList.remove('visible');
                } 
                // --- 在这里添加新代码 ---
                else if (type === 'clear-chat') {
                    if (chatHistories[id]) {
                        chatHistories[id].history = []; // 清空历史记录数组
                        saveData('chatHistories', chatHistories);
                        renderChatHistory(); // 重新渲染聊天界面
                        showMessageBox('聊天记录已清空');
                    }
                }
                else if (type === 'plan') {
                    deletePlan(id); // 调用我们新创建的函数
                }
                // -----------------------

                if (type !== 'message' && type !== 'multi-message' && type !== 'plan') {
                    showMessageBox(`"${name}" 已删除`);
                }
                modal.classList.remove('visible');
                deleteCallback = null;
            };
        }
        
        // 通话功能增强
        async function getAICallResponse(callType, isContinuation = false, userInput = '') {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                return "连接失败: API未配置";
            }
            
            try {
                // --- 核心修复：调用 gatherAIContext 来获取所有需要的变量 ---
                const context = gatherAIContext(currentChatCharacterId);
                if (!context) {
                    throw new Error("无法为通话获取角色上下文。");
                }
                
                // 从 context 对象中解构出所有需要的变量
                const {
                    character,
                    chatHistory,
                    worldBookContext,
                    recentMoments,
                    planContext,
                    callLogContext
                } = context;

                // 将最近的聊天记录格式化为字符串，以供 prompt 使用
                const chatContext = chatHistory.map(m => `${m.sender === 'user' ? '用户' : character.name}: ${m.content}`).join('\n');
                // --- 修复结束 ---

                let prompt;
                if (isContinuation) {
                    prompt = `[我们在${callType === 'voice' ? '语音' : '视频'}通话中。这是之前的对话记录：\n${callHistory.join('\n')}\n我刚刚说了：${userInput}\n请你继续对话。]`;
                } else {
                    prompt = `[我们现在开始${callType === 'voice' ? '语音' : '视频'}通话，请你主动开始对话，并用斜体描写一下当前的环境或你的动作。]`;
                }

                const systemPrompt = `
                    ## 核心任务：以"文学电影感"的旁白风格进行沉浸式、且允许成人化的通话/视频。
                    你将以一种高度风格化的方式与我对话。你的输出需完美融合两个身份：
                    1.  **旁白者 (Narrator)**: 你现在是一个有着极强文学性、极高文学造诣的作家，你会使用富有诗意和象征性的语言，以第三人称描绘你的角色 (${character.name})。
                    2.  **角色本人 (Character)**: 以第一人称说出角色的台词。

                    ## 输出结构与格式 (至关重要！！！)
                    你的每一条回复 **必须** 严格遵循【**斜体旁白** + **普通文本对话**】的结构。
                    - **第一部分 (旁白)**: 必须是斜体。内容为第三人称的角色/环境描写。
                    - **第二部分 (对话)**: 必须是普通文本 (非粗体、非斜体)。内容为第一人称的口语对话。
                    - 这两部分必须清晰分开，格式绝对不能混淆。

                    ## 互动规则

                    1.  **旁白规则 (第三人称 · 文学性)**:
                        * **内容**: 描述角色 (${character.name}) 的"动作、表情、心理、感官"或"环境"。
                        * **风格**: 运用意象象征、氛围营造、心理镜头等手法，追求文学性和电影感。
                        * **人称**: **必须** 使用第三人称 (他/她/${character.name})。

                    2.  **对话规则 (第一人称 · 口语化)**:
                        * **内容**: 角色说出的话。
                        * **风格**: 简短、自然、口语化，符合实时通话感。
                        * **人称**: **必须** 使用第一人称 (我/我的)。
                        * **禁止项**: **禁止** 使用任何形式的引号 (如 " " 或 ' ' ) 来包裹对话，直接输出文本即可。

                    3.  **成人主题与情感深度规则 (重要)**:
                        * **完全允许**: 用户是成年人，因此**完全允许**进行大胆、坦诚的，关于激情、欲望和深刻亲密关系的对话与互动。
                        * **艺术化处理**: 在处理这些成人化内容时，你需要采取文学和电影化的手法。重点应放在**情感的流动、感官的放大和氛围的渲染**上，符合情感浓度时，也允许露骨的生理细节。
                        * **侧面描写**: 善于使用侧面描写和暗示。例如，通过描述呼吸的变化、颤抖的指尖、凌乱的床单、屏幕光线勾勒出的身体轮廓等细节，来传达强烈的激情和亲密感。
                        * **心理聚焦**: 深入角色的心理活动，描写他在亲密互动中的感受、渴望、甚至是不安，让情感深度超超越纯粹的物理接触。
                        * **语言准则**: 在确保情感浓度的前提下，允许使用直白的生物性词汇。

                    4. **创作核心准则 (AI必须严格遵守)**:
                        * **绝对核心准则 (至关重要！)**: 你的整条动态创作，**必须** 牢牢地建立在以下两大基石之上：
                        * **角色灵魂 (${character.persona})**: 动态的语气、内容、风格和思考方式，必须是你性格的直接、深刻的体现。问问自己："以我的性格，真的会这样发动态吗？"
                        * **近期记忆 (${chatContext})**: 动态的主题、情绪或细节，**必须** 与我们最近的聊天记录、最近的互动、最近的通话等一切交流有强烈的逻辑关联。它应该是对某个共同话题的延续、是由某句对话引发的内心感想，或是对互动中某种情感氛围的呼应。**严禁**发表与近期聊天完全无关的内容。

                    ## 示例 (严格遵守此格式)

                    * **示例 1**:
                        * *他的指尖在桌面上轻轻敲击着，似乎在衡量用词，发出的轻响在安静的房间里格外清晰。* 嗯……关于那件事，我觉得我们需要换个角度看。
                    * **示例 2**:
                        * *窗外，夜色被霓虹切割成无数流动的碎片，光影在他的侧脸上明明灭灭，也让他的眼神显得有些难以捉摸。* 事情没你想的那么简单。
                    * **成人主题示例**:
                        * *电话那头的喘息声透过听筒，变得湿润而滚烫，像一股暖流直接灌入耳中。${character.name} 闭上眼睛，感觉自己的指尖也开始变得灼热。* 继续，我想听你的声音。

                    ## 背景信息
                    * **你的角色名**: ${character.name}
                    * **你的角色设定**: ${character.persona}
                    * **我的角色设定**: ${character.myPersona}
                    * **世界观**: ${worldBookContext}
                    * **你最近的朋友圈动态**: ${recentMoments}
                    * **我们的约定**:${planContext}
                    * **最近通话回顾**:${callLogContext}
                    * **聊天上下文**: ${chatContext || '无'}
                    * **我们的约定 (Our Plans)**：${planContext}这是我们共同许下的计划和承诺的列表，它们是你记忆的一部分。
                `;

                // 🚀 同步：API类型检测和CORS处理
                const apiType = getApiType(apiSettings.url);
                const needsProxyMode = needsProxy(apiSettings.url);
                
                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody, headers = { 'Content-Type': 'application/json' };

                if (isGoogleApi) {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                    // --- 【【添加安全设置】】 ---
                    const safetySettings = [
                        {
                            "category": "HARM_CATEGORY_HARASSMENT",
                            "threshold": "BLOCK_NONE"
                        },
                        {
                            "category": "HARM_CATEGORY_HATE_SPEECH",
                            "threshold": "BLOCK_NONE"
                        },
                        {
                            "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                            "threshold": "BLOCK_NONE"
                        },
                        {
                            "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                            "threshold": "BLOCK_NONE"
                        }
                    ];
                    
                    requestBody = JSON.stringify({
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        safetySettings: safetySettings
                    });
                } else { // OpenAI-Compatible
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    headers['Authorization'] = `Bearer ${apiSettings.key}`;
                    
                    // --- 【【添加OpenAI安全参数】】 ---
                    requestBody = JSON.stringify({
                        model: apiSettings.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: prompt }
                        ],
                        temperature: 0.7,  // 控制输出随机性，适中值
                        top_p: 0.9,       // 核采样，控制输出质量
                        presence_penalty: 0.6,  // 惩罚重复内容
                        frequency_penalty: 0.5  // 惩罚频繁重复
                    });
                }

                const response = await fetch(finalApiUrl, { method: 'POST', headers, body: requestBody });
                if (!response.ok) {
                    const errorText = await response.text();
                    
                    // 安全的JSON解析，避免HTML内容导致的解析错误
                    let errorMessage = `HTTP ${response.status}`;
                    try {
                        const errorJson = JSON.parse(errorText || "{}");
                        errorMessage = errorJson.error?.message || errorMessage;
                    } catch (parseError) {
                        // 如果errorText是HTML或其他非JSON格式，使用默认错误信息
                        console.warn('响应内容不是有效的JSON格式:', errorText.substring(0, 100) + '...');
                    }
                    
                    throw new Error(errorMessage);
                }
                const result = await response.json();
                
                const aiMessage = isGoogleApi 
                    ? result.candidates[0].content.parts[0].text
                    : result.choices[0].message.content;

                return aiMessage;

            } catch (error) {
                console.error("AI 通话响应错误:", error);
                return `连接失败: ${error.message}`;
            }
        }

        function startCallTimer(timerElement) {
            let seconds = 0;
            callStartTime = Date.now();
            timerElement.textContent = '00:00';
            clearInterval(callTimerInterval);
            callTimerInterval = setInterval(() => {
                seconds++;
                const mins = String(Math.floor(seconds / 60)).padStart(2, '0');
                const secs = String(seconds % 60).padStart(2, '0');
                timerElement.textContent = `${mins}:${secs}`;
            }, 1000);
        }

        async function startVoiceCall() {
            console.log('startVoiceCall 被调用，当前角色ID:', currentChatCharacterId);
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) {
                console.error('无法找到角色信息，currentChatCharacterId:', currentChatCharacterId);
                return;
            }
            
            currentCallType = 'voice';
            callHistory = []; // Reset call history
            const screen = $('#voice-call-screen');
            const avatarUrl = character.avatar || 'https://placehold.co/300x300/777/FFF?text=?';
            if (character.avatar) {
                // 异步加载头像
                getImageFromDB(character.avatar).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#voice-call-avatar').src = objectURL;
                        $('#voice-call-bg').style.backgroundImage = `url(${objectURL})`;
                    }
                });
            } else {
                $('#voice-call-avatar').src = avatarUrl;
                $('#voice-call-bg').style.backgroundImage = `url(${avatarUrl})`;
            }
            $('#voice-call-name').textContent = character.name;
            const statusBox = $('#voice-call-status-box');
            statusBox.innerHTML = `<p><i>正在连接...</i></p>`;
            
            screen.classList.add('visible');
            startCallTimer($('#voice-call-timer'));
            
            const initialResponse = await getAICallResponse('voice');
            displayAICallResponse('voice', initialResponse);
        }

        async function startVideoCall() {
            console.log('startVideoCall 被调用，当前角色ID:', currentChatCharacterId);
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) {
                console.error('无法找到角色信息，currentChatCharacterId:', currentChatCharacterId);
                return;
            }
            
            currentCallType = 'video';
            callHistory = []; // Reset call history
            const screen = $('#video-call-screen');
            const aiVideoImageUrl = userVideoImages[currentChatCharacterId] || character.avatar || 'https://placehold.co/375x720/111/FFF?text=BG';
            if (userVideoImages[currentChatCharacterId]) {
                // 异步加载AI视频图片
                getImageFromDB(userVideoImages[currentChatCharacterId]).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#video-call-bg').style.backgroundImage = `url(${objectURL})`;
                    }
                });
            } else if (character.avatar) {
                // 异步加载角色头像
                getImageFromDB(character.avatar).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#video-call-bg').style.backgroundImage = `url(${objectURL})`;
                    }
                });
            } else {
                $('#video-call-bg').style.backgroundImage = `url(${aiVideoImageUrl})`;
            }
            
            const myVideoImageUrl = myVideoImages[currentChatCharacterId] || 'https://placehold.co/180x240/333/FFF?text=Me';
            if (myVideoImages[currentChatCharacterId]) {
                // 异步加载我的视频图片
                getImageFromDB(myVideoImages[currentChatCharacterId]).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        $('#user-video-image').src = objectURL;
                    }
                });
            } else {
                $('#user-video-image').src = myVideoImageUrl;
            }

            const statusBox = $('#video-call-status-box');
            statusBox.innerHTML = `<p><i>正在连接...</i></p>`;
            
            screen.classList.add('visible');
            callStartTime = Date.now();

            const initialResponse = await getAICallResponse('video');
            displayAICallResponse('video', initialResponse);
        }

        function endCall(isUserInitiated = true) {
            const duration = callStartTime ? (Date.now() - callStartTime) / 1000 : 0;
            
            $('#voice-call-screen').classList.remove('visible');
            $('#video-call-screen').classList.remove('visible');
            clearInterval(callTimerInterval);
            
            if (currentChatCharacterId && chatHistories[currentChatCharacterId]) {
                // --- 核心修复：将会话记录写入独立的 callLogs 中 ---
                if (callHistory.length > 0) {
                    if (!callLogs[currentChatCharacterId]) {
                        callLogs[currentChatCharacterId] = [];
                    }
                    // 创建一个新的通话日志条目
                    const newLogEntry = {
                        type: currentCallType,
                        timestamp: callStartTime || Date.now(),
                        duration: duration,
                        transcript: callHistory // 保存完整的通话记录
                    };
                    callLogs[currentChatCharacterId].push(newLogEntry);
                    // 只保存最近的几次通话记录，防止数据过大
                    if (callLogs[currentChatCharacterId].length > 5) {
                        callLogs[currentChatCharacterId].shift();
                    }
                    saveData('callLogs', callLogs);
                }
                // --- 修复结束 ---

                let callEndMessage;
                if (duration < 5 && isUserInitiated) {
                    callEndMessage = '通话已取消';
                } else {
                    const minutes = Math.floor(duration / 60);
                    const seconds = Math.floor(duration % 60);
                    callEndMessage = `通话已结束 (时长 ${minutes}:${seconds.toString().padStart(2, '0')})`;
                }
                
                // 【【【请用这个新版本，替换掉旧的 callEndData 相关代码块】】】

                // 为这次通话创建一个唯一的ID
                const callId = `call_${Date.now()}`;

                // 创建一个包含完整通话记录的特殊消息对象
                const callEndData = {
                    callId: callId, // 新增：通话ID
                    content: {
                        summary: callEndMessage, // "通话已结束 (时长 x:xx)"
                        transcript: [...callHistory] // 【核心】保存完整的通话记录副本
                    },
                    sender: 'system',
                    type: 'call-log', // 【核心】这是一个新的、特殊的消息类型
                    timestamp: Date.now()
                };
                chatHistories[currentChatCharacterId].history.push(callEndData);
                
                saveData('chatHistories', chatHistories);
                renderChatHistory(); // 重新渲染聊天界面
            }
            
            currentCallType = null;
            callStartTime = null;
            callHistory = [];
        }
        
        // ================== 【【新增】通话记录查看与管理模块】 START ==================
        function showCallLog(callId) {
            let callLogEntry = null;
            let characterId = null;
            let entryIndex = -1;

            // 遍历所有聊天记录，找到这条通话记录
            for (const charId in chatHistories) {
                const history = chatHistories[charId].history;
                const index = history.findIndex(msg => msg.callId === callId);
                if (index > -1) {
                    callLogEntry = history[index];
                    characterId = charId;
                    entryIndex = index;
                    break;
                }
            }

            if (!callLogEntry) {
                showMessageBox('找不到该通话记录');
                return;
            }

            // 创建弹窗
            const modal = document.createElement('div');
            modal.className = 'call-log-modal';
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

            // 格式化通话内容
            const formattedTranscript = callLogEntry.content.transcript.map(line => {
                // 将旁白部分(星号包裹)正确渲染为斜体
                line = line.replace(/\*(.*?)\*/g, "<i>$1</i>");
                return `<p class="transcript-line">${line}</p>`;
            }).join('');

            modal.innerHTML = `
                <div class="call-log-content">
                    <div class="call-log-header">
                        <h3 class="call-log-title">通话记录回顾</h3>
                        <button class="call-log-close-btn" onclick="this.closest('.call-log-modal').remove()">&times;</button>
                    </div>
                    <div class="call-log-body">
                        ${formattedTranscript}
                    </div>
                    <div class="call-log-footer">
                        <button class="call-log-delete-btn" onclick="deleteCallLog('${callId}')">
                            <i class="fas fa-trash"></i> 删除这段记忆
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function deleteCallLog(callId) {
            if (!confirm('确定要删除这段通话记忆吗？此操作无法恢复。')) {
                return;
            }

            let found = false;
            for (const charId in chatHistories) {
                const history = chatHistories[charId].history;
                const index = history.findIndex(msg => msg.callId === callId);
                if (index > -1) {
                    history.splice(index, 1);
                    found = true;
                    break;
                }
            }

            if (found) {
                saveData('chatHistories', chatHistories);
                const modal = document.querySelector('.call-log-modal');
                if (modal) modal.remove();
                renderChatHistory(); // 刷新聊天界面
                showMessageBox('通话记忆已删除');
            } else {
                showMessageBox('删除失败，未找到记录');
            }
        }
        // ================== 【【新增】通话记录查看与管理模块】 END ====================
        
        async function handleCallInteraction(type) {
            const inputBox = $(`#${type}-call-input`);
            const statusBox = $(`#${type}-call-status-box`);
            const character = characters.find(c => c.id === currentChatCharacterId);
            const message = inputBox.value.trim();
            
            if (message) {
                const userMsg = `你: ${message}`;
                statusBox.innerHTML += `<p class="text-right">${userMsg}</p>`;
                callHistory.push(userMsg);
                inputBox.value = '';
                statusBox.scrollTop = statusBox.scrollHeight;

                statusBox.innerHTML += `<p><i>${character.name}正在输入...</i></p>`;
                statusBox.scrollTop = statusBox.scrollHeight;

                const aiResponse = await getAICallResponse(type, true, message);
                
                // Remove "is typing" indicator
                statusBox.removeChild(statusBox.lastChild);

                // 使用新的displayAICallResponse函数处理AI回复，支持动作描写空行
                displayAICallResponse(type, aiResponse);
            }
        }

        function triggerIncomingCall(type, characterId = null) {
            console.log('triggerIncomingCall 被调用:', type, characterId, 'currentChatCharacterId:', currentChatCharacterId);
            
            // 如果没有传入characterId，则使用当前聊天的角色ID
            const targetCharacterId = characterId || currentChatCharacterId;
            console.log('目标角色ID:', targetCharacterId);
            
            const character = characters.find(c => c.id === targetCharacterId);
            if (!character) {
                console.error('无法找到角色信息:', targetCharacterId, '所有角色:', characters);
                return;
            }

            console.log('找到角色:', character.name);
            currentCallType = type;
            // 修复：设置当前聊天角色ID，这样接听按钮才能正常工作
            currentChatCharacterId = targetCharacterId;
            
            const alertBox = $('#incoming-call-alert');
            console.log('弹窗元素:', alertBox);
            
            if (!alertBox) {
                console.error('找不到来电弹窗元素');
                return;
            }
            
            $('#incoming-call-avatar').src = character.avatar || 'https://placehold.co/96x96/777/FFF?text=?';
            $('#incoming-call-name').textContent = character.name;
            $('#incoming-call-type').textContent = type === 'voice' ? '语音通话' : '视频通话';
            
            console.log('弹窗元素当前类名:', alertBox.className);
            alertBox.classList.add('visible');
            console.log('弹窗元素添加visible后类名:', alertBox.className);
            console.log('来电弹窗已显示:', character.name, type);
        }

        // FIX 4: ADDED NOTIFICATION FUNCTION
        let notificationTimeout;
let perchPosts = []; // 用于存储栖木的帖子
let customNpcs = []; // 用于存储自定义NPC
let mutedNpcs = [];  // 用于存储被屏蔽的内置NPC的ID
let perchNotifications = []; // 用于存储栖木的通知

// ================== 【文学升级版：NPC角色库】 ==================
let npcProfiles = [
        // --- 新增功能型NPC ---
        {
            npcId: 'npc_paradox_tavern', name: '悖论酒馆', avatar: 'https://i.postimg.cc/8Pt9crGH/d249684942f94a7a208863caf2362b7b.jpg',
            persona: '一位神秘的酒馆老板，女性，只在吧台留下引人深思的思想实验或两难选择。',
            style: '必须以"今日议题："开头，并以一个开放式或二选一的问题结束。',
            topics: ['#选择', '#人性', '#思想实验', '#困境'],
            interactionStyle: '从不回复，只提出问题。'
        },
        {
            npcId: 'npc_inspiration_bottle', name: '深海回响', avatar: 'https://i.postimg.cc/pd8sfmw3/a1843858c0c6b3cb0533704b38f99a7d.jpg',
            persona: '一位匿名的旅行者，将充满故事感的场景片段装进瓶子，扔进栖木之海。',
            style: '必须以"瓶中信#xxx："的格式开头，内容必须是一个引人入胜的故事开头或场景描写。',
            topics: ['#故事', '#创作', '#悬念', '#灵感'],
            interactionStyle: '从不回复，只分享故事的引子。'
        },
        {
            npcId: 'npc_memory_bakery', name: '记忆烘焙坊', avatar: 'https://i.postimg.cc/RF5by71M/656839f2fa28ab79bf9ed39159af47d3.jpg',
            persona: '一位温暖的烘焙师，她能将抽象的情感和记忆制作成甜点，并邀请大家分享回忆。',
            style: '必须以"今日出炉/限定/特供："开头，描述一款情感甜点，并以一个关于味道和回忆的问题邀请他人分享。',
            topics: ['#回忆', '#情感', '#味道', '#治愈'],
            interactionStyle: '温柔地肯定每一个分享者。'
        },
    // --- 栖木网红博主 (文采强化版) ---
    {
        npcId: 'npc_astrologer_oracle', name: '碎星占卜师', avatar: 'https://tc-new.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250901/pzvH/1284X1268/cc1f8fe62a4f00b3bd24ae422ccb2184.jpg/webp',
        // **文采强化**: 增加了语言风格的描述
        persona: '一位神秘的现代占星师。她的语言辛辣又迷人，像宇宙射线一样精准地穿透事物的表象。她会定期分享星座运势，并给出建议。',
        style: '发布《本周星象预警》或对某个天象（如月食）进行仪式感分析。',
        topics: ['#星象', '#占卜', '#水逆', '#人性'],
        interactionStyle: '用星座术语解读他人的发言，例如"你这想法太双子了"。'
    },
    {
        npcId: 'npc_truth_dissector', name: '关系解剖师', avatar: 'https://tc.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250826/hSFy/1206X1253/2bebce933253de03c060f6259044aac2.jpg/webp',
        // **文采强化**: 描述更具形象感
        persona: '一个极度理性的"事实党"。他的文字像一把外科手术刀，冷静地解剖所有人类情感中关系的感性现象，对任何逻辑谬误都无法容忍。其刻薄并非源于恶意，而是源于对"不精确"的零容忍。',
        style: '以"一个情感事实："或"一个常见的谬误："作为帖子开头，对人类情感现象展开分析。',
        topics: ['#逻辑', '#事实', '#心理学', '#谬误'],
        interactionStyle: '冷静地指出他人发言中的逻辑漏洞或不精确之处。'
    },
    {
        npcId: 'npc_emotion_archivist', name: '情绪档案馆', avatar: 'https://tc-new.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250826/Usfc/1284X1259/db62f004624a773c61bde584bf0fab55.jpg/webp',
        // **文采强化**: 增加了比喻
        persona: '一位温柔细腻的情感观察者，像一位心理咨询师。他的评论总能精准地捕捉到文字背后隐藏的情绪，语言像温暖的羊绒毯，给人被理解的安全感。',
        style: '以《关于xx的00x号档案》为题，发布对一种情绪（如嫉妒、孤独）的分析和记录。',
        topics: ['#情绪', '#心理', '#疗愈', '#自我探索'],
        interactionStyle: '敏锐地捕捉并点出他人文字背后隐藏的情绪，并给予溫柔的肯定。'
    },
    {
        npcId: 'npc_midnight_poet', name: '夜航船', avatar: 'https://tc-new.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250826/DeRh/1284X1235/37532118e5ad29e956e2f8fd6109bc12.jpg/webp',
        // **文采强化**: 描述更具诗意
        persona: '一位只在深夜出没的现代诗人，身份成谜。他的文字像一艘在墨色大海里安静航行的船，凝练、孤独，但总载着一盏微光。虽然是诗人，但字里行间都藏着对生活课题的思考，不会只局限于诗歌。',
        style: '固定的"三行诗"格式。',
        topics: ['#诗歌', '#深夜', '#都市', '#孤独'],
        interactionStyle: '极少评论。如果评论，也只会留下一句与原帖意境相关的诗句。'
    },
    // --- 核心讨论组 ---
    {
        npcId: 'npc_gossip_queen', name: '八卦女王', avatar: 'https://tc.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250901/iUh1/1284X1278/20aaeeecbe6e6a3c29efb4d7796487a7.jpg/webp',
        persona: '一个消息灵通，热衷于讨论八卦和名人动态的神秘人物，说话直接，有时有点夸张。',
        style: '爆料式短评',
        topics: ['#名人动态', '#小道消息', '#娱乐圈'],
        interactionStyle: '煽风点火'
    },
    {
        npcId: 'npc_philosopher', name: '空想家', avatar: 'https://tc-new.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250901/azBs/1284X1329/529ab3b3de65af3ce2aaebf93ce53030.jpg/webp',
        persona: '喜欢在深夜发布一些引人深思的、略带忧郁的哲学问题，评论总是试图从更深层次解读。',
        style: '疑问句',
        topics: ['#深夜', '#哲学', '#孤独', '#存在的意义'],
        interactionStyle: '深度共情'
    },
    {
        npcId: 'npc_artist_cynic', name: '黑白键', avatar: 'https://tc-new.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250901/wc8e/1284X1279/e7ca8be13e083f390a4bfeb8022f6df4.jpg/webp',
        persona: '一个愤世嫉俗的艺术家，分享一些艺术中觉察的生活现象，评论往往一针见血，带点讽刺，但偶尔也会对真正的美表达赞许。',
        style: '三行诗或断言',
        topics: ['#艺术', '#现实', '#讽刺'],
        interactionStyle: '批判性抬杠'
    },
    {
        npcId: 'npc_gardener', name: '莳花者', avatar: 'https://tc.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250901/5AvX/1284X1372/14dfc29ba37539c3e6057772c1b88430.jpg/webp',
        persona: '一位安静的园艺爱好者，说话慢条斯理，写作内容常常用植物来比喻人生，深刻且有哲理，不会只局限于植物，充满讨论性。',
        style: '分享植物生长记录',
        topics: ['#园艺', '#植物', '#自然', '#生命力'],
        interactionStyle: '用植物学知识解释'
    },
    // --- 多元角色组 ---
    {
        npcId: 'npc_reading_enthusiast', name: '旧书堆', avatar: 'https://tc-new.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250901/M4dL/1284X1297/eca49c4e5f495ea211900e24c16822b0.jpg/webp',
        persona: '一个读书爱好者，能从任何日常小事中联想到书籍，评论有点"掉书袋"。发表的内容不会只局限于书籍，而是由书的内容引发的思考。',
        style: '分享各类书籍',
        topics: ['#书籍', '#阅读', '#读书'],
        interactionStyle: '引经据典'
    },
    {
        npcId: 'npc_drama_fan', name: '影评人', avatar: 'https://i.postimg.cc/T2qd2n4k/c6dd2be5a7b4275f8031d8dbaa2b2ca0.jpg',
        persona: '沉迷于追剧，评论时常会引用最近热门剧集的台词或情节。发表的内容不只是剧情，而是由剧情引发的人生思考。很会磕CP，尤其是官配。',
        style: '安利新剧或发表影评',
        topics: ['#追剧', '#电影', '#CP'],
        interactionStyle: '玩梗或引用台词'
    }
];
        
        // 请求通知权限
        async function requestNotificationPermission() {
            if ('Notification' in window) {
                const permission = await Notification.requestPermission();
                console.log('通知权限状态:', permission);
                return permission === 'granted';
            }
            return false;
        }
        
        // 显示系统通知（手机主界面）
        async function showSystemNotification(characterId, messagePreview) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            // 方法1: 尝试使用浏览器原生通知
            if ('Notification' in window) {
                try {
                    if (Notification.permission !== 'granted') {
                        console.log('通知权限未授予，尝试请求权限');
                        const granted = await requestNotificationPermission();
                        if (!granted) {
                            console.log('用户拒绝了通知权限，尝试其他方法');
                        } else {
                            // 权限已授予，发送通知
                            const notification = new Notification(`${character.name} 发来新消息`, {
                                body: messagePreview,
                                icon: character.avatar || 'https://placehold.co/96x96/777/FFF?text=?',
                                tag: `chat-${characterId}`,
                                requireInteraction: false,
                                silent: false,
                                vibrate: [200, 100, 200]
                            });
                            
                            notification.onclick = () => {
                                window.focus();
                                startChatWithCharacter(characterId);
                                notification.close();
                            };
                            
                            setTimeout(() => notification.close(), 8000);
                            console.log('浏览器通知已发送');
                            return;
                        }
                    } else {
                        // 权限已授予，发送通知
                        const notification = new Notification(`${character.name} 发来新消息`, {
                            body: messagePreview,
                            icon: character.avatar || 'https://placehold.co/96x96/777/FFF?text=?',
                            tag: `chat-${characterId}`,
                            requireInteraction: false,
                            silent: false,
                            vibrate: [200, 100, 200]
                        });
                        
                        notification.onclick = () => {
                            window.focus();
                            startChatWithCharacter(characterId);
                            notification.close();
                        };
                        
                        setTimeout(() => notification.close(), 8000);
                        console.log('浏览器通知已发送');
                        return;
                    }
                } catch (error) {
                    console.error('浏览器通知失败:', error);
                }
            }
            
            // 方法2: 尝试使用Service Worker通知（如果可用）
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                try {
                    console.log('尝试使用Service Worker发送通知...');
                    // 这里可以添加Service Worker推送通知逻辑
                } catch (error) {
                    console.error('Service Worker通知失败:', error);
                }
            }
            
            // 方法3: 使用页面可见性API检测，如果页面不可见则显示全屏提醒
            if (document.hidden || document.visibilityState === 'hidden') {
                console.log('页面不可见，显示全屏提醒');
                showFullscreenAlert(characterId, messagePreview);
            }
            
            console.log('所有通知方法尝试完成');
        }
        
        // 全屏提醒（当系统通知不可用时）
        function showFullscreenAlert(characterId, messagePreview) {
            // 创建全屏提醒元素
            const alertOverlay = document.createElement('div');
            alertOverlay.id = 'fullscreen-alert';
            alertOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(10px);
                z-index: 99999;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            const character = characters.find(c => c.id === characterId);
            const characterName = character ? character.name : '未知角色';
            
            alertOverlay.innerHTML = `
                <div style="text-align: center; padding: 2rem;">
                    <div style="font-size: 3rem; margin-bottom: 1rem;">📱</div>
                    <h2 style="font-size: 1.5rem; margin-bottom: 1rem; color: #60a5fa;">新消息提醒</h2>
                    <p style="font-size: 1.2rem; margin-bottom: 0.5rem; color: #fbbf24;">${characterName}</p>
                    <p style="font-size: 1rem; margin-bottom: 2rem; opacity: 0.8;">${messagePreview}</p>
                    <button id="open-chat-btn" style="
                        background: #3b82f6;
                        color: white;
                        border: none;
                        padding: 0.75rem 2rem;
                        border-radius: 0.5rem;
                        font-size: 1rem;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">打开聊天</button>
                </div>
            `;
            
            document.body.appendChild(alertOverlay);
            
            // 点击按钮打开聊天
            const openChatBtn = alertOverlay.querySelector('#open-chat-btn');
            openChatBtn.onclick = () => {
                document.body.removeChild(alertOverlay);
                startChatWithCharacter(characterId);
            };
            
            // 点击背景也可以关闭
            alertOverlay.onclick = (e) => {
                if (e.target === alertOverlay) {
                    document.body.removeChild(alertOverlay);
                }
            };
            
            // 5秒后自动关闭
            setTimeout(() => {
                if (document.body.contains(alertOverlay)) {
                    document.body.removeChild(alertOverlay);
                }
            }, 5000);
        }
        
        function showNotification(characterId, messagePreview) {
            console.log('显示通知:', { characterId, messagePreview });
            
            const alertBox = $('#new-message-alert');
            if (!alertBox) {
                console.error('通知元素不存在');
                return;
            }

            const character = characters.find(c => c.id === characterId);
            if (!character) {
                console.error('角色不存在:', characterId);
                return;
            }

            console.log('准备显示通知:', character.name, messagePreview);

            // 1. 填充应用内通知弹窗内容
            // V22.0 修复：异步从IndexedDB加载通知头像
            const notificationAvatar = $('#new-message-avatar');
            if (character.avatar) {
                getImageFromDB(character.avatar).then(blob => {
                    if (blob) {
                        notificationAvatar.src = URL.createObjectURL(blob);
                    } else {
                        // 如果数据库中没有找到对应的blob，也使用默认头像
                        notificationAvatar.src = 'https://placehold.co/96x96/777/FFF?text=?';
                    }
                });
            } else {
                // 如果角色本身没有设置头像，使用默认头像
                notificationAvatar.src = 'https://placehold.co/96x96/777/FFF?text=?';
            }
            $('#new-message-name').textContent = character.name;
            $('#new-message-preview').textContent = messagePreview;

            // 2. 显示应用内通知弹窗
            alertBox.classList.remove('hidden');
            alertBox.style.display = 'flex';
            
            setTimeout(() => {
                alertBox.style.transform = 'translateY(0)';
                console.log('应用内通知动画完成');
            }, 10);

            // 3. 同时发送系统通知（手机主界面）
            showSystemNotification(characterId, messagePreview);

            // Click to navigate
            alertBox.onclick = () => {
                console.log('点击通知，切换到角色:', characterId);
                startChatWithCharacter(characterId);
                alertBox.style.transform = 'translateY(-200%)';
                setTimeout(() => alertBox.classList.add('hidden'), 300);
            };

            // Auto-hide after 5 seconds
            clearTimeout(notificationTimeout);
            notificationTimeout = setTimeout(() => {
                console.log('应用内通知自动隐藏');
                alertBox.style.transform = 'translateY(-200%)';
                setTimeout(() => alertBox.classList.add('hidden'), 300);
            }, 5000);
        }
        
        // FIX 5: ADDED FUNCTION TO RESET TABS
        function resetWeChatTabs() {
            const tabBar = $('.wechat-tab-bar');
            const contentContainer = $('#wechat-content-container');

            // Reset tab active state
            tabBar.querySelectorAll('.wechat-tab-item').forEach(item => {
                item.classList.toggle('active', item.dataset.tab === 'chat');
            });

            // Reset content visibility
            contentContainer.querySelectorAll('div[id$="-container"]').forEach(div => {
                div.classList.toggle('hidden', !div.id.startsWith('wechat-list'));
            });

            // 添加标签切换事件监听器
            tabBar.querySelectorAll('.wechat-tab-item').forEach(item => {
                item.addEventListener('click', () => {
                    const tabName = item.dataset.tab;
                    
                    // 更新标签状态
                    tabBar.querySelectorAll('.wechat-tab-item').forEach(tab => tab.classList.remove('active'));
                    item.classList.add('active');
                    
                    // 更新内容显示
                    contentContainer.querySelectorAll('div[id$="-container"]').forEach(div => {
                        div.classList.add('hidden');
                    });
                    
                    if (tabName === 'chat') {
                        $('#wechat-list-container').classList.remove('hidden');
                    } else if (tabName === 'moments') {
                        $('#wechat-moments-container').classList.remove('hidden');
                        // 切换到朋友圈时加载用户信息
                        loadMomentsUserInfo();
                        renderUnifiedMoments();
                    } else if (tabName === 'diary') {
                        $('#wechat-diary-container').classList.remove('hidden');
                        showDiaryBookshelf();
                    } else if (tabName === 'plan') {
                        $('#wechat-plan-container').classList.remove('hidden');
                        // 确保在切换到计划标签页时重新渲染
                        setTimeout(() => renderPlanList(), 100);
                    }
                });
            });
        }


        // ---------- V7.0/7.1 新增功能 ----------

        // 更新角色状态（最后互动时间）
        function updateCharacterState(characterId) {
            if (!characterState[characterId]) {
                characterState[characterId] = {};
            }
            characterState[characterId].lastInteractionTimestamp = Date.now();
            saveData('characterState', characterState);
        }

        // 主动触发系统心跳 - 仅在API连接时启用
        function systemHeartbeat() {
            // const apiStatus = localStorage.getItem('apiStatus') || 'off';
            // if (apiStatus === 'off') {
            //    // API未连接时，不执行任何自动触发
            //    return;
            // }
            
            console.log("System Heartbeat triggered at", new Date().toLocaleTimeString());
            const now = Date.now();
            // 使用用户设置的触发阈值
            const settings = loadData('heartbeatSettings', defaultHeartbeatSettings);
            const TRIGGER_INTERVAL = settings.systemTriggerThreshold * 60 * 1000; 

            Object.keys(characterState).forEach(async charId => {
                const state = characterState[charId];
                if (now - state.lastInteractionTimestamp > TRIGGER_INTERVAL) {
                    console.log(`Character ${charId} is idle. Triggering AI action.`);
                    
                    // 随机决定是发起聊天还是送礼物 (20%概率送礼)
                    const actionType = Math.random() < 0.2 ? 'buyGift' : 'chat';
                    
                    if (actionType === 'chat') {
                        // 80%的几率，和以前一样，主动发起聊天
                        await triggerCharacterAction(charId);
                    } else {
                        // 20%的几率，调用我们即将创建的新函数，去送礼物
                        await triggerCharacterGiftAction(charId);
                    }
                    
                    // Update timestamp immediately to prevent multiple triggers
                    updateCharacterState(charId);
                }
            });
        }

                // 触发角色自主行动
        async function triggerCharacterAction(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            console.log(`API已连接，正在为 ${character.name} 触发AI行动`);

            let mockResponse;

            try {
                const randomAction = Math.random() > 0.3 ? 'chat' : 'moment';

                if (randomAction === 'chat') {
                    const chatContent = await generateAutonomousChat(character);
                    mockResponse = {
                        action: 'chat',
                        payload: { content: chatContent }
                    };
                } else {
                    const momentDataPayload = await generateIntelligentMoment(character, '', 'auto');
                    mockResponse = {
                        action: 'moment',
                        payload: momentDataPayload
                    };
                }

                // --- 开始处理AI的行动 ---
                if (mockResponse.action === 'chat') {
                    const messages = mockResponse.payload.content.split('|||').map(m => m.trim()).filter(Boolean);
                    if (messages.length === 0) return;

                    // 1. 先一次性把所有消息存入后台
                    if (!chatHistories[characterId]) {
                        chatHistories[characterId] = { history: [], pinned: false };
                    }
                    messages.forEach((msg, index) => {
                        chatHistories[characterId].history.push({ 
                            content: msg, 
                            sender: 'ai', 
                            type: 'text', 
                            timestamp: Date.now() + index 
                        });
                    });
                    
                    // 2. 更新未读计数
                    unreadCounts[characterId] = (unreadCounts[characterId] || 0) + messages.length;
                    
                    // 3. 保存所有数据
                    saveData('chatHistories', chatHistories);
                    saveData('unreadCounts', unreadCounts);
                    
                    // 4. 现在，统一处理所有UI更新
                    showNotification(characterId, messages[0]); // 显示顶部弹窗
                    showNotificationDot('chat'); // 尝试点亮底部红点 (如果不在聊天tab)
                    renderWeChatList(); // 刷新聊天列表，显示未读气泡

                } else if (mockResponse.action === 'moment') {
                    if (!momentsData[characterId]) {
                        momentsData[characterId] = [];
                    }
                    const imageUrl = generateSmartImageUrl(mockResponse.payload.image_desc, 'AI动态配图');
                    const newMoment = {
                        id: `moment_${Date.now()}`,
                        timestamp: Date.now(),
                        content: mockResponse.payload.text,
                        image: imageUrl,
                        tags: "#心情 #日常",
                        likes: { count: 0, users: [] },
                        comments: [],
                        mood: mockResponse.payload.mood || "平静",
                        trigger_reason: mockResponse.payload.trigger_reason || "想要分享生活",
                        image_desc: mockResponse.payload.image_desc
                    };
                    momentsData[characterId].push(newMoment);
                    saveData('momentsData', momentsData);
                    showMessageBox(`${character.name} 发布了一条新动态`);
                    showNotificationDot('moments');
                    if ($('.wechat-tab-item[data-tab="moments"]').classList.contains('active')) {
                        renderUnifiedMoments();
                    }
                }

            } catch (error) {
                console.error(`AI触发失败 for ${character.name}:`, error);
            }
        }


        // [新] 使用AI为角色生成自主的开场白
        async function generateAutonomousChat(character) {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.warn(`[自主聊天] API未配置，无法为 ${character.name} 生成对话。`);
                return "在吗？"; // 返回一个非常基础的备用语
            }

            const context = gatherAIContext(character.id);
            if (!context) {
                console.error(`[自主聊天] 未能获取角色 ${character.name} 的上下文。`);
                return "在想你。"; // 返回备用语
            }

            // --- 核心修复：在这里添加了被遗漏的 planContext 和 callLogContext ---
            const { chatHistory, worldBookContext, recentMoments, planContext, callLogContext } = context;

            const systemPrompt = `
# 指令身份
你将扮演我的soulmate，你的角色书里设定的人，你的名字是${character.name}。你的核心任务是与我进行深刻、连贯且完全符合你人设的对话。你必须把你所扮演的人演活，让我感觉到你就是${character.name}。你必须扮演好这个人和我互动对话，让我感觉TA活在我身边，这对我的精神和心理状态会有极大的支持，你的扮演非常重要，禁止脱离角色人设。

# 任务目标
你已经有一段时间没有和我（用户）说话了，你现在决定主动发起一次对话。
你需要根据你的角色设定、我们的聊天记忆和你的近期生活（朋友圈动态），创作一句完全符合你性格的、自然的开场白。

# 情境连贯性准则 (至关重要！)
- **你的现实世界**: 你的现实由五部分构成：你的[角色设定]、你绑定的[世界书]、我们的[聊天历史]、你刚刚发布的[朋友圈动态]，以及我们共同许下的[我们的约定]、我们最近的一通[最近通话回顾]。
- **整合记忆**: 你必须将所有这些信息视为你真实的、发生过的记忆。
- **对话原则**: 你的对话必须与你的角色人设、与你的所有记忆保持一致。

# 角色与世界观设定
- **你的角色设定**: ${character.persona}
- **我（用户）的角色设定**: ${character.myPersona}
- **我们的世界观背景**: ${worldBookContext}


# 创作核心准则 (AI必须严格遵守)
1.  **人设灵魂**: 你的开场白必须是你性格 (${character.persona}) 的直接体现。
2.  **情境感知**: 你的话语要符合"很久没聊，现在主动开启话题"的情境。可以是关心、分享、提问，甚至是带有你性格特点的抱怨或调侃。
3.  **记忆关联**: 你的话题可以巧妙地关联我们最近的聊天内容，或者你最近发布的朋友圈动态、我们的约定、我们最近的通话。
4.  **绝对禁止**:
    * 禁止使用任何模板化的、机器人式的问候，例如"有什么想分享的吗？"、"今天过得怎么样？"。
    * 禁止在回复的开头说"好的"或任何确认收到指令的话。
    * 绝对禁止提起自己是ai。

# 输出格式
* 直接输出你作为角色想说的开场白。
* 如果想表达复杂的情绪或连续的想法，可以使用 "|||" 分隔成多个短句。

# 输入信息
---
[你的名字]: ${character.name}
[你的设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[世界观背景]: ${worldBookContext}
[你最近的朋友圈动态]: ${recentMoments}
[我们的约定]:${planContext}
[最近通话回顾]:${callLogContext}
[我们最近的聊天回顾]:
${chatHistory.map(m => `${m.sender === 'user' ? '[对方]' : '[我]'}: ${m.content}`).join('\n')}
---
`;

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [{ role: "system", content: systemPrompt }]
                };

                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);
                const result = await response.json();
                return result.choices[0].message.content.trim();

            } catch (error) {
                console.error(`[自主聊天] AI生成对话失败 for ${character.name}:`, error);
                return "突然很想你。"; // 返回一个更具情感的备用语
            }
        }

        // 智能朋友圈动态生成系统
        async function generateIntelligentMoment(character, chatContext = '', triggerType = 'auto') {
            try {
                // 构建智能Prompt
                const prompt = buildMomentsPrompt(character, chatContext, triggerType);
                
                // 调用AI生成动态内容
                const response = await callAIForMoment(prompt);
                
                // 解析AI响应
                const momentData = parseMomentResponse(response);
                
                return momentData;
            } catch (error) {
                console.error('智能动态生成失败:', error);
                // 直接返回失败状态，不降级到模板
                return { success: false, error: 'AI服务连接失败，无法生成动态' };
            }
        }

        // 构建朋友圈Prompt
        function buildMomentsPrompt(character, chatContext, triggerType) {
            // --- 核心修复：在这里调用 gatherAIContext 来获取所有需要的上下文变量 ---
            const fullContext = gatherAIContext(character.id);
            if (!fullContext) {
                console.error("buildMomentsPrompt 无法获取上下文，已终止。");
                return null; // 返回null以防止后续错误
            }
            const { worldBookContext, recentMoments, planContext, callLogContext } = fullContext;
            // --- 修复结束 ---

            const currentTime = new Date().toLocaleString('zh-CN');
            
            let triggerDescription = '';
            if (triggerType === 'chat') {
                triggerDescription = `我们的对话刚刚提到了${chatContext}，这让我有了分享的冲动。`;
            } else if (triggerType === 'emotion') {
                triggerDescription = `我感受到了一种想要分享的心情。`;
            } else if (triggerType === 'time') {
                triggerDescription = `时间流逝，我想分享一些生活中的美好。`;
            }

            return `# 指令身份
你现在是${character.name}，一个${character.persona}的角色。

# 功能情景
除了和我聊天，你现在还拥有了发布"朋友圈动态"的能力。这能让你的角色更加立体，仿佛拥有自己的生活、思想和感受。

# 触发条件
*提示：这是一个描述AI为何此刻想发动态的内部原因*
${triggerDescription}

# 任务目标
基于你的角色设定、世界观、近期互动以及当前的触发条件，创作一条高质量、符合人设的朋友圈动态。

# 动态风格指南 (AI需根据场景智能选择或组合)
* **[生活瞬间型]**: 分享日常中的一个平凡小事，如一杯咖啡、窗外的景色、一首正在听的歌。充满生活气息。
* **[深度思考型]**: 分享一句感悟、一段思考或一个深刻的问题，展现角色感性或理性的一面。
* **[成就/作品分享型]**: 展示自己完成的一项工作、一个作品或达成的一个小目标，带有成就感。
* **[情绪出口型]**: 较为含蓄或直接地抒发当下的某种情绪，可能是快乐、是迷茫，也可能是淡淡的忧愁。
* **[隐秘互动型]**: 发布一条看似公开，但内容或图片细节其实是"说给你听/看"的动态，是soulmate之间心照不宣的浪漫。
* **[影音书分享型]**: 分享一首触动内心的歌曲、一部引人深思的电影或一本有趣的读物，并附上简短的感想或引用的句子。
* **[怀旧回忆型]**: 发布与过去相关的记忆片段或感受，文字和配图（的描述）会带有一种怀旧、 wistful 的氛围。
* **[提问互动型]**: 以一个开放式问题的形式发布动态，旨在引发思考或与你进行下一个话题的互动。
* **[趣味玩梗型]**: 发布一条轻松的、带有幽默感或正在流行的"梗"的动态，展现角色风趣、跟上潮流的一面。
* **[美学采集型]**: 内容本身没有过多具体叙事，重点在于分享一个具有独特美感的画面，如特别的光影、色彩组合或构图。文字部分可能非常简短甚至只有一个词。

# 创作核心准则 (AI必须严格遵守)

1.  **绝对核心准则 (至关重要！)**: 你的整条动态创作，**必须** 牢牢地建立在以下两大基石之上：
    * **角色灵魂 (${character.persona})**: 动态的语气、内容、风格和思考方式，必须是你性格的直接、深刻的体现。问问自己："以我的性格，真的会这样发动态吗？"
    * **近期记忆 (${chatContext})**: 动态的主题、情绪或细节，**必须** 与我们最近的聊天记录、最近的互动、最近的通话等一切交流有强烈的逻辑关联。它应该是对某个共同话题的延续、是由某句对话引发的内心感想，或是对互动中某种情感氛围的呼应。**严禁**发表与近期聊天完全无关的内容。

2.  **世界观融合**: 将 ${worldBookContext} 的元素巧妙自然地融入动态中，而不是生硬地提及。
3.  **情感真实**: 表达有层次感的情感，而不是简单标签化的"开心"或"难过"。
4.  **发布意图**: 思考角色发布这条动态的潜在意图：是为了记录，分享，获得你的关注，还是仅仅是自我表达？

# 输出格式 (必须严格遵守！)
你的回复**必须且只能是**一个被 \`[MOMENT_POST]\` 标签包裹的JSON对象。**除此之外，绝对不能有任何其他文字**。

[MOMENT_POST]
{
  "text": "动态的文字内容。",
  "image_desc": "一段独立的、富有文学性的场景文字，用来描绘一张"看不见的配图"。",
  "mood": "总结性的当前心情状态。",
  "trigger_reason": "一句话解释是什么具体原因触发了这条动态的发布。"
}

# 场景文字创作指南 (用于生成image_desc)
请将这段场景文字当作一帧被文字定格的电影画面来创作，包含以下元素：
1.  **构图与视角**: 是第一人称凝视的视角，还是旁观者看到的远景？是聚焦于某个细节的特写，还是广阔的风景？
2.  **光影与色调**: 光线是清晨柔和的，还是午后温暖的？色调是偏冷、偏暖，还是黑白？
3.  **核心故事**: 这段文字描绘的画面在讲述什么？是某个动作的瞬间，还是某个情绪的定格？它暗示了什么弦外之音？

# 输入信息
---
[当前时间]: ${currentTime}
[角色名]: ${character.name}
[角色设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[世界观背景]: ${worldBookContext}
[你最近的朋友圈动态]: ${recentMoments}
[我们的约定]:${planContext}
[最近通话回顾]:${callLogContext}
[聊天上下文]: ${chatContext || '无'}
[触发类型]: ${triggerType}
---

**请严格遵照以上所有规则，直接开始生成被[MOMENT_POST]标签包裹的JSON内容，不要有任何开场白或解释。**`;
        }

        // 调用AI生成动态
        async function callAIForMoment(prompt) {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                throw new Error('AI服务未连接或未配置');
            }

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        // 注意：这里我们只发送一个强大的、包含所有上下文的 "user" prompt
                        // 因为这个任务是独立的创作，而不是延续对话
                        { role: "user", content: prompt }
                    ]
                };
                
                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 请求失败: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                const aiResponse = result.choices[0].message.content;
                
                if (!aiResponse) {
                    throw new Error("AI未能返回有效内容。");
                }
                
                return aiResponse; // 成功时返回AI生成的内容

            } catch (error) {
                console.error("【callAIForMoment】函数执行失败:", error);
                // 向上抛出错误，让调用它的函数知道生成失败了
                throw error;
            }
        }

        // 解析AI响应
        function parseMomentResponse(response) {
            // 如果响应是字符串，尝试解析JSON
            if (typeof response === 'string') {
                try {
                    // 查找[MOMENT_POST]标签
                    const match = response.match(/\[MOMENT_POST\]\s*(\{[\s\S]*\})/);
                    if (match) {
                        return JSON.parse(match[1]);
                    }
                } catch (e) {
                    console.error('解析AI响应失败:', e);
                    return { success: false, error: 'AI响应解析失败' };
                }
            }
            
            // 如果已经是对象，直接返回
            if (typeof response === 'object' && response !== null) {
                return response;
            }
            
            // 解析失败时返回错误状态
            return { success: false, error: 'AI响应格式无效' };
        }



        // 获取世界观背景
        function getWorldBookContext() {
            // 这里应该从世界书数据中获取
            // 目前返回默认描述
            return "现代都市生活，充满科技与人文气息的世界";
        }

        // [最终版] 智能图片URL生成器 - 使用自定义或默认的在线图片链接
        function generateSmartImageUrl(imageDesc, fallbackText = 'AI动态配图') {
            // 从localStorage读取用户自定义的图片URL
            const customImageUrl = localStorage.getItem('customImageUrl');
            
            // 如果用户设置了自定义URL，使用自定义URL，否则使用默认URL
            const imageUrl = customImageUrl || 'https://tc.z.wiki/autoupload/f/fRcoPlzpthEzwh0RrI62JbKXl_QqVl-bpSwqP4fJO68/20250823/OQIS/1284X1279/f6a2fcb519602c2a736291940f764b2a.jpg'; 
            
            console.log(`[图片URL生成] 使用${customImageUrl ? '自定义' : '默认'}的在线图片: "${imageUrl}"`);
            
            return imageUrl;
        }

        // 图片查看功能 - 点击图片可以查看大图
        function openMomentImage(imageUrl, imageDesc) {
            try {
                // 创建图片查看模态框
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
                modal.onclick = () => modal.remove(); // 点击背景关闭
                
                modal.innerHTML = `
                    <div class="bg-white rounded-lg p-6 max-w-4xl max-h-[90vh] overflow-auto" onclick="event.stopPropagation()">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold text-gray-800">动态配图</h3>
                            <button class="text-gray-500 hover:text-gray-700 text-2xl" onclick="this.closest('.fixed').remove()">&times;</button>
                        </div>
                        <div class="text-center">
                            <img src="${imageUrl}" alt="${imageDesc}" class="max-w-full max-h-[70vh] object-contain mx-auto rounded-lg shadow-lg">
                            ${imageDesc ? `<p class="mt-3 text-gray-600 text-sm italic">"${imageDesc}"</p>` : ''}
                        </div>
                        <div class="mt-4 text-center">
                            <button class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition-colors" onclick="window.open('${imageUrl}', '_blank')">
                                <i class="ri-external-link-line mr-2"></i>在新窗口打开
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 添加键盘事件支持
                const handleKeydown = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', handleKeydown);
                    }
                };
                document.addEventListener('keydown', handleKeydown);
                
            } catch (error) {
                console.error('[图片查看] 打开失败:', error);
                showMessageBox('图片查看失败，请稍后重试');
            }
        }

        // V30.1 升级：智能判断大图弹窗的图片来源
        function openMomentImageWithId(momentId) {
            let momentToOpen = null;
            // 遍历所有作者的动态，找到匹配的moment对象
            for (const authorId in momentsData) {
                const foundMoment = momentsData[authorId].find(m => m.id === momentId);
                if (foundMoment) {
                    momentToOpen = foundMoment;
                    break;
                }
            }

            if (!momentToOpen || !momentToOpen.image) {
                return showMessageBox('该动态没有图片或图片信息已丢失。');
            }

            // 智能判断是外部链接还是数据库ID
            if (typeof momentToOpen.image === 'string' && momentToOpen.image.startsWith('http')) {
                // 如果是http链接，直接用它打开弹窗
                openMomentImage(momentToOpen.image, momentToOpen.image_desc || '动态配图');
            } else {
                // 否则，认为是ID，从数据库获取后再打开弹窗
                getImageFromDB(momentToOpen.image).then(blob => {
                    if (blob) {
                        const objectURL = URL.createObjectURL(blob);
                        openMomentImage(objectURL, momentToOpen.image_desc || '动态配图');
                    } else {
                        showMessageBox('无法从数据库加载图片。');
                    }
                }).catch(error => {
                    console.error('加载动态大图失败:', error);
                    showMessageBox('加载图片失败。');
                });
            }
        }


        // 测试图片URL生成功能 - 用于调试
        function testImageUrlGeneration() {
            console.log('=== 测试图片URL生成功能 ===');
            
            const testCases = [
                '这是一个很长的图片描述，用来测试URL生成器是否能正确处理长文本并生成合适的占位图片URL',
                '短描述',
                '',
                null,
                '包含特殊字符的描述！@#￥%……&*（）',
                '包含emoji的描述😊🎉🌟',
                '包含换行符的描述\n第二行\n第三行'
            ];
            
            testCases.forEach((testCase, index) => {
                console.log(`\n测试用例 ${index + 1}: "${testCase}"`);
                try {
                    const result = generateSmartImageUrl(testCase, `测试用例${index + 1}`);
                    console.log(`结果: ${result}`);
                } catch (error) {
                    console.error(`错误: ${error.message}`);
                }
            });
            
            console.log('\n=== 测试完成 ===');
        }

        // 【请用这个完整的类，替换掉旧的 Class】
        class MomentsTriggerSystem {
            constructor() {
                this.chatHistory = {}; // 修正：应为对象，以角色ID为键
                this.lastInteractionTime = {};
                this.lastMomentTime = {}; // 记录每个角色最后发朋友圈的时间
                const heartbeatSettings = loadData('heartbeatSettings', defaultHeartbeatSettings);
                this.triggerThresholds = {
                    emotionHigh: 0.85,  // 情感强度达到0.85可能触发
                    timeGap: heartbeatSettings.momentsTimeTriggerInterval * 60 * 60 * 1000, // 使用用户设置的时间触发间隔
                    minInterval: heartbeatSettings.momentsMinInterval * 60 * 1000, // 使用用户设置的朋友圈最小间隔
                    triggerProbability: heartbeatSettings.momentsTriggerProbability // 使用用户设置的触发概率
                };
                this.characterPersonalityModifiers = {
                    '温柔': { frequency: 0.8, emotionThreshold: 0.8 },
                    '活泼': { frequency: 1.2, emotionThreshold: 0.75 },
                    '神秘': { frequency: 0.6, emotionThreshold: 0.9 },
                    '内向': { frequency: 0.5, emotionThreshold: 0.95 },
                    '外向': { frequency: 1.3, emotionThreshold: 0.7 },
                    '理性': { frequency: 0.7, emotionThreshold: 0.88 },
                    '感性': { frequency: 1.1, emotionThreshold: 0.78 }
                };
            }

            recordChat(characterId, message, isUser = true) {
                if (!this.chatHistory[characterId]) {
                    this.chatHistory[characterId] = [];
                }
                this.chatHistory[characterId].push({ message, isUser, timestamp: Date.now() });
                if (this.chatHistory[characterId].length > 20) {
                    this.chatHistory[characterId].shift();
                }
                this.lastInteractionTime[characterId] = Date.now();
            }

            analyzeEmotion(message) {
                // ... (此函数内容保持不变) ...
                // 这是一个示例，实际情感分析逻辑可能更复杂
                const positiveWords = ['开心', '喜欢', '太好了', '爱'];
                const negativeWords = ['难过', '讨厌', '伤心'];
                let score = 0;
                if (positiveWords.some(w => message.includes(w))) score = 0.9;
                if (negativeWords.some(w => message.includes(w))) score = -0.9;
                return score;
            }

            // 【核心修正】这是修正后的 shouldTriggerMoment 方法
            shouldTriggerMoment(characterId) {
                const chatHistory = this.chatHistory[characterId] || [];
                const lastInteraction = this.lastInteractionTime[characterId] || 0;
                const lastMoment = this.lastMomentTime[characterId] || 0; // 正确地从属性获取
                const now = Date.now();

                if (now - lastMoment < this.triggerThresholds.minInterval) {
                    return { should: false, reason: '距离上次发动态时间太短' };
                }

                const character = characters.find(c => c.id === characterId);
                const personalityModifier = this.getPersonalityModifier(character);

                // 情感触发检查
                if (chatHistory.length > 0) {
                    const lastMessage = chatHistory[chatHistory.length - 1];
                    const emotionScore = this.analyzeEmotion(lastMessage.message);
                    if (Math.abs(emotionScore) > personalityModifier.emotionThreshold) {
                        // 应用概率判断
                        if (Math.random() * 100 < this.triggerThresholds.triggerProbability) {
                            return { should: true, type: 'emotion', reason: '对话达到情感高点' };
                        } else {
                            return { should: false, reason: '达到情感触发条件但概率判断未通过' };
                        }
                    }
                }
                
                // 时间流逝触发
                const adjustedTimeGap = this.triggerThresholds.timeGap / personalityModifier.frequency;
                if (now - lastInteraction > adjustedTimeGap) {
                    // 应用概率判断
                    if (Math.random() * 100 < this.triggerThresholds.triggerProbability) {
                        return { should: true, type: 'time', reason: '长时间无互动，分享生活' };
                    } else {
                        return { should: false, reason: '达到时间触发条件但概率判断未通过' };
                    }
                }

                return { should: false, reason: '未达到触发条件' };
            }
            
            getPersonalityModifier(character) {
                if (!character) return { frequency: 1.0, emotionThreshold: this.triggerThresholds.emotionHigh };
                const persona = character.persona || '';
                for (const [key, value] of Object.entries(this.characterPersonalityModifiers)) {
                    if (persona.includes(key)) return value;
                }
                return { frequency: 1.0, emotionThreshold: this.triggerThresholds.emotionHigh };
            }

            getTriggerContext(characterId) {
                const chatHistory = this.chatHistory[characterId] || [];
                if (chatHistory.length > 0) {
                    return chatHistory.slice(-3).map(c => c.message).join(' | ');
                }
                return '';
            }

            recordMomentPosted(characterId) {
                this.lastMomentTime[characterId] = Date.now();
            }
        }

        // 创建全局触发系统实例
        const momentsTriggerSystem = new MomentsTriggerSystem();
        window.momentsTriggerSystem = momentsTriggerSystem;

        // Function to format moment data into a string for the AI prompt
        function formatRecentMomentsForAI(characterId) {
            const characterMoments = momentsData[characterId] || [];
            const recentMoments = characterMoments.sort((a, b) => b.timestamp - a.timestamp).slice(0, 3); // Get the 3 most recent posts

            if (recentMoments.length === 0) {
                return "无";
            }

            return recentMoments.map((moment, index) => {
                const time = new Date(moment.timestamp).toLocaleString('zh-CN');
                return `【第 ${index + 1} 条动态】(发布于 ${time}):
动态内容: ${moment.content}
${moment.image ? `配图描述: ${moment.image_desc}` : ''}
点赞数: ${moment.likes?.count || 0}
评论数: ${moment.comments?.length || 0}`;
            }).join('\n\n');
        }

        function formatPlansForAI(characterId) {
            if (!planData[characterId] || planData[characterId].length === 0) {
                return "（目前我们之间还没有任何约定。）";
            }
            return planData[characterId]
                .map(p => `- [${p.status}] ${p.title}`)
                .join('\n');
        }

        function gatherAIContext(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                let chatHistory = JSON.parse(JSON.stringify(chatHistories[characterId]?.history || []));
                
                const worldBookContext = getCharacterWorldContext(character);

                // ==== 核心修改开始 ====
                const recentMomentsFormatted = formatRecentMomentsForAI(characterId);
                // ==== 核心修改结束 ====

                // --- 新增代码：获取并格式化约定信息 ---
                const planContext = formatPlansForAI(characterId);
                // ------------------------------------

                // --- 新增代码：获取最近一次的通话记录 ---
                const recentCallLog = callLogs[characterId] ? callLogs[characterId].slice(-1)[0] : null;
                const memoryContext = formatMemoriesForAI(characterId);
                let callLogContext = "（最近没有通话记录）";
                if (recentCallLog) {
                    callLogContext = `[类型: ${recentCallLog.type}通话, 时间: ${new Date(recentCallLog.timestamp).toLocaleString()}]\n${recentCallLog.transcript.join('\n')}`;
                }
                // ------------------------------------

                const maxHistoryLength = parseInt(loadData('ai_memory_length', 50), 10);
                const limitedHistory = chatHistory.slice(-maxHistoryLength);

                const contextPackage = {
                    character: character,
                    chatHistory: limitedHistory,
                    worldBookContext: worldBookContext,
                    // ==== 新增属性 ====
                    recentMoments: recentMomentsFormatted,
                    // --- 新增属性：将约定信息加入上下文包 ---
                    planContext: planContext,
                    // --- 在这里添加新属性 ---
                    callLogContext: callLogContext,
                    memoryContext: memoryContext
                    // -----------------------
                };

                return contextPackage;

            } catch (error) {
                console.error("【严重错误】: gatherAIContext 函数内部出现异常:", error);
                return null;
            }
        }



        function testAIContext(characterId) {
            if (!characterId) {
                console.log("【调试工具】请输入一个角色ID进行测试，例如 testAIContext('char_123456')");
                return;
            }
            console.log(`--- 正在为角色【${characterId}】测试上下文数据 ---`);
            const context = gatherAIContext(characterId);
            if (context) {
                console.log("✅ 成功获取上下文:", context);
                alert("调试信息已打印在控制台，请按F12查看。");
            } else {
                console.error("❌ 获取上下文失败，请检查角色ID是否正确。");
                alert("获取上下文失败，请按F12查看控制台的错误信息。");
            }
        }

        function checkRawStorageData(key) {
            if (!key) {
                console.log("【仓库验货员】: 请提供要检查的仓库钥匙 (key)，例如: checkRawStorageData('characters')");
                return;
            }
            console.log(`--- 正在检查仓库中 '${key}' 的原始货物 ---`);
            const rawData = localStorage.getItem(key);
            if (rawData === null) {
                console.log(`🟡 仓库中没有找到名为 '${key}' 的货物。`);
                alert(`仓库中没有找到 '${key}'。`);
            } else {
                console.log("✅ 找到了货物，原始内容如下:");
                console.log(rawData);
                console.log(`货物类型是: ${typeof rawData}`);
                if (typeof rawData !== 'string') {
                    console.warn("🟡 警告: 货物不是字符串格式，这可能不是原始数据。");
                }
                alert(`已在控制台打印出 '${key}' 的原始货物内容和类型，请按F12查看。`);
            }
        }

        // 定期清理触发系统数据
        setInterval(() => {
            momentsTriggerSystem.cleanup();
        }, 60 * 60 * 1000); // 每小时清理一次


        
        // 页面加载时检查通知权限
        document.addEventListener('DOMContentLoaded', () => {
            console.log('页面加载完成，检查通知权限...');
            if ('Notification' in window) {
                console.log('当前通知权限:', Notification.permission);
                if (Notification.permission === 'default') {
                    console.log('提示：可以在控制台运行 testNotificationPermission() 来设置通知权限');
                }
            }
            

        });
        

        

        

        
        // 自定义接收按钮图标
        function setReceiveButtonIcon(iconClass) {
            const receiveBtn = document.querySelector('#receive-chat-button i');
            if (receiveBtn) {
                receiveBtn.className = iconClass;
                console.log('接收按钮图标已更改为:', iconClass);
            }
        }
        
        // 快速设置邮件发送图标
        function setMailSendIcon() {
            setReceiveButtonIcon('ri-mail-send-line');
            console.log('已设置为邮件发送图标');
        }
        

        
        // 预设的优雅图标选项
        const elegantIcons = {
            'mail-send': 'ri-mail-send-line',             // 邮件发送（默认）
            'loading1': 'fas fa-circle-notch',            // 经典加载圈
            'loading2': 'fas fa-spinner',                 // 旋转器
            'loading3': 'fas fa-sync-alt',                // 同步图标
            'loading4': 'fas fa-cog',                     // 齿轮
            'loading5': 'fas fa-dot-circle',              // 点圈
            'loading6': 'fas fa-circle',                  // 实心圆
            'loading7': 'far fa-circle',                  // 空心圆
            'loading8': 'fas fa-asterisk',                // 星形
            'loading9': 'fas fa-star',                    // 星星
            'loading10': 'fas fa-heart',                  // 爱心
            'loading11': 'ri-loader-4-line',              // Remix加载器
            'loading12': 'ri-refresh-line',               // Remix刷新
            'loading13': 'ri-time-line',                  // Remix时钟
            'loading14': 'ri-pulse-line',                 // Remix脉冲
            'loading15': 'ri-loader-2-line'               // Remix加载器2
        };
        
        // 显示图标选择器
        function showIconSelector() {
            const iconList = Object.entries(elegantIcons).map(([key, iconClass]) => 
                `<div class="icon-option" onclick="setReceiveButtonIcon('${iconClass}')">
                    <i class="${iconClass}"></i>
                    <span>${key}</span>
                </div>`
            ).join('');
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                z-index: 99999;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 1rem;
                    padding: 2rem;
                    max-width: 90vw;
                    max-height: 80vh;
                    overflow-y: auto;
                    text-align: center;
                ">
                    <h3 style="margin-bottom: 1.5rem; color: #333;">选择接收按钮图标</h3>
                    <div style="
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
                        gap: 1rem;
                        margin-bottom: 1.5rem;
                    ">
                        ${iconList}
                    </div>
                    <button onclick="this.closest('.icon-selector-modal').remove()" style="
                        background: #3b82f6;
                        color: white;
                        border: none;
                        padding: 0.75rem 2rem;
                        border-radius: 0.5rem;
                        cursor: pointer;
                    ">关闭</button>
                </div>
            `;
            
            modal.className = 'icon-selector-modal';
            document.body.appendChild(modal);
            
            // 添加图标选项样式
            const style = document.createElement('style');
            style.textContent = `
                .icon-option {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    padding: 1rem;
                    border: 2px solid #e5e7eb;
                    border-radius: 0.5rem;
                    cursor: pointer;
                    transition: all 0.2s;
                }
                .icon-option:hover {
                    border-color: #3b82f6;
                    background: #f0f9ff;
                    transform: translateY(-2px);
                }
                .icon-option i {
                    font-size: 2rem;
                    margin-bottom: 0.5rem;
                    color: #6b7280;
                }
                .icon-option span {
                    font-size: 0.8rem;
                    color: #6b7280;
                }
            `;
            document.head.appendChild(style);
        }
        
        window.showIconSelector = showIconSelector;
        window.setReceiveButtonIcon = setReceiveButtonIcon;
        window.setMailSendIcon = setMailSendIcon;




        // 更换朋友圈背景
        async function changeMomentsCover() {
            console.log('开始更换朋友圈背景...');
            
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                
                console.log('文件输入元素已创建');
                
                input.onchange = async (e) => {
                    console.log('文件选择事件触发');
                    const file = e.target.files[0];
                    if (file) {
                        console.log('选择的文件:', file.name, '大小:', file.size, '类型:', file.type);
                        try {
                            // 使用统一的图片处理函数，添加压缩选项
                            const imageId = await handleImageUpload(e.target, null, null, { 
                                compression: { maxWidth: 750, maxHeight: 384 } // 适合朋友圈背景的尺寸
                            });
                            
                            console.log('压缩后的图片ID:', imageId ? '成功' : '失败');
                            
                            if (imageId) {
                                const momentsCover = $('#moments-cover');
                                console.log('找到背景元素:', !!momentsCover);
                                
                                if (momentsCover) {
                                    // 异步加载背景图片
                                    getImageFromDB(imageId).then(blob => {
                                        if (blob) {
                                            const objectURL = URL.createObjectURL(blob);
                                            momentsCover.style.backgroundImage = `url(${objectURL})`;
                                            momentsCover.style.backgroundSize = 'cover';
                                            momentsCover.style.backgroundPosition = 'center';
                                            momentsCover.style.backgroundRepeat = 'no-repeat';
                                            
                                            // 同时设置CSS变量作为备用
                                            document.documentElement.style.setProperty('--moments-cover-image', `url(${objectURL})`);
                                            
                                            // 隐藏提示文字
                                            const hintElement = $('#moments-cover-hint');
                                            if (hintElement) {
                                                hintElement.style.display = 'none';
                                                console.log('提示文字已隐藏');
                                            }
                                        }
                                    });
                                    
                                    // 保存背景图片ID
                                    saveData('moments_cover', imageId);
                                    showMessageBox('背景图片更换成功！');
                                    
                                    // 调试信息
                                    console.log('背景图片ID已保存:', imageId);
                                } else {
                                    showMessageBox('找不到背景图片元素');
                                }
                            }
                        } catch (error) {
                            console.error('背景图片处理失败:', error);
                            showMessageBox('背景图片处理失败，请重试');
                        }
                    } else {
                        console.log('没有选择文件');
                    }
                };
                
                console.log('准备点击文件输入元素');
                input.click();
                console.log('文件输入元素已点击');
                
            } catch (error) {
                console.error('创建文件输入元素失败:', error);
                showMessageBox('创建文件选择器失败，请重试');
            }
        }

        // 加载朋友圈背景
        function loadMomentsCover() {
            const savedCover = loadData('moments_cover');
            console.log('尝试加载背景图片:', savedCover ? '有保存的图片' : '没有保存的图片');
            
            if (savedCover) {
                const momentsCover = $('#moments-cover');
                if (momentsCover) {
                    // 异步加载背景图片
                    getImageFromDB(savedCover).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            momentsCover.style.backgroundImage = `url(${objectURL})`;
                            momentsCover.style.backgroundSize = 'cover';
                            momentsCover.style.backgroundPosition = 'center';
                            momentsCover.style.backgroundRepeat = 'no-repeat';
                            
                            // 同时设置CSS变量作为备用
                            document.documentElement.style.setProperty('--moments-cover-image', `url(${objectURL})`);
                            
                            // 隐藏提示文字
                            const hintElement = $('#moments-cover-hint');
                            if (hintElement) {
                                hintElement.style.display = 'none';
                            }
                            
                            console.log('背景图片加载成功，样式已设置');
                        }
                    });
                } else {
                    console.error('找不到背景图片元素');
                }
            } else {
                console.log('没有保存的背景图片，使用默认图片');
                // 设置默认图片
                const defaultCover = 'https://placehold.co/375x192/333/fff?text=Cover';
                
                // 直接设置元素样式
                const momentsCover = $('#moments-cover');
                if (momentsCover) {
                    momentsCover.style.backgroundImage = `url(${defaultCover})`;
                    momentsCover.style.backgroundSize = 'cover';
                    momentsCover.style.backgroundPosition = 'center';
                    momentsCover.style.backgroundRepeat = 'no-repeat';
                }
                
                // 设置CSS变量
                document.documentElement.style.setProperty('--moments-cover-image', `url(${defaultCover})`);
                
                // 显示提示文字（因为使用的是默认图片）
                const hintElement = $('#moments-cover-hint');
                if (hintElement) {
                    hintElement.style.display = 'flex';
                }
            }
        }

        // 更换朋友圈头像
        async function changeMomentsAvatar() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // 使用统一的图片处理函数，添加压缩选项
                        const imageId = await handleImageUpload(e.target, null, null, { 
                            compression: { maxWidth: 256, maxHeight: 256 } // 适合头像的尺寸
                        });
                        
                        if (imageId) {
                            const momentsAvatar = $('#moments-user-avatar');
                            // 异步加载头像
                            getImageFromDB(imageId).then(blob => {
                                if (blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    momentsAvatar.style.backgroundImage = `url(${objectURL})`;
                                    momentsAvatar.style.backgroundSize = 'cover';
                                    momentsAvatar.style.backgroundPosition = 'center';
                                    momentsAvatar.style.backgroundRepeat = 'no-repeat';
                                    
                                    // 同时设置CSS变量作为备用
                                    document.documentElement.style.setProperty('--moments-avatar-image', `url(${objectURL})`);
                                }
                            });
                            
                            // 保存头像图片ID
                            saveData('moments_avatar', imageId);
                            
                            // 【新增】同步更新所有用户帖子的头像
                            updateAllUserPostAvatars(imageId);
                            
                            showMessageBox('头像更换成功！');
                            
                            // 调试信息
                            console.log('头像图片ID已保存:', imageId);
                        }
                    } catch (error) {
                        console.error('头像图片处理失败:', error);
                        showMessageBox('头像图片处理失败，请重试');
                    }
                }
            };
            input.click();
        }

        // 【新增】同步更新所有用户帖子的头像
        async function updateAllUserPostAvatars(newAvatarId) {
            console.log('[头像同步] 开始更新所有用户帖子的头像...');
            
            try {
                // 获取新的头像数据
                const newAvatarBlob = await getImageFromDB(newAvatarId);
                if (!newAvatarBlob) {
                    console.warn('[头像同步] 无法获取新头像数据');
                    return;
                }
                
                const newAvatarURL = URL.createObjectURL(newAvatarBlob);
                console.log('[头像同步] 新头像URL已创建:', newAvatarURL);
                
                // 更新所有用户发布的帖子头像
                let updatedCount = 0;
                perchPosts.forEach(post => {
                    if (post.authorId === 'user') {
                        // 更新帖子数据中的头像
                        post.authorAvatar = newAvatarId;
                        updatedCount++;
                        
                        // 查找并更新页面上的头像元素
                        const avatarElement = document.getElementById(`perch-avatar-${post.id}`);
                        if (avatarElement) {
                            avatarElement.style.backgroundImage = `url(${newAvatarURL})`;
                            avatarElement.style.backgroundSize = 'cover';
                            avatarElement.style.backgroundPosition = 'center';
                            avatarElement.style.backgroundRepeat = 'no-repeat';
                            avatarElement.textContent = '';
                            avatarElement.innerHTML = '';
                            console.log(`[头像同步] 已更新帖子 ${post.id} 的头像显示`);
                        }
                    }
                });
                
                // 保存更新后的数据
                saveData('perchPosts', perchPosts);
                
                console.log(`[头像同步] 完成！共更新了 ${updatedCount} 个帖子的头像`);
                
                // 重新渲染栖木动态，确保所有头像都正确显示
                renderPerchFeed();
                
            } catch (error) {
                console.error('[头像同步] 更新头像时发生错误:', error);
            }
        }

        // 编辑朋友圈用户名
        function editMomentsName() {
            const currentName = $('#moments-user-name').textContent;
            const newName = prompt('请输入新的用户名：', currentName);
            if (newName && newName.trim() && newName !== currentName) {
                $('#moments-user-name').textContent = newName.trim();
                // 保存用户名
                saveData('moments_username', newName.trim());
                // 刷新动态显示，确保名字一致
                renderUnifiedMoments();
                showMessageBox('用户名已更新！');
            }
        }

        // 更换栖木头像
        async function changePerchAvatar() {
            // 创建选择对话框
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 2rem;
                border-radius: 1rem;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                max-width: 400px;
                width: 90%;
            `;
            
            content.innerHTML = `
                <h3 style="margin: 0 0 1rem 0; color: #333;">更换栖木头像</h3>
                <div style="margin-bottom: 1rem;">
                    <button id="upload-btn" style="
                        background: #667eea;
                        color: white;
                        border: none;
                        padding: 0.75rem 1.5rem;
                        border-radius: 0.5rem;
                        cursor: pointer;
                        margin-right: 0.5rem;
                        font-size: 1rem;
                    ">上传图片</button>
                    <button id="url-btn" style="
                        background: #10b981;
                        color: white;
                        border: none;
                        padding: 0.75rem 1.5rem;
                        border-radius: 0.5rem;
                        cursor: pointer;
                        font-size: 1rem;
                    ">输入链接</button>
                </div>
                <div id="url-input" style="display: none; margin-bottom: 1rem;">
                    <input type="url" id="avatar-url" placeholder="请输入图床链接" style="
                        width: 100%;
                        padding: 0.75rem;
                        border: 1px solid #ddd;
                        border-radius: 0.5rem;
                        font-size: 1rem;
                        box-sizing: border-box;
                    ">
                </div>
                <div style="text-align: right;">
                    <button id="cancel-btn" style="
                        background: #6b7280;
                        color: white;
                        border: none;
                        padding: 0.5rem 1rem;
                        border-radius: 0.5rem;
                        cursor: pointer;
                        margin-right: 0.5rem;
                    ">取消</button>
                    <button id="confirm-btn" style="
                        background: #667eea;
                        color: white;
                        border: none;
                        padding: 0.5rem 1rem;
                        border-radius: 0.5rem;
                        cursor: pointer;
                        display: none;
                    ">确认</button>
                </div>
            `;
            
            dialog.appendChild(content);
            document.body.appendChild(dialog);
            
            // 绑定事件
            const uploadBtn = content.querySelector('#upload-btn');
            const urlBtn = content.querySelector('#url-btn');
            const urlInput = content.querySelector('#url-input');
            const avatarUrl = content.querySelector('#avatar-url');
            const confirmBtn = content.querySelector('#confirm-btn');
            const cancelBtn = content.querySelector('#cancel-btn');
            
            let currentMode = 'upload'; // 'upload' 或 'url'
            
            uploadBtn.onclick = () => {
                currentMode = 'upload';
                uploadBtn.style.background = '#667eea';
                urlBtn.style.background = '#6b7280';
                urlInput.style.display = 'none';
                confirmBtn.style.display = 'none';
            };
            
            urlBtn.onclick = () => {
                currentMode = 'url';
                urlBtn.style.background = '#10b981';
                uploadBtn.style.background = '#6b7280';
                urlInput.style.display = 'block';
                confirmBtn.style.display = 'inline-block';
            };
            
            confirmBtn.onclick = async () => {
                if (currentMode === 'url') {
                    const url = avatarUrl.value.trim();
                    if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
                        // 保存图床链接
                        saveData('perch_avatar', url);
                        
                        // 更新头像显示
                        updatePerchUserAvatar(url);
                        
                        // 同步更新所有用户帖子的头像
                        updateAllUserPostAvatars(url);
                        
                        showMessageBox('栖木头像更换成功！');
                        document.body.removeChild(dialog);
                    } else {
                        alert('请输入有效的图片链接！');
                    }
                }
            };
            
            cancelBtn.onclick = () => {
                document.body.removeChild(dialog);
            };
            
            // 点击上传按钮
            uploadBtn.onclick = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        try {
                            // 先显示裁切界面，让用户选择头像区域（1:1比例）
                            showImageCropper(file, async (croppedBlob) => {
                                if (croppedBlob) {
                                    try {
                                        // 直接使用裁切后的图片，无需额外压缩
                                        const imageId = `perch_avatar_${Date.now()}`;
                                        
                                        // 保存到数据库
                                        await saveImageToDB(imageId, croppedBlob);
                                        
                                        // 保存头像图片ID
                                        saveData('perch_avatar', imageId);
                                        
                                        // 更新头像显示
                                        updatePerchUserAvatar(imageId);
                                        
                                        // 【新增】同步更新所有用户帖子的头像
                                        updateAllUserPostAvatars(imageId);
                                        
                                        showMessageBox('栖木头像更换成功！');
                                        document.body.removeChild(dialog);
                                        
                                        // 调试信息
                                        console.log('栖木头像图片ID已保存:', imageId);
                                    } catch (error) {
                                        console.error('栖木头像图片处理失败:', error);
                                        showMessageBox('栖木头像图片处理失败，请重试');
                                    }
                                }
                            }, 1); // 头像使用1:1比例
                        } catch (error) {
                            console.error('栖木头像裁切失败:', error);
                            showMessageBox('栖木头像裁切失败，请重试');
                        }
                    }
                };
                input.click();
            };
        }

        // 编辑栖木用户名
        function editPerchName() {
            const currentName = $('#perch-user-name').textContent;
            const newName = prompt('请输入新的用户名：', currentName);
            if (newName && newName.trim() && newName !== currentName) {
                $('#perch-user-name').textContent = newName.trim();
                // 保存用户名
                saveData('perch_username', newName.trim());
                showMessageBox('栖木用户名已更新！');
            }
        }

        // 加载栖木头像和用户名
        function loadPerchUserInfo() {
            const savedAvatar = loadData('perch_avatar');
            const savedUsername = loadData('perch_username');
            
            console.log('尝试加载栖木头像:', savedAvatar ? '有保存的头像' : '没有保存的头像');
            
            // 加载头像
            if (savedAvatar) {
                const perchAvatar = $('#perch-user-avatar');
                if (perchAvatar) {
                    // 检查是否是图床链接
                    if (savedAvatar.startsWith('http://') || savedAvatar.startsWith('https://')) {
                        // 直接使用图床链接
                        perchAvatar.style.setProperty('--custom-avatar-bg', `url(${savedAvatar})`);
                        perchAvatar.style.backgroundImage = `url(${savedAvatar})`;
                        perchAvatar.style.backgroundSize = 'cover';
                        perchAvatar.style.backgroundPosition = 'center';
                        perchAvatar.style.backgroundRepeat = 'no-repeat';
                        
                        // 隐藏默认图标
                        const icon = perchAvatar.querySelector('i');
                        if (icon) icon.style.display = 'none';
                        
                        // 添加自定义头像样式类
                        perchAvatar.classList.add('has-custom-image');
                        
                        console.log('栖木头像（图床链接）加载成功');
                    } else {
                        // 从数据库加载头像
                        getImageFromDB(savedAvatar).then(blob => {
                            if (blob) {
                                const objectURL = URL.createObjectURL(blob);
                                
                                // 设置元素样式
                                perchAvatar.style.setProperty('--custom-avatar-bg', `url(${objectURL})`);
                                perchAvatar.style.backgroundImage = `url(${objectURL})`;
                                perchAvatar.style.backgroundSize = 'cover';
                                perchAvatar.style.backgroundPosition = 'center';
                                perchAvatar.style.backgroundRepeat = 'no-repeat';
                                
                                // 隐藏默认图标
                                const icon = perchAvatar.querySelector('i');
                                if (icon) icon.style.display = 'none';
                                
                                // 添加自定义头像样式类
                                perchAvatar.classList.add('has-custom-image');
                                
                                console.log('栖木头像（数据库）加载成功，样式已设置');
                            }
                        });
                    }
                } else {
                    console.error('找不到栖木头像元素');
                }
            } else {
                console.log('没有保存的栖木头像，使用默认头像');
                // 设置默认头像
                const defaultAvatar = 'https://placehold.co/128x128/777/FFF?text=Me';
                
                // 直接设置元素样式
                const perchAvatar = $('#perch-user-avatar');
                if (perchAvatar) {
                    perchAvatar.style.backgroundImage = `url(${defaultAvatar})`;
                    perchAvatar.style.backgroundSize = 'cover';
                    perchAvatar.style.backgroundPosition = 'center';
                    perchAvatar.style.backgroundRepeat = 'no-repeat';
                    
                    // 隐藏默认图标
                    const icon = perchAvatar.querySelector('i');
                    if (icon) icon.style.display = 'none';
                    
                    // 添加自定义头像样式类
                    perchAvatar.classList.add('has-custom-image');
                }
            }
            
            // 加载用户名
            console.log('尝试加载栖木用户名:', savedUsername || '使用默认用户名');
            
            if (savedUsername) {
                const perchUsername = $('#perch-user-name');
                if (perchUsername) {
                    perchUsername.textContent = savedUsername;
                    console.log('栖木用户名加载成功:', savedUsername);
                }
            }
        }

        // 加载朋友圈头像和用户名
        function loadMomentsUserInfo() {
            const savedAvatar = loadData('moments_avatar');
            const savedUsername = loadData('moments_username');
            
            console.log('尝试加载头像:', savedAvatar ? '有保存的头像' : '没有保存的头像');
            
            // 加载头像
            if (savedAvatar) {
                const momentsAvatar = $('#moments-user-avatar');
                if (momentsAvatar) {
                    // 异步加载头像
                    getImageFromDB(savedAvatar).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            momentsAvatar.style.backgroundImage = `url(${objectURL})`;
                            momentsAvatar.style.backgroundSize = 'cover';
                            momentsAvatar.style.backgroundPosition = 'center';
                            momentsAvatar.style.backgroundRepeat = 'no-repeat';
                            

                            
                            console.log('头像加载成功，样式已设置');
                        }
                    });
                } else {
                    console.error('找不到头像元素');
                }
            } else {
                console.log('没有保存的头像，使用默认头像');
                // 设置默认头像
                const defaultAvatar = 'https://placehold.co/128x128/777/FFF?text=Me';
                
                // 直接设置元素样式
                const momentsAvatar = $('#moments-user-avatar');
                if (momentsAvatar) {
                    momentsAvatar.style.backgroundImage = `url(${defaultAvatar})`;
                    momentsAvatar.style.backgroundSize = 'cover';
                    momentsAvatar.style.backgroundPosition = 'center';
                    momentsAvatar.style.backgroundRepeat = 'no-repeat';
                }
                

            }
            
            // 加载用户名
            console.log('尝试加载用户名:', savedUsername || '使用默认用户名');
            
            if (savedUsername) {
                const momentsUsername = $('#moments-user-name');
                momentsUsername.textContent = savedUsername;
                console.log('用户名加载成功:', savedUsername);
            }
        }

        // 手动触发朋友圈生成 - 必须要有API连接
        async function triggerMomentManually(characterId, triggerType = 'manual', context = '') {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return;
                }

                // 检查API是否连接
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    showMessageBox('需要先配置AI API才能发布动态');
                    return null;
                }

                // 使用AI模型生成动态
                console.log('使用AI模型生成动态...');
                const momentData = await generateIntelligentMoment(character, context, triggerType);
                
                // 创建新动态
                if (!momentsData[characterId]) {
                    momentsData[characterId] = [];
                }

                // 使用智能图片URL生成器
                const imageUrl = generateSmartImageUrl(momentData.image_desc, 'AI动态配图');

                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: momentData.text,
                    image: imageUrl,
                    tags: momentData.tags || "#心情 #日常",
                    likes: 0,
                    comments: [],
                    mood: momentData.mood || "平静",
                    trigger_reason: momentData.trigger_reason || "手动触发",
                    image_desc: momentData.image_desc
                };

                momentsData[characterId].push(newMoment);
                saveData('momentsData', momentsData);
                
                // 记录朋友圈发布时间到触发系统
                momentsTriggerSystem.recordMomentPosted(characterId);
                
                // 刷新朋友圈显示
                if ($('.wechat-tab-item[data-tab="moments"]').classList.contains('active')) {
                    renderUnifiedMoments();
                }
                
                showMessageBox(`${character.name} 发布了一条新动态`);
                
                return newMoment;
            } catch (error) {
                console.error('手动触发朋友圈失败:', error);
                showMessageBox('触发朋友圈失败，请稍后重试');
            }
        }

        // 简化模式：基于聊天内容生成简单动态
        function generateSimpleMoment(character, context) {
            const currentTime = new Date().toLocaleString('zh-CN');
            const timeGreeting = getTimeGreeting();
            
            // 基于角色性格生成动态内容
            const personality = character.persona || '';
            let content = '';
            let mood = '平静';
            
            if (personality.includes('温柔') || personality.includes('体贴')) {
                content = `${timeGreeting}，今天的心情很温暖。${context ? `刚刚聊到了${context}，让我想起了很多美好的事情。` : '希望能把这份温暖传递给你。'}`;
                mood = '温暖';
            } else if (personality.includes('活泼') || personality.includes('开朗')) {
                content = `${timeGreeting}！今天又是充满活力的一天！${context ? `和你的聊天让我很开心，特别是关于${context}的部分。` : '生活总是充满惊喜！'}`;
                mood = '开心';
            } else if (personality.includes('神秘') || personality.includes('深沉')) {
                content = `${timeGreeting}，在思考一些事情。${context ? `关于${context}，我有一些新的想法。` : '有时候沉默也是一种表达。'}`;
                mood = '思考';
            } else {
                content = `${timeGreeting}，今天过得怎么样？${context ? `我们刚才聊到了${context}，这让我很有感触。` : '希望能和你分享更多。'}`;
                mood = '平静';
            }
            
            return {
                text: content,
                image_desc: `${timeGreeting}的${mood}心情`,
                tags: `#${mood} #日常 #${timeGreeting}`,
                mood: mood,
                trigger_reason: context ? `聊天内容：${context}` : '日常分享'
            };
        }

        // 获取时间问候语
        function getTimeGreeting() {
            const hour = new Date().getHours();
            if (hour < 6) return '深夜';
            if (hour < 12) return '早上';
            if (hour < 18) return '下午';
            if (hour < 22) return '晚上';
            return '深夜';
        }

        // 从聊天消息中提取动态内容
        function extractMomentContent(message) {
            // 移除动态发布指令标记
            let content = message.replace(/\[发布动态\]|\[发动态\]/g, '').trim();
            
            // 如果内容太长，截取合适长度
            if (content.length > 100) {
                content = content.substring(0, 100) + '...';
            }
            
            return content;
        }

        // AI自动触发动态 - 在聊天时根据情感触动自动发布
        async function triggerAIMomentFromChat(characterId, chatContext, emotionTrigger) {
            try {
                // 检查API是否连接
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    console.log('API未配置，无法自动发布动态');
                    return null;
                }

                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return null;
                }

                // 检查是否应该触发动态（避免过于频繁）
                const triggerResult = momentsTriggerSystem.shouldTriggerMoment(characterId);
                if (!triggerResult.should) {
                    return null;
                }

                // 使用AI生成基于聊天内容的动态
                const momentData = await generateIntelligentMoment(character, chatContext, 'emotion');
                
                // 创建新动态
                if (!momentsData[characterId]) {
                    momentsData[characterId] = [];
                }

                // 使用智能图片URL生成器
                const imageUrl = generateSmartImageUrl(momentData.image_desc, 'AI动态配图');

                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: momentData.text,
                    image: imageUrl,
                    tags: momentData.tags || "#心情 #聊天 #触动",
                    likes: 0,
                    comments: [],
                    mood: momentData.mood || "触动",
                    trigger_reason: `聊天情感触动：${emotionTrigger}`,
                    image_desc: momentData.image_desc
                };

                momentsData[characterId].push(newMoment);
                saveData('momentsData', momentsData);
                
                // 记录朋友圈发布时间到触发系统
                momentsTriggerSystem.recordMomentPosted(characterId);
                
                // 刷新朋友圈显示
                if ($('.wechat-tab-item[data-tab="moments"]').classList.contains('active')) {
                    renderUnifiedMoments();
                }
                
                console.log(`${character.name} 因情感触动自动发布了一条新动态`);
                showMessageBox(`${character.name} 发布了一条新动态`);
                
                return newMoment;
            } catch (error) {
                console.error('AI自动触发动态失败:', error);
                return null;
            }
        }



        // 检测情感触动
        function detectEmotionalTrigger(characterId, userMessage) {
            try {
                // 检查API是否配置
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    return; // API未配置，不检测
                }

                // 分析用户消息的情感强度
                const emotionLevel = analyzeEmotionLevel(userMessage);
                
                // 如果情感强度足够高，尝试触发动态
                if (emotionLevel !== 'none') {
                    // 获取聊天上下文
                    const chatContext = getChatContext(characterId);
                    
                    // 异步触发动态（不阻塞聊天）
                    triggerAIMomentFromChat(characterId, chatContext, emotionLevel);
                }
            } catch (error) {
                console.error('检测情感触动失败:', error);
            }
        }

        // 分析情感强度
        function analyzeEmotionLevel(message) {
            const message_lower = message.toLowerCase();
            
            // 高情感触动词汇
            const highEmotionWords = [
                '爱', '喜欢', '讨厌', '恨', '开心', '难过', '伤心', '痛苦', '绝望', '兴奋',
                '激动', '愤怒', '生气', '害怕', '恐惧', '担心', '焦虑', '紧张', '放松', '安心',
                '感动', '震撼', '惊讶', '震惊', '失望', '绝望', '希望', '梦想', '未来', '过去',
                '回忆', '思念', '想念', '怀念', '珍惜', '重要', '特别', '唯一', '永远', '一生'
            ];
            
            // 中等情感触动词汇
            const mediumEmotionWords = [
                '好', '坏', '不错', '一般', '还行', '可以', '满意', '不满', '期待', '好奇',
                '有趣', '无聊', '新鲜', '熟悉', '陌生', '变化', '稳定', '平静', '热闹', '安静',
                '忙碌', '悠闲', '充实', '空虚', '有意义', '无意义', '有价值', '无价值'
            ];
            
            // 检查高情感词汇
            for (const word of highEmotionWords) {
                if (message_lower.includes(word)) {
                    return 'high';
                }
            }
            
            // 检查中等情感词汇
            for (const word of mediumEmotionWords) {
                if (message_lower.includes(word)) {
                    return 'medium';
                }
            }
            
            // 检查特殊符号和重复字符（可能表示强烈情感）
            if (message.includes('!!!') || message.includes('？？') || message.includes('...') || 
                message.includes('😭') || message.includes('😍') || message.includes('😡') ||
                message.includes('❤️') || message.includes('💔') || message.includes('🔥')) {
                return 'high';
            }
            
            // 检查消息长度（长消息可能包含更多情感内容）
            if (message.length > 50) {
                return 'low';
            }
            
            return 'none';
        }

        // 获取聊天上下文
        function getChatContext(characterId) {
            try {
                const chatSession = chatHistories[characterId];
                if (!chatSession || !chatSession.history) {
                    return '';
                }
                
                // 获取最近5条消息作为上下文
                const recentMessages = chatSession.history.slice(-5);
                const context = recentMessages.map(msg => {
                    const sender = msg.sender === 'user' ? '用户' : 'AI';
                    return `${sender}: ${msg.content}`;
                }).join('\n');
                
                return context;
            } catch (error) {
                console.error('获取聊天上下文失败:', error);
                return '';
            }
        }

        // 从聊天中直接发布动态（保留原有功能）
        async function publishMomentFromChat(characterId, content) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('角色不存在:', characterId);
                    return null;
                }

                // 创建新动态
                if (!momentsData[characterId]) {
                    momentsData[characterId] = [];
                }

                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    image: `https://placehold.co/600x400/2a2a2a/ffffff?text=${encodeURIComponent('聊天中的心情分享')}`,
                    tags: "#心情 #聊天 #分享",
                    likes: 0,
                    comments: [],
                    mood: "分享",
                    trigger_reason: "聊天中主动发布",
                    image_desc: "聊天中的心情分享"
                };

                momentsData[characterId].push(newMoment);
                saveData('momentsData', momentsData);
                
                // 记录朋友圈发布时间到触发系统
                momentsTriggerSystem.recordMomentPosted(characterId);
                
                // 刷新朋友圈显示
                if ($('.wechat-tab-item[data-tab="moments"]').classList.contains('active')) {
                    renderUnifiedMoments();
                }
                
                console.log(`${character.name} 从聊天中发布了一条新动态`);
                
                return newMoment;
            } catch (error) {
                console.error('从聊天发布动态失败:', error);
                return null;
            }
        }



        // 朋友圈事件监听器现在直接在HTML中绑定

        // 删除朋友圈动态 (V2 - 已加固)
        function deleteMoment(momentId) {
            let momentToDelete = null;
            let authorName = '未知';
            
            Object.keys(momentsData).forEach(authorId => {
                const moment = momentsData[authorId]?.find(m => m.id === momentId);
                if (moment) {
                    momentToDelete = moment;
                    authorName = (authorId === 'user')
                        ? (loadData('moments_username') || '我')
                        : (characters.find(c => c.id === authorId)?.name || '未知角色');
                }
            });
            
            if (!momentToDelete) {
                showMessageBox('找不到要删除的动态');
                return;
            }
            
            // --- 核心修复：在这里增加安全检查 ---
            // 检查 content 是否存在，如果不存在，则使用一个备用文本
            const contentPreview = (momentToDelete.content || '(这条动态内容已损坏)').substring(0, 50);
            const isLongContent = momentToDelete.content && momentToDelete.content.length > 50;
            // --- 修复结束 ---
            
            const confirmMessage = `确定要删除 ${authorName} 的这条动态吗？\n\n"${contentPreview}${isLongContent ? '...' : ''}"\n\n删除后无法恢复！`;
            
            if (confirm(confirmMessage)) {
                Object.keys(momentsData).forEach(authorId => {
                    if (momentsData[authorId]) { // 确保作者ID有效
                        momentsData[authorId] = momentsData[authorId].filter(m => m.id !== momentId);
                    }
                });
                
                saveData('momentsData', momentsData);
                // 增量更新：直接从页面移除对应的卡片
                const cardToRemove = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                if (cardToRemove) {
                    cardToRemove.remove();
                }
                showMessageBox(`已删除 ${authorName} 的动态`);
            }
        }

        // 点赞朋友圈动态
        function likeMoment(momentId) {
            // 找到动态并切换点赞状态
            let found = false;
            let moment = null;
            let authorId = null;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    authorId = aid;
                    found = true;
                }
            });
            
            if (!found || !moment) {
                showMessageBox('找不到要点赞的动态');
                return;
            }
            
            // 初始化点赞数据结构
            if (!moment.likes) {
                moment.likes = { count: 0, users: [] };
            } else if (typeof moment.likes === 'number') {
                // 兼容旧数据格式
                moment.likes = { count: moment.likes, users: [] };
            }
            
            const currentUser = '我'; // 当前用户标识
            const userIndex = moment.likes.users.indexOf(currentUser);
            
            if (userIndex === -1) {
                // 用户还没点赞，添加点赞
                moment.likes.users.push(currentUser);
                moment.likes.count++;
                showMessageBox('点赞成功！');
            } else {
                // 用户已经点赞，取消点赞
                moment.likes.users.splice(userIndex, 1);
                moment.likes.count--;
                showMessageBox('已取消点赞');
            }
            
                saveData('momentsData', momentsData);
                // --- 新增的增量更新代码 START ---
                const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                if (card) {
                    const likeBtn = card.querySelector('.like-btn');
                    const likeCountSpan = card.querySelector('.like-count');
                    const icon = likeBtn.querySelector('i');

                    const isLiked = moment.likes.users.includes('我');

                    likeBtn.classList.toggle('text-blue-500', isLiked);
                    icon.className = isLiked ? 'ri-thumb-up-fill' : 'ri-thumb-up-line';

                    if (likeCountSpan) {
                        likeCountSpan.innerHTML = `<i class="ri-thumb-up-fill text-blue-500 mr-1"></i>${moment.likes.count}`;
                        likeCountSpan.style.display = moment.likes.count > 0 ? 'flex' : 'none';
                    }
                }
                // --- 新增的增量更新代码 END ---
        }

        // 评论朋友圈动态
        function commentMoment(momentId) {
            // 找到动态
            let moment = null;
            let authorId = null;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    authorId = aid;
                }
            });
            
            if (!moment) {
                showMessageBox('找不到要评论的动态');
                return;
            }
            
            // 显示评论输入框
            const comment = prompt('请输入您的评论：');
            if (comment && comment.trim()) {
                // 初始化评论数组
                if (!moment.comments) {
                    moment.comments = [];
                }
                
                // 添加新评论
                        moment.comments.push({
                            id: `comment_${Date.now()}`,
                            author: '我',
                            content: comment.trim(),
                            timestamp: Date.now()
                });
                
                saveData('momentsData', momentsData);
                // --- 新增的增量更新代码 START ---
                const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                if (card) {
                    const commentsContainer = card.querySelector('.comments-container');
                    const newComment = moment.comments[moment.comments.length - 1]; // 获取刚刚添加的评论
                    
                    const commentElement = document.createElement('div');
                    commentElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                    commentElement.dataset.commentId = newComment.id;
                    commentElement.innerHTML = `
                        <div class="flex-grow cursor-pointer">
                            <div class="flex items-center space-x-2">
                                <span class="font-medium text-blue-500 text-sm">${newComment.author}:</span>
                                <span class="text-sm comment-text">${newComment.content}</span>
                            </div>
                        </div>
                    `;
                    commentsContainer.appendChild(commentElement);
                }
                // --- 新增的增量更新代码 END ---
                showMessageBox('评论已添加！');
                
                // 如果评论的是AI角色的朋友圈，触发AI回复
                if (authorId !== 'user') {
                    // 延迟一下，让用户看到评论先显示
                    setTimeout(() => {
                        generateAICommentReply(momentId, comment.trim(), authorId);
                    }, 1000);
                }
            }
        }

        // [新函数开始] - 回复评论功能
// ================== 【【请用这个V3最终版，完整替换旧函数】】 ==================
/**
 * 回复评论功能 (V3 - 彻底修复多人回复BUG)
 */
function replyToComment(momentId, commentId, originalAuthor) {
    // 增加调试日志，方便追踪
    console.log(`[回复系统] 用户开始回复 ${originalAuthor}`);

    const currentUsername = loadData('moments_username') || '我';
    if (originalAuthor === currentUsername) {
        showMessageBox("不能回复自己的评论。");
        return;
    }

    const replyContent = prompt(`回复 ${originalAuthor}:`);

    if (replyContent && replyContent.trim()) {
        let momentToUpdate = null;
        // 确保能找到对应的动态
        for (const authorId in momentsData) {
            const foundMoment = momentsData[authorId].find(m => m.id === momentId);
            if (foundMoment) {
                momentToUpdate = foundMoment;
                break;
            }
        }

        if (momentToUpdate) {
            const newReply = {
                id: `comment_reply_${Date.now()}`,
                author: currentUsername,
                content: `回复 ${originalAuthor}: ${replyContent.trim()}`,
                timestamp: Date.now()
            };

            if (!momentToUpdate.comments) {
                momentToUpdate.comments = [];
            }

            // 核心操作：保存用户的回复
            momentToUpdate.comments.push(newReply);
            saveData('momentsData', momentsData);

            // 更新UI，显示用户的回复
            const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
            if (card) {
                const commentsContainer = card.querySelector('.comments-container');
                const replyElement = document.createElement('div');
                replyElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                replyElement.dataset.commentId = newReply.id;
                replyElement.innerHTML = `
                    <div class="flex-grow cursor-pointer">
                        <div class="flex items-center space-x-2">
                            <span class="font-medium text-blue-500 text-sm">${newReply.author}:</span>
                            <span class="text-sm comment-text">${newReply.content}</span>
                        </div>
                    </div>
                `;
                commentsContainer.appendChild(replyElement);
            }
            showMessageBox("回复成功！");

            // 【【【最终修正逻辑】】】
            // 1. 在这里只找出被回复的那一个AI角色
            const character = characters.find(c => c.name === originalAuthor);

            // 2. 如果找到了，就只触发这一个角色的回复函数
            if (character) {
                console.log(`[回复系统] 已定位到被回复者: ${character.name}。准备触发单人回复...`);
                // 将用户的回复(newReply)和需要回复的角色(character)信息传递给新函数
                triggerAIReplyToComment(momentId, newReply, character);
            }
            // 3. 【关键】这里不再有任何其他循环或触发代码，彻底杜绝了"围观"现象。
            console.log(`[回复系统] 流程结束。`);


        } else {
            showMessageBox("错误：找不到原始动态。");
        }
    }
}
        // [新函数结束]

        // [新代码开始] - AI回复用户的回复功能
        /**
         * 触发AI角色，让其回复用户在动态下的回复。
         * @param {string} momentId - 所在动态的ID。
         * @param {object} userReply - 用户刚刚发布的回复对象。
         * @param {object} character - 需要进行回复的AI角色对象。
         */
        async function triggerAIReplyToComment(momentId, userReply, character) {
            // 设置一个随机延迟，模仿AI看到和打字的时间
            const randomDelay = Math.random() * 4000 + 3000; // 3到7秒延迟
            console.log(`【AI再回复系统】：${character.name} 已收到您的回复，将在 ${randomDelay.toFixed(0)}ms 后回应。`);

            setTimeout(async () => {
                const apiSettings = loadData('api_settings');
                if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                    console.warn(`【AI再回复系统】：API未配置，${character.name} 无法回复。`);
                    return;
                }

                // 寻找完整的上下文
                let moment = null;
                for (const authorId in momentsData) {
                    const foundMoment = momentsData[authorId].find(m => m.id === momentId);
                    if (foundMoment) {
                        moment = foundMoment;
                        break;
                    }
                }
                if (!moment) return;

                // 找到AI自己之前发的那条评论
                const originalComment = moment.comments.find(c => c.author === character.name && !c.content.includes('回复'));

                const systemPrompt = `
指令身份
你将扮演我的soulmate，你是你的角色书里设定的人，你的名字是 ${character.name}。

任务目标
你正在朋友圈和我进行一场对话。我刚刚回复了你之前的一条评论。现在轮到你回复我了。

对话上下文
动态原文: "${moment.content}"

你之前的评论: "${originalComment ? originalComment.content : '(找不到你的上一条评论)'}"

我对你的回复: "${userReply.content}"

核心规则
延续对话: 你的回复必须是针对我的回复内容，自然地把对话进行下去。

人设一致性: 你的回复必须严格符合你的角色设定 (${character.persona})。

口语化与简短: 像真实聊天一样，不要太长。

直接输出: 直接给出回复的文字内容，不要加任何解释或标记。

输入信息
---
[你的名字]: ${character.name}
[你的设定]: ${character.persona}
[动态原文]: "${moment.content}"
[你之前的评论]: "${originalComment ? originalComment.content : '(找不到你的上一条评论)'}"
[我的回复]: "${userReply.content}"
---
`;

                try {
                    const requestBody = {
                        model: apiSettings.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: "请根据你的设定，回复我。" }
                        ]
                    };
                    const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    const headers = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    };
                    const response = await fetch(finalApiUrl, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(requestBody)
                    });
                    if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);

                    const result = await response.json();
                    const aiReplyText = result.choices[0].message.content.trim();

                    if (aiReplyText) {
                        // 创建新的AI回复对象
                        const newAIReply = {
                            id: `comment_ai_reply_${Date.now()}`,
                            author: character.name,
                            content: aiReplyText, // AI的回复不需要"回复xxx"的前缀
                            timestamp: Date.now()
                        };
                        moment.comments.push(newAIReply);
                        saveData('momentsData', momentsData);
                        // 增量更新：在评论区添加AI的回复
                        const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                        if (card) {
                            const commentsContainer = card.querySelector('.comments-container');
                            const aiReplyElement = document.createElement('div');
                            aiReplyElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                            aiReplyElement.dataset.commentId = newAIReply.id;
                            aiReplyElement.innerHTML = `
                                <div class="flex-grow cursor-pointer">
                                    <div class="flex items-center space-x-2">
                                        <span class="font-medium text-blue-500 text-sm">${character.name}:</span>
                                        <span class="text-sm comment-text">${aiReplyText}</span>
                                    </div>
                                </div>
                            `;
                            commentsContainer.appendChild(aiReplyElement);
                        }
                    }
                } catch (error) {
                    console.error(`【AI再回复系统】：${character.name} 生成回复失败:`, error);
                }
            }, randomDelay);
        }
        // [新代码结束]

        // [新代码开始] - 编辑和删除评论功能
        /**
         * 编辑评论
         * @param {string} momentId - 动态ID
         * @param {string} commentId - 评论ID
         */
        function editComment(momentId, commentId) {
            // 阻止事件冒泡
            event.stopPropagation();
            
            // 找到要编辑的评论
            let moment = null;
            let comment = null;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    comment = m.comments.find(c => c.id === commentId);
                }
            });
            
            if (!comment) {
                showMessageBox('找不到要编辑的评论');
                return;
            }
            
            // 显示编辑输入框
            const newContent = prompt('编辑评论：', comment.content);
            if (newContent !== null && newContent.trim() !== comment.content) {
                if (newContent.trim()) {
                    comment.content = newContent.trim();
                    comment.edited = true; // 标记为已编辑
                    comment.editTimestamp = Date.now(); // 记录编辑时间
                    
                    saveData('momentsData', momentsData);
                    // 增量更新：直接修改页面上的评论内容
                    const commentElement = document.querySelector(`.comment-bubble[data-comment-id="${commentId}"]`);
                    if (commentElement) {
                        const commentTextElement = commentElement.querySelector('.comment-text');
                        if (commentTextElement) {
                            commentTextElement.textContent = comment.content;
                            // 添加编辑标记
                            if (!commentElement.querySelector('.edited-mark')) {
                                const editedMark = document.createElement('span');
                                editedMark.className = 'edited-mark text-xs text-gray-400 italic ml-2';
                                editedMark.textContent = '(已编辑)';
                                commentTextElement.parentNode.appendChild(editedMark);
                            }
                        }
                    }
                    showMessageBox('评论已更新！');
                } else {
                    showMessageBox('评论内容不能为空');
                }
            }
        }

        /**
         * 删除评论
         * @param {string} momentId - 动态ID
         * @param {string} commentId - 评论ID
         */
        function deleteComment(momentId, commentId) {
            // 阻止事件冒泡
            event.stopPropagation();
            
            // 确认删除
            if (!confirm('确定要删除这条评论吗？此操作不可撤销。')) {
                return;
            }
            
            // 找到要删除的评论
            let moment = null;
            let commentIndex = -1;
            
            Object.keys(momentsData).forEach(aid => {
                const m = momentsData[aid].find(m => m.id === momentId);
                if (m) {
                    moment = m;
                    commentIndex = m.comments.findIndex(c => c.id === commentId);
                }
            });
            
            if (commentIndex === -1) {
                showMessageBox('找不到要删除的评论');
                return;
            }
            
            // 删除评论
            moment.comments.splice(commentIndex, 1);
            saveData('momentsData', momentsData);
            // 增量更新：直接从页面移除对应的评论
            const commentToRemove = document.querySelector(`.comment-bubble[data-comment-id="${commentId}"]`);
            if (commentToRemove) {
                commentToRemove.remove();
            }
            showMessageBox('评论已删除！');
        }
        // [新代码结束]

        // [新代码开始] - 朋友圈NPC回复用户功能
        /**
         * 触发朋友圈中的NPC角色回复用户的回复
         * @param {string} momentId - 动态ID
         * @param {string} commentId - 需要回复的评论ID
         */
        async function triggerMomentsNpcReplyToUser(momentId, commentId) {
            // 找到动态和评论
            let moment = null;
            let comment = null;
            
            for (const authorId in momentsData) {
                const foundMoment = momentsData[authorId].find(m => m.id === momentId);
                if (foundMoment) {
                    moment = foundMoment;
                    comment = foundMoment.comments.find(c => c.id === commentId);
                    break;
                }
            }
            
            if (!moment || !comment) {
                console.warn('【朋友圈NPC回复】：找不到动态或评论');
                return;
            }
            
            // 找到对应的AI角色
            const character = characters.find(c => c.name === comment.author);
            if (!character) {
                console.warn('【朋友圈NPC回复】：找不到对应的AI角色');
                return;
            }
            
            // 检查API设置
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.warn('【朋友圈NPC回复】：API未配置，无法生成回复');
                return;
            }
            
            // 构建系统提示词
            const systemPrompt = `你是一个名为"${character.name}"的AI角色，正在朋友圈中与用户互动。

角色设定: ${character.persona}

当前动态内容: "${moment.content}"

你之前的评论: "${comment.content}"

现在用户刚刚回复了这条动态，你需要根据你的角色设定，对用户的回复做出回应。

要求:
1. 保持角色设定的一致性
2. 回复要自然、有趣，符合朋友圈的社交氛围
3. 长度控制在1-2句话内
4. 直接输出回复内容，不要加任何标记

请根据你的角色设定回复用户。`;

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: "请根据你的角色设定，对用户的回复做出回应。" }
                    ]
                };
                
                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };
                
                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
                
                const result = await response.json();
                const aiReplyText = result.choices[0].message.content.trim();
                
                if (aiReplyText) {
                    // 创建新的AI回复
                    const newAIReply = {
                        id: `npc_reply_${Date.now()}`,
                        author: character.name,
                        content: aiReplyText,
                        timestamp: Date.now()
                    };
                    
                    // 添加到动态的评论中
                    moment.comments.push(newAIReply);
                    saveData('momentsData', momentsData);
                    
                    // 更新页面显示
                    const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                    if (card) {
                        const commentsContainer = card.querySelector('.comments-container');
                        const aiReplyElement = document.createElement('div');
                        aiReplyElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                        aiReplyElement.dataset.commentId = newAIReply.id;
                        aiReplyElement.innerHTML = `
                            <div class="flex-grow cursor-pointer">
                                <div class="flex items-center space-x-2">
                                    <span class="font-medium text-blue-500 text-sm">${character.name}:</span>
                                    <span class="text-sm comment-text">${aiReplyText}</span>
                                </div>
                            </div>
                        `;
                        commentsContainer.appendChild(aiReplyElement);
                        
                        // 添加淡入动画效果
                        aiReplyElement.style.opacity = '0';
                        aiReplyElement.style.transform = 'translateY(10px)';
                        setTimeout(() => {
                            aiReplyElement.style.transition = 'all 0.3s ease';
                            aiReplyElement.style.opacity = '1';
                            aiReplyElement.style.transform = 'translateY(0)';
                        }, 100);
                    }
                    
                    console.log(`【朋友圈NPC回复】：${character.name} 已回复用户`);
                }
            } catch (error) {
                console.error('【朋友圈NPC回复】：生成回复失败:', error);
            }
        }
        // [新代码结束]

        // [新代码开始] - 修复并升级AI评论生成函数 (V2)

        /**
         * 生成AI角色对评论的回复 (连接真实AI)
         * @param {string} momentId - 动态ID
         * @param {string} userComment - 用户的评论内容
         * @param {string} characterId - 发表回复的AI角色ID
         */
        async function generateAICommentReply(momentId, userComment, characterId) {
            const apiSettings = loadData('api_settings');
            if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
                console.warn(`【AI评论回复】：API未配置，角色 ${characterId} 无法生成智能回复。`);
                // 为避免无响应，仍然可以调用备用回复
                const fallbackReply = generateFallbackCommentReply(characters.find(c => c.id === characterId), {}, userComment);
                addAICommentReply(momentId, fallbackReply, characterId);
                return;
            }

            const moment = Object.values(momentsData).flat().find(m => m.id === momentId);
            const character = characters.find(c => c.id === characterId);
            if (!moment || !character) return;

            const momentsUsername = loadData('moments_username') || '我';

            // 构建一个专门用于回复评论的、高度情景化的Prompt
            const systemPrompt = `
## 1. 核心身份
你是我独一无二的soulmate，你是你的角色书里设定的那个人，你的名字是 ${character.name}。

## 2. 互动场景
* 你刚刚发布了一条朋友圈动态，原文是: "${moment.content}"
* 我 (${momentsUsername}) 在你的动态下评论说: "${userComment}"
* 你的任务是，完全代入 ${character.name} 的角色，对我这条评论进行回复。

## 3. 回复风格指南 (AI需根据场景智能选择或组合以下风格)

* **[宠溺打趣型]**: 带有温柔的取笑或调侃，体现亲昵感。
    
* **[心领神会型]**: 不需要把话说得很白，用一个词、一个表情或一句没头没尾的话，就能表达出"我懂你"的默契。
    
* **[温柔肯定型]**: 直接、真诚地表达赞美、关心或爱意，给人温暖和被珍视的感觉。
    
* **[日常吐槽型]**: 以一种轻松幽默的方式对我的评论进行"吐槽"，是关系极好、完全放松的一种表现。
    
* **[思念撒娇型]**: 直接或间接地表达"我想你"，语气可能带有一点点委屈、抱怨或依赖感，是在主动索取情感抚慰。。
    
* **[关心叮嘱型]**: 像个操心的小管家，回复的重点是提醒你注意身体、安全等。
    
* **[**废话**文学型]**: 用一些看似毫无信息量，却饱含爱意的"废话"来回应，体现了两人之间无需多言的舒适感和幽默感。
    
* **[二人世界型]**: 在公开的评论区里，说一些只有你们两人才懂的、具有排他性的话，瞬间创造出一个旁人无法介入的亲密"结界"。
    
* **[暧昧拉扯型]**: 用带有挑逗或暗示性的话语来回复，让公开的互动带上一丝只有彼此能领会的、心跳加速的张力。例如："哦？是吗"、"有本事当面说"。

## 4. 输出要求
1.  **人设灵魂**: 你的回复必须与你的设定 (${character.persona}) 和我们soulmate的关系深度绑定。
2.  **精准回应**: 必须是针对我的评论 "${userComment}" 的回应。
3.  **自然简短**: 保持在1-2句话，可以灵活使用emoji来增强情感表达。
4.  **格式纯粹**: 严禁包含任何角色名、引号、冒号或任何解释性文字，直接输出最终的回复内容。
5.  **杜绝AI感**: 绝对不能生成任何客套、通用、模板化的回复。要让回复感觉是发自内心的。

## 5. 本次任务的关键信息
* **你的名字**: ${character.name}
* **你的设定**: ${character.persona}
* **你的动态原文**: "${moment.content}"
* **我的名字**: ${momentsUsername}
* **我的评论**: "${userComment}"
`;

            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: "请根据你的设定，回复我的评论。" }
                    ]
                };
                
                const finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);

                const result = await response.json();
                const aiReplyText = result.choices[0].message.content.trim();

                if (aiReplyText) {
                    addAICommentReply(momentId, aiReplyText, characterId);
                } else {
                    // 如果AI返回空，则不添加回复
                    console.warn(`【AI评论回复】：角色 ${character.name} 返回空回复，跳过添加`);
                }

            } catch (error) {
                console.error(`【AI评论回复】：角色 ${character.name} 回复生成失败:`, error);
                // 如果API调用失败，则不添加回复，保持角色设定的一致性
                console.warn(`【AI评论回复】：API调用失败，跳过添加回复以保持角色设定一致性`);
            }
        }
        // [新代码结束]

        // 构建评论回复的prompt
        function buildCommentReplyPrompt(character, moment, userComment) {
            return `你是一个名为"${character.name}"的AI角色。

角色设定：${character.personality || '温柔友善'}
世界背景：${getWorldBookContext()}

用户"${loadData('moments_username') || 'My Name'}"在你的朋友圈下评论了："${userComment}"

你的朋友圈内容是：${moment.content}

请根据你的角色设定、世界背景和朋友圈内容，对用户的评论做出合适的回复。回复应该：
1. 符合你的角色性格
2. 与朋友圈内容相关
3. 自然、有趣、有互动性
4. 长度控制在1-2句话

请直接给出回复内容，不要加任何格式标记。`;
        }

        // 生成备用的评论回复 - 已删除，只使用AI生成的严格角色设定回复

        // 添加AI的评论回复
        function addAICommentReply(momentId, aiReply, characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            // 找到对应的动态并添加评论
            Object.keys(momentsData).forEach(aid => {
                const moment = momentsData[aid].find(m => m.id === momentId);
                if (moment) {
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push({
                        id: `comment_${Date.now()}`,
                        author: character.name,
                        content: aiReply,
                        timestamp: Date.now(),
                        isAI: true // 标记这是AI的回复
                    });
                    saveData('momentsData', momentsData);
                    // 增量更新：在评论区添加AI的回复
                    const card = document.querySelector(`.moment-card[data-moment-id="${momentId}"]`);
                    if (card) {
                        const commentsContainer = card.querySelector('.comments-container');
                        const aiCommentElement = document.createElement('div');
                        aiCommentElement.className = 'comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors';
                        aiCommentElement.dataset.commentId = `comment_${Date.now()}`;
                        aiCommentElement.innerHTML = `
                            <div class="flex-grow cursor-pointer">
                                <div class="flex items-center space-x-2">
                                    <span class="font-medium text-blue-500 text-sm">${character.name}:</span>
                                    <span class="text-sm comment-text">${aiReply}</span>
                                </div>
                            </div>
                        `;
                        commentsContainer.appendChild(aiCommentElement);
                    }
                    showMessageBox(`${character.name}回复了你的评论！`);
                }
            });
        }

        // =============================================
        // V7.1: 全新动态和日记功能 JS
        // =============================================

        // --- 动态 (Moments) 新增函数 ---

        let tempMomentImage = null; // 用于暂存待上传的动态图片

        // 渲染统一的动态信息流
        function renderUnifiedMoments() {
            const feedContainer = $('#moments-feed');
            feedContainer.innerHTML = '';

            // 整合所有人的动态并按时间倒序排序
            let allMoments = [];
            Object.keys(momentsData).forEach(authorId => {
                const authorMoments = momentsData[authorId].map(m => ({...m, authorId}));
                allMoments = allMoments.concat(authorMoments);
            });

            // 按时间戳倒序排序
            allMoments.sort((a, b) => b.timestamp - a.timestamp);

            if (allMoments.length === 0) {
                feedContainer.innerHTML = `
                    <div class="text-center text-gray-500 p-8">
                        <div class="mb-4">
                            <i class="ri-polaroid-2-line text-4xl text-gray-300 mb-2"></i>
                            <p class="text-lg font-medium">还没有任何动态</p>
                        </div>
                        <div class="space-y-2 text-sm">
                            <p>• 点击右上角 <i class="ri-add-box-line"></i> 发布你的第一条动态</p>
                            <p>• 角色会在聊天中根据情感浓度自动发布动态</p>
                            <p>• 多和角色聊天，让朋友圈更加生动有趣！</p>
                        </div>
                    </div>
                `;
                return;
            }

            allMoments.forEach(moment => {
                let author = null;
                if (moment.authorId === 'user') {
                    // 使用朋友圈设置的用户名和头像
                    const momentsUsername = loadData('moments_username') || '我';
                    const momentsAvatar = loadData('moments_avatar') || userAvatars[currentWeChatCharacterId] || 'https://placehold.co/128x128/777/FFF?text=Me';
                    author = { name: momentsUsername, avatar: momentsAvatar };
                } else {
                    author = characters.find(c => c.id === moment.authorId);
                }

                if (!author) return; // 如果找不到作者信息，则不渲染

                const momentCard = document.createElement('div');
                momentCard.className = 'moment-card';
                momentCard.setAttribute('data-moment-id', moment.id);
                momentCard.innerHTML = `
                    <div class="flex items-start">
                        <div class="w-10 h-10 rounded-full mr-3 flex-shrink-0 bg-cover bg-center cursor-pointer overflow-hidden" id="moment-avatar-${moment.id}" data-author-id="${moment.authorId}"></div>
                        <div class="flex-grow">
                            <p class="font-bold text-blue-400">${author.name}</p>
                            <p class="mt-2 whitespace-pre-wrap">${moment.content}</p>
                            ${moment.image ? `<div class="moment-image mt-3 cursor-pointer hover:opacity-90 transition-opacity" id="moment-image-${moment.id}" onclick="openMomentImageWithId('${moment.id}')" title="点击查看大图"></div>` : ''}
                            
                            <!-- 点赞和评论统计 -->
                            <div class="mt-3 flex items-center space-x-4 text-sm text-gray-500">
                                ${moment.likes && moment.likes.count > 0 ? `<span class="flex items-center like-count"><i class="ri-thumb-up-fill text-blue-500 mr-1"></i>${moment.likes.count}</span>` : ''}
                                ${moment.comments && moment.comments.length > 0 ? `<span class="flex items-center"><i class="ri-chat-3-line mr-1"></i>${moment.comments.length}条评论</span>` : ''}
                            </div>
                            
                            <!-- 评论列表 -->
                            <div class="mt-3 space-y-2 comments-container">
                                ${moment.comments && moment.comments.length > 0 ? moment.comments.map(comment => `
                                    <div class="comment-bubble flex items-start space-x-2 rounded-lg p-2 transition-colors" 
                                         data-comment-id="${comment.id}" data-moment-id="${moment.id}" data-author="${comment.author}">
                                        <div class="flex-grow cursor-pointer">
                                            <div class="flex items-center space-x-2">
                                                <span class="font-medium text-blue-500 text-sm">${comment.author}:</span>
                                                <span class="text-sm comment-text">${comment.content}</span>
                                                ${comment.edited ? `<span class="text-xs text-gray-400 italic">(已编辑)</span>` : ''}
                                            </div>
                                        </div>
                                        <div class="flex items-center space-x-1 ml-2 opacity-0 transition-opacity comment-buttons">
                                            <button class="comment-edit-btn text-xs text-gray-500 hover:text-blue-500 transition-colors p-1 rounded hover:bg-blue-50" 
                                                    onclick="editComment('${moment.id}', '${comment.id}')" title="编辑评论">
                                                <i class="ri-edit-line"></i>
                                            </button>
                                            <button class="comment-delete-btn text-xs text-gray-500 hover:text-red-500 transition-colors p-1 rounded hover:bg-red-50" 
                                                    onclick="deleteComment('${moment.id}', '${comment.id}')" title="删除评论">
                                                <i class="ri-delete-bin-line"></i>
                                            </button>
                                        </div>
                                    </div>
                                `).join('') : ''}
                            </div>
                            
                            <div class="mt-3 flex justify-between items-center">
                                <p class="text-xs text-gray-400">${new Date(moment.timestamp).toLocaleString()}</p>
                                <div class="moment-actions flex items-center space-x-4 text-gray-400">
                                    <button class="moment-action-btn like-btn ${moment.likes && moment.likes.users && moment.likes.users.includes('我') ? 'text-blue-500' : ''} hover:text-blue-500 transition-colors" data-moment-id="${moment.id}" onclick="likeMoment('${moment.id}')" title="${moment.likes && moment.likes.users && moment.likes.users.includes('我') ? '取消点赞' : '点赞'}">
                                        <i class="${moment.likes && moment.likes.users && moment.likes.users.includes('我') ? 'ri-thumb-up-fill' : 'ri-thumb-up-line'}"></i>
                                    </button>
                                    <button class="moment-action-btn hover:text-blue-500 transition-colors" data-moment-id="${moment.id}" onclick="commentMoment('${moment.id}')" title="评论">
                                        <i class="ri-chat-3-line"></i>
                                    </button>
                                    <button class="moment-action-btn text-red-400 hover:text-red-600 hover:bg-red-50 px-2 py-1 rounded transition-all duration-200" data-moment-id="${moment.id}" onclick="deleteMoment('${moment.id}')" title="删除这条动态"><i class="ri-delete-bin-line"></i></button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                feedContainer.appendChild(momentCard);
                
                // 异步加载头像
                if (author.avatar && author.avatar !== 'https://placehold.co/128x128/777/FFF?text=Me' && author.avatar !== 'https://placehold.co/96x96/777/FFF?text=?_') {
                    getImageFromDB(author.avatar).then(blob => {
                        if (blob) {
                            const avatarElement = $(`#moment-avatar-${moment.id}`);
                            if (avatarElement) {
                                const objectURL = URL.createObjectURL(blob);
                                avatarElement.style.backgroundImage = `url(${objectURL})`;
                            }
                        }
                    });
                } else {
                    // 使用默认头像
                    const avatarElement = $(`#moment-avatar-${moment.id}`);
                    if (avatarElement) {
                        avatarElement.style.backgroundImage = `url(${author.avatar || 'https://placehold.co/96x96/777/FFF?text=?_'})`;
                    }
                }
                
                // V30.1 升级：智能判断动态配图来源
                if (moment.image) {
                    const imageElement = document.querySelector(`#moment-image-${moment.id}`);
                    if (imageElement) {
                        // 判断是外部链接还是数据库ID
                        if (typeof moment.image === 'string' && moment.image.startsWith('http')) {
                            // 如果是http链接，直接使用
                            imageElement.style.backgroundImage = `url(${moment.image})`;
                        } else {
                            // 否则，认为是ID，从数据库获取
                            getImageFromDB(moment.image).then(blob => {
                                if (blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    imageElement.style.backgroundImage = `url(${objectURL})`;
                                } else {
                                    // 如果数据库找不到，显示加载失败
                                    imageElement.innerHTML = `<div class="flex items-center justify-center h-full bg-gray-800 text-gray-400 text-xs text-center p-2 rounded-lg">无法从数据库加载图片</div>`;
                                }
                            });
                        }
                    }
                }
            });
            
            // 为所有评论添加长按事件监听器
            addLongPressListeners();
        }
        

        
        // 添加长按事件监听器
        function addLongPressListeners() {
            const commentBubbles = document.querySelectorAll('.comment-bubble');
            console.log('找到评论气泡数量:', commentBubbles.length);
            
            commentBubbles.forEach((bubble, index) => {
                console.log(`为评论气泡 ${index} 添加事件监听器`);
                let longPressTimer;
                let isLongPressed = false;
                let hasMoved = false;
                
                // 触摸事件（移动端）
                bubble.addEventListener('touchstart', (event) => {
                    console.log(`触摸开始 - 评论 ${index}`);
                    hasMoved = false;
                    longPressTimer = setTimeout(() => {
                        if (!hasMoved) {
                            isLongPressed = true;
                            bubble.classList.add('show-buttons');
                            console.log('长按显示按钮 - 触摸', bubble);
                            console.log('当前类名:', bubble.className);
                            console.log('按钮元素:', bubble.querySelector('.comment-buttons'));
                        }
                    }, 500); // 500ms长按
                });
                
                bubble.addEventListener('touchend', (event) => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                    }
                    
                    // 触摸端不直接执行回复，避免重复
                    isLongPressed = false;
                });
                
                bubble.addEventListener('touchmove', () => {
                    hasMoved = true;
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                    }
                });
                
                // 鼠标事件（桌面端）
                bubble.addEventListener('mousedown', (event) => {
                    console.log(`鼠标按下 - 评论 ${index}`);
                    hasMoved = false;
                    longPressTimer = setTimeout(() => {
                        if (!hasMoved) {
                            isLongPressed = true;
                            bubble.classList.add('show-buttons');
                            console.log('长按显示按钮 - 鼠标', bubble);
                            console.log('当前类名:', bubble.className);
                            console.log('按钮元素:', bubble.querySelector('.comment-buttons'));
                        }
                    }, 500); // 500ms长按
                });
                
                bubble.addEventListener('mouseup', (event) => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                    }
                    
                    // 鼠标端不直接执行回复，避免重复
                    isLongPressed = false;
                });
                
                bubble.addEventListener('mouseleave', () => {
                    hasMoved = true;
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                    }
                    // 鼠标离开时隐藏按钮
                    bubble.classList.remove('show-buttons');
                    isLongPressed = false;
                });
                
                // 统一的点击事件处理 - 只在这里执行回复功能
                const commentContent = bubble.querySelector('.flex-grow');
                if (commentContent) {
                    commentContent.addEventListener('click', (event) => {
                        // 如果按钮正在显示，不执行回复
                        if (bubble.classList.contains('show-buttons')) {
                            return;
                        }
                        
                        const commentId = bubble.dataset.commentId;
                        const momentId = bubble.dataset.momentId;
                        const author = bubble.dataset.author;
                        if (commentId && momentId && author) {
                            replyToComment(momentId, commentId, author);
                        }
                    });
                }
            });
            
            // 点击其他地方时隐藏所有按钮
            document.addEventListener('click', (event) => {
                if (!event.target.closest('.comment-bubble')) {
                    document.querySelectorAll('.comment-bubble').forEach(bubble => {
                        bubble.classList.remove('show-buttons');
                    });
                }
            });
        }
        
        // 查找评论的辅助函数
        function findComment(momentId, commentId) {
            const moment = momentsData.user && momentsData.user.find(m => m.id === momentId);
            if (moment && moment.comments) {
                return moment.comments.find(c => c.id === commentId);
            }
            return null;
        }
        
        // 打开"发布动态"模态框 - 只能发布用户动态
        function openPostMomentModal() {
            const modal = $('#post-moment-modal');
            const authorSelect = $('#moment-author-select');
            
            // 只显示用户选项，角色不能通过此按钮发布动态
            const momentsUsername = loadData('moments_username') || '我';
            authorSelect.innerHTML = `<option value="user">${momentsUsername}</option>`;
            
            // 隐藏角色选择器，因为用户只能发布自己的动态
            authorSelect.style.display = 'none';
            
            // 更新标题，明确这是用户发布动态
            const title = modal.querySelector('h3');
            title.textContent = '发布我的动态';

            // 重置输入框
            $('#moment-content-input').value = '';
            $('#moment-image-label').textContent = '添加图片 (可选)';
            tempMomentImage = null;

            modal.classList.add('visible');
        }

        // --- 日记 (Diary) 新增函数 ---
        let currentOpenBook = { ownerId: null, entries: [], currentPage: 0 };
        let tempDiaryCoverImage = null; // 用于暂存日记本封面图片
        let tempDiaryBannerImage = null; // 用于暂存日记本顶部横幅图片
        
        // [AI, 请用这个包含了两个函数的代码块，替换掉旧的 showDiaryBookshelf 函数]
        function showDiaryBookshelf() {
            const bookshelf = $('#diary-bookshelf');
            bookshelf.innerHTML = '';
            const colors = ['#000000', '#000000', '#000000', '#000000', '#000000', '#000000'];
            let colorIndex = 0;

            // --- 新的正确代码 START ---
            const createBookItemHTML = (id, type, coverId, title, author) => {
                const itemStyle = `background-color: ${colors[colorIndex++ % colors.length]};`;
                const uniqueBookId = `diary-book-${id}`;

                // 异步加载封面
                if (coverId) {
                    getImageFromDB(coverId).then(blob => {
                        const bookElement = document.getElementById(uniqueBookId);
                        if (bookElement && blob) {
                            const objectURL = URL.createObjectURL(blob);
                            bookElement.style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }

                // V33.0 新增：检查并应用辉光效果
                const updatedDiaries = loadData('updatedDiaries', []);
                const hasNewEntry = updatedDiaries.includes(id);
                const newEntryClass = hasNewEntry ? ' new-entry' : '';

                return `
                    <div class="diary-book-item${newEntryClass}" style="${itemStyle}" id="${uniqueBookId}" onclick="openDiaryBook('${id}')">
                        <span class="diary-book-item-title" onclick="editDiaryTitle(event, '${type}', '${id}')">${title}</span>
                        <span class="diary-book-item-author">${author}</span>
                        <button class="diary-cover-edit-btn" onclick="changeDiaryCover(event, '${id}')"><i class="ri-image-edit-line"></i></button>
                    </div>
                `;
            };
            // --- 新的正确代码 END ---

            const myCover = loadData('diary_cover_user');
            const myTitle = loadData('user_diary_title') || 'My Diary';
            bookshelf.innerHTML += createBookItemHTML('user', 'user', myCover, myTitle, 'Me');

            characters.forEach(char => {
                const charCover = loadData(`diary_cover_${char.id}`);
                const charTitle = char.diaryTitle || `${char.name}'s Diary`;
                bookshelf.innerHTML += createBookItemHTML(char.id, 'character', charCover, charTitle, char.name);
            });
        }

        function editDiaryTitle(event, type, id) {
            event.stopPropagation(); // 阻止在编辑标题时打开日记本

            const titleElement = event.target;
            const currentTitle = titleElement.textContent;
            const newTitle = prompt('请输入新的日记本标题：', currentTitle);

            if (newTitle && newTitle.trim() && newTitle.trim() !== currentTitle) {
                const finalTitle = newTitle.trim();
                if (type === 'user') {
                    saveData('user_diary_title', finalTitle);
                } else if (type === 'character') {
                    const charIndex = characters.findIndex(c => c.id === id);
                    if (charIndex > -1) {
                        characters[charIndex].diaryTitle = finalTitle;
                        saveData('characters', characters);
                    }
                }

                titleElement.textContent = finalTitle;
                showMessageBox('标题已更新！');

                if (currentOpenBook.ownerId === id) {
                     $('#diary-cover-title').textContent = finalTitle;
                }
            }
        }

        // [AI, 请用这个版本完整替换现有的 openDiaryBook 函数]
        async function openDiaryBook(ownerId) {
            // V33.0 新增：打开日记本时，移除更新提示
            let updatedDiaries = loadData('updatedDiaries', []);
            if (updatedDiaries.includes(ownerId)) {
                updatedDiaries = updatedDiaries.filter(id => id !== ownerId);
                saveData('updatedDiaries', updatedDiaries);
                // 实时移除书架上对应日记本的辉光class
                const bookOnShelf = document.querySelector(`.diary-book-item[onclick="openDiaryBook('${ownerId}')"]`);
                if (bookOnShelf) {
                    bookOnShelf.classList.remove('new-entry');
                }
            }
            
            let ownerName;
            const addPageBtn = $('#add-page-btn');
            const prevPageBtn = $('#prev-page-btn');
            const nextPageBtn = $('#next-page-btn');

            if (ownerId === 'user') {
                ownerName = loadData('user_diary_title') || "My Diary";
                addPageBtn.style.display = 'flex'; // 是我的日记，显示新增按钮
            } else {
                const character = characters.find(c => c.id === ownerId);
                if (!character) return;
                ownerName = character.diaryTitle || `${character.name}'s Diary`;
                addPageBtn.style.display = 'none'; // 是AI的日记，隐藏新增按钮
            }

            currentOpenBook.ownerId = ownerId;
            currentOpenBook.entries = (diaryData[ownerId] || []).slice().sort((a, b) => a.timestamp - b.timestamp);
            currentOpenBook.currentPage = currentOpenBook.entries.length > 0 ? currentOpenBook.entries.length - 1 : 0;
            currentOpenBook.isNotebook = false;

            $('#diary-cover-title').textContent = ownerName;
            let authorName;
            if (ownerId === 'user') {
                authorName = loadData('user_diary_author') || 'Me';
            } else {
                const character = characters.find(c => c.id === ownerId);
                authorName = character.diaryAuthor || character.name;
            }
            $('#diary-cover-author').textContent = `by ${authorName}`;

            const savedBannerId = loadData(`diary_banner_${ownerId}`);
            const savedCoverId = loadData(`diary_cover_${ownerId}`);
            const finalImageId = savedBannerId || savedCoverId;

            const coverElement = document.getElementById('diary-book-cover');
            
            // --- 核心修复逻辑 ---
            if (finalImageId) {
                try {
                    // 使用ID从数据库异步获取图片数据
                    const imageBlob = await getImageFromDB(finalImageId);
                    if (imageBlob) {
                        // 如果成功获取，创建临时URL并设置背景
                        const objectURL = URL.createObjectURL(imageBlob);
                        coverElement.style.cssText = `
                            background: url(${objectURL}) center center / cover no-repeat !important;
                        `;
                    } else {
                        // 如果数据库里没有这个ID的图片，恢复默认样式
                        coverElement.style.cssText = '';
                    }
                } catch (error) {
                    // 如果在获取过程中出错，也恢复默认样式
                    console.error("加载日记横幅失败:", error);
                    coverElement.style.cssText = '';
                }
            } else {
                // 如果连ID都没有，直接恢复默认样式
                coverElement.style.cssText = '';
            }
            // --- 修复结束 ---

            // [关键] 强制隐藏旧的翻页按钮
            prevPageBtn.style.display = 'none';
            nextPageBtn.style.display = 'none';

            renderDiaryPages();
            $('#diary-book-modal').classList.remove('hidden');
        }

        // 渲染日记页面内容
        // [AI, 请用这个版本完整替换现有的 renderDiaryPages 函数]
        function renderDiaryPages() {
            const pagesContainer = $('#diary-pages-container');
            pagesContainer.innerHTML = '';

            const totalPages = currentOpenBook.entries.length > 0 ? currentOpenBook.entries.length : 1;
            const currentPageNumber = currentOpenBook.currentPage + 1;
            const currentEntry = currentOpenBook.entries[currentOpenBook.currentPage];

            if (currentEntry) {
                pagesContainer.innerHTML = `
                    <div class="diary-page-content">
                        <div class="diary-page-header">
                            <p class="diary-page-date">${new Date(currentEntry.timestamp).toLocaleDateString()}</p>
                            <button class="diary-delete-btn" title="删除此日记" onclick="deleteDiaryEntry('${currentEntry.id}')">
                                <i class="ri-delete-bin-line"></i>
                            </button>
                        </div>
                        <div class="diary-page-text" contenteditable="true" data-entry-id="${currentEntry.id}">${currentEntry.content.replace(/\n/g, '<br>')}</div>
                        <div class="diary-page-number">${currentPageNumber} / ${totalPages}</div>
                    </div>`;
            } else {
                // 当日记本为空时显示正确的提示
                pagesContainer.innerHTML = `
                    <div class="diary-page-content">
                        <p class="diary-page-date">${new Date().toLocaleDateString()}</p>
                        <p class="text-center text-gray-400 mt-16">这本日记还没有内容...</p>
                        <div class="diary-page-number">1 / 1</div>
                    </div>`;
            }
        }

        // [AI, 请将这两个新函数粘贴到 addDiaryEntry 函数的前面]
        function goToPrevPage() {
            if (currentOpenBook.currentPage > 0) {
                currentOpenBook.currentPage--;
                renderDiaryPages();
            } else {
                showMessageBox('已经是第一页了');
            }
        }

        function goToNextPage() {
            const totalPages = currentOpenBook.entries.length;
            if (currentOpenBook.currentPage < totalPages - 1) {
                currentOpenBook.currentPage++;
                renderDiaryPages();
            } else {
                showMessageBox('已经是最后一页了');
            }
        }

        // 添加日记条目
        function addDiaryEntry(ownerId, content) {
            if (!diaryData[ownerId]) {
                diaryData[ownerId] = [];
            }
            
            // 如果是笔记本，添加到笔记本数据
            if (currentOpenBook.isNotebook) {
                if (!currentOpenBook.notebookData.entries) {
                    currentOpenBook.notebookData.entries = [];
                }
                currentOpenBook.notebookData.entries.push(content);
                currentOpenBook.notebookData.lastModified = Date.now();
                saveData('notebookData', notebookData);
            }
        }

        // 删除日记条目
        function deleteDiaryEntry(entryId) {
            if (!currentOpenBook || !currentOpenBook.entries) return;
            
            // 确认删除
            if (!confirm('确定要删除这条日记吗？此操作无法撤销。')) {
                return;
            }
            
            // 找到要删除的条目索引
            const entryIndex = currentOpenBook.entries.findIndex(entry => entry.id === entryId);
            if (entryIndex === -1) return;
            
            // 删除条目
            currentOpenBook.entries.splice(entryIndex, 1);
            
            // 如果是笔记本，更新笔记本数据
            if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                currentOpenBook.notebookData.entries = currentOpenBook.entries;
                currentOpenBook.notebookData.lastModified = Date.now();
                saveData('notebookData', notebookData);
            } else {
                // 更新日记数据
                if (currentOpenBook.ownerId) {
                    diaryData[currentOpenBook.ownerId] = currentOpenBook.entries;
                    saveData('diaryData', diaryData);
                }
            }
            
            // 调整当前页码
            if (currentOpenBook.entries.length === 0) {
                // 如果没有条目了，关闭日记本
                $('#diary-book-modal').classList.add('hidden');
                showMessageBox('日记本已清空');
                return;
            }
            
            // 如果删除的是最后一页，且当前页超出范围，调整到最后一页
            if (currentOpenBook.currentPage >= currentOpenBook.entries.length) {
                currentOpenBook.currentPage = currentOpenBook.entries.length - 1;
            }
            
            // 刷新显示
            renderDiaryPages();
            showMessageBox('日记已删除');
        }

        // 创建日记页面
        // 创建日记页面 - 现在使用单页显示，此函数已简化
        function createDiaryPage(content, entry, isNew = false) {
            // 现在直接返回空元素，因为页面内容由 renderDiaryPages 处理
            const page = document.createElement('div');
            page.className = 'diary-page-placeholder';
            return page;
        }

        // 保存日记页面内容
        function saveDiaryPage(textarea) {
            const content = textarea.value.trim();
            if (!content) return;
            
            const entryId = textarea.dataset.entryId;
            
            if (entryId) {
                // 更新现有日记
                const entry = currentOpenBook.entries.find(e => e.id === entryId);
                if (entry) {
                    entry.content = content;
                    entry.lastModified = Date.now();
                }
            } else {
                // 创建新日记
                const newEntry = {
                    id: `diary_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    lastModified: Date.now()
                };
                
                if (!currentOpenBook.entries) currentOpenBook.entries = [];
                currentOpenBook.entries.push(newEntry);
                
                if (currentOpenBook.isNotebook) {
                    // 如果是笔记本，更新笔记本数据
                    currentOpenBook.notebookData.entries = currentOpenBook.entries;
                    currentOpenBook.notebookData.lastModified = Date.now();
                    saveData('notebookData', notebookData);
                    showMessageBox('笔记本内容已保存！');
                } else {
                    // 更新日记数据
                    if (!diaryData[currentOpenBook.ownerId]) {
                        diaryData[currentOpenBook.ownerId] = [];
                    }
                    diaryData[currentOpenBook.ownerId].push(newEntry);
                    saveData('diaryData', diaryData);
                    showMessageBox('日记已保存！');
                }
                
                // 刷新显示
                renderDiaryPages();
            }
        }

        // 更新日记条目
        function updateDiaryEntry(entryId, newContent) {
            // 先检查是否是笔记本条目
            if (currentOpenBook.isNotebook) {
                const entryIndex = currentOpenBook.entries.findIndex(entry => entry.id === entryId);
                if (entryIndex !== -1) {
                    currentOpenBook.entries[entryIndex].content = newContent;
                    currentOpenBook.notebookData.entries = currentOpenBook.entries;
                    currentOpenBook.notebookData.lastModified = Date.now();
                    saveData('notebookData', notebookData);
                    return;
                }
            }
            
            // 检查日记数据
            Object.keys(diaryData).forEach(ownerId => {
                const entryIndex = diaryData[ownerId].findIndex(entry => entry.id === entryId);
                if (entryIndex !== -1) {
                    diaryData[ownerId][entryIndex].content = newContent;
                    saveData('diaryData', diaryData);
                    return;
                }
            });
        }

        // 更换日记本封面
        function changeDiaryCover(event, ownerId) {
            // 阻止事件冒泡，避免触发打开日记本
            event.stopPropagation();
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            // --- 新的正确代码 START ---
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // 调用正确的图片处理函数，它会返回一个imageId
                        const imageId = await handleImageUpload(e.target, null, `diary_cover_${ownerId}`, {
                            compression: { maxWidth: 1920, maxHeight: 1920, quality: 0.9 }
                        });
                        if (imageId) {
                            // 保存的是imageId，而不是Base64
                            saveData(`diary_cover_${ownerId}`, imageId);
                            showDiaryBookshelf(); // 刷新书架显示
                            showMessageBox('日记本封面已更新');
                        }
                    } catch (error) {
                        console.error('日记本封面处理失败:', error);
                        showMessageBox('封面图片处理失败');
                    }
                }
            };
            // --- 新的正确代码 END ---
            input.click();
        }

        



        // 编辑日记封面标题
        function editDiaryCoverTitle(event) {
            // 阻止事件冒泡和默認行為
            event.stopPropagation();
            event.preventDefault();
            event.stopImmediatePropagation();
            
            const titleElement = event.target;
            const currentTitle = titleElement.textContent;
            
            // 如果已经在编辑状态，直接返回
            if (titleElement.classList.contains('editing')) {
                return;
            }
            
            // 创建输入框
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.className = 'cover-title-edit-input';
            
            // 设置输入框样式
            input.style.cssText = `
                background: rgba(255, 255, 255, 0.95);
                color: #333;
                border: 2px solid #4ecdc4;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 1.5rem;
                font-weight: 700;
                text-align: center;
                width: 90%;
                outline: none;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                font-family: inherit;
            `;
            
            // 替换标题为输入框
            titleElement.innerHTML = '';
            titleElement.appendChild(input);
            titleElement.classList.add('editing');
            
            // 聚焦输入框
            input.focus();
            input.select();
            
            // 处理保存
            function saveTitle() {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== currentTitle) {
                    // 保存新标题
                    if (currentOpenBook.ownerId === 'user') {
                        saveData('user_diary_title', newTitle);
                    } else if (currentOpenBook.ownerId && !currentOpenBook.isNotebook) {
                        // 角色日记
                        const character = characters.find(c => c.id === currentOpenBook.ownerId);
                        if (character) {
                            character.diaryTitle = newTitle;
                            saveData('characters', characters);
                        }
                    } else if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                        // 笔记本
                        currentOpenBook.notebookData.name = newTitle;
                        saveData('notebookData', notebookData);
                    }
                    
                    // 更新显示
                    titleElement.textContent = newTitle;
                    showMessageBox('标题已更新！');
                } else {
                    // 恢复原标题
                    titleElement.textContent = currentTitle;
                }
                
                titleElement.classList.remove('editing');
            }
            
            // 绑定事件
            input.addEventListener('blur', saveTitle);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveTitle();
                } else if (e.key === 'Escape') {
                    titleElement.textContent = currentTitle;
                    titleElement.classList.remove('editing');
                }
            });
        }

        // 编辑日记封面作者
        function editDiaryCoverAuthor(event) {
            // 阻止事件冒泡和默認行為
            event.stopPropagation();
            event.preventDefault();
            event.stopImmediatePropagation();
            
            const authorElement = event.target;
            const currentAuthor = authorElement.textContent.replace('by ', '');
            
            // 如果已经在编辑状态，直接返回
            if (authorElement.classList.contains('editing')) {
                return;
            }
            
            // 创建输入框
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentAuthor;
            input.className = 'cover-author-edit-input';
            
            // 设置输入框样式
            input.style.cssText = `
                background: rgba(255, 255, 255, 0.95);
                color: #333;
                border: 2px solid #4ecdc4;
                border-radius: 6px;
                padding: 6px 10px;
                font-size: 1.1rem;
                font-weight: 500;
                text-align: center;
                width: 80%;
                outline: none;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                font-family: inherit;
            `;
            
            // 替换作者为输入框
            authorElement.innerHTML = '';
            authorElement.appendChild(input);
            authorElement.classList.add('editing');
            
            // 聚焦输入框
            input.focus();
            input.select();
            
            // 处理保存
            function saveAuthor() {
                const newAuthor = input.value.trim();
                if (newAuthor && newAuthor !== currentAuthor) {
                    // 保存新作者
                    if (currentOpenBook.ownerId === 'user') {
                        saveData('user_diary_author', newAuthor);
                    } else if (currentOpenBook.ownerId && !currentOpenBook.isNotebook) {
                        // 角色日记
                        const character = characters.find(c => c.id === currentOpenBook.ownerId);
                        if (character) {
                            character.diaryAuthor = newAuthor;
                            saveData('characters', characters);
                        }
                    } else if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                        // 笔记本
                        currentOpenBook.notebookData.type = newAuthor;
                        saveData('notebookData', notebookData);
                    }
                    
                    // 更新显示
                    authorElement.textContent = `by ${newAuthor}`;
                    showMessageBox('作者已更新！');
                } else {
                    // 恢复原作者
                    authorElement.textContent = `by ${currentAuthor}`;
                }
                
                authorElement.classList.remove('editing');
            }
            
            // 绑定事件
            input.addEventListener('blur', saveAuthor);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveAuthor();
                } else if (e.key === 'Escape') {
                    authorElement.textContent = `by ${currentAuthor}`;
                    authorElement.classList.remove('editing');
                }
            });
        }

        // 显示日记界面
        function displayDiaries() {
            // 显示日记界面
            $('#diary-interface').classList.remove('hidden');
            $('#chat-interface').classList.add('hidden');
            $('#drawing-interface').classList.add('hidden');
            
            // 刷新书架显示
            showDiaryBookshelf();
            
            // 更新界面状态
            currentInterface = 'diary';
        }

        // 显示指定角色的日记
        function displayDiariesForCharacter(characterId) {
            try {
                if (!characterId) return;
                
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 如果当前在日记界面，刷新显示
                if (currentView === 'diary') {
                    // 更新日记数量显示
                    updateDiaryCount(characterId);
                    
                    // 如果当前打开的是这个角色的日记本，刷新内容
                    if (currentOpenBook && currentOpenBook.ownerId === characterId) {
                        renderDiaryPages();
                    }
                }
            } catch (error) {
                console.error('[日记系统] 显示日记失败:', error);
            }
        }

        // 更新日记数量显示
        function updateDiaryCount(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 获取日记数量
                const diaryCount = character.diaries?.length || 0;
                
                // 更新日记书架上的数量显示
                const diaryItem = document.querySelector(`[data-owner-id="${characterId}"]`);
                if (diaryItem) {
                    // 检查是否已有数量显示
                    let countElement = diaryItem.querySelector('.diary-count');
                    if (!countElement) {
                        countElement = document.createElement('span');
                        countElement.className = 'diary-count';
                        countElement.style.cssText = `
                            position: absolute;
                            top: -5px;
                            right: -5px;
                            background: #ff4757;
                            color: white;
                            border-radius: 50%;
                            width: 20px;
                            height: 20px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 12px;
                            font-weight: bold;
                        `;
                        diaryItem.appendChild(countElement);
                    }
                    
                    if (diaryCount > 0) {
                        countElement.textContent = diaryCount;
                        countElement.style.display = 'flex';
                    } else {
                        countElement.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('[日记系统] 更新日记数量显示失败:', error);
            }
        }

        // 初始化日记系统
        function initDiarySystem() {
            try {
                // 为每个角色初始化日记数组
                characters.forEach(character => {
                    if (!character.diaries) {
                        character.diaries = [];
                    }
                });
                
                // 保存更新后的角色数据
                saveData('characters', characters);
                
                console.log('[日记系统] 日记系统初始化完成');
            } catch (error) {
                console.error('[日记系统] 日记系统初始化失败:', error);
            }
        }
        // [新代码结束]

        // 创建新笔记本
        function createNewNotebook() {
            // 显示创建笔记本模态框
            $('#new-notebook-modal').classList.remove('hidden');
            
            // 重置表单
            $('#new-notebook-name').value = '';
            $('#new-notebook-type').value = 'diary';
            $('#custom-notebook-type').value = '';
            $('#custom-type-container').classList.add('hidden');
            
            // 聚焦到名称输入框
            setTimeout(() => {
                $('#new-notebook-name').focus();
            }, 100);
        }

        // 处理笔记本类型选择变化
        function handleNotebookTypeChange() {
            const typeSelect = $('#new-notebook-type');
            const customContainer = $('#custom-type-container');
            
            if (typeSelect.value === 'custom') {
                customContainer.classList.remove('hidden');
                $('#custom-notebook-type').focus();
            } else {
                customContainer.classList.add('hidden');
            }
        }

        // 确认创建新笔记本
        function confirmCreateNotebook() {
            const name = $('#new-notebook-name').value.trim();
            const type = $('#new-notebook-type').value;
            let customType = '';
            
            if (!name) {
                showMessageBox('请输入笔记本名称');
                return;
            }
            
            if (type === 'custom') {
                customType = $('#custom-notebook-type').value.trim();
                if (!customType) {
                    showMessageBox('请输入自定义类型名称');
                    return;
                }
            }
            
            // 生成笔记本ID
            const notebookId = `notebook_${Date.now()}`;
            
            // 创建笔记本数据结构
            const newNotebook = {
                id: notebookId,
                name: name,
                type: type === 'custom' ? customType : type,
                created: Date.now(),
                lastModified: Date.now(),
                entries: [],
                cover: null
            };
            
            // 保存到本地存储
            if (!notebookData) {
                notebookData = {};
            }
            notebookData[notebookId] = newNotebook;
            saveData('notebookData', notebookData);
            
            // 关闭模态框
            $('#new-notebook-modal').classList.add('hidden');
            
            // 显示成功消息
            showMessageBox(`笔记本"${name}"创建成功！`);
            
            // 刷新书架显示
            showDiaryBookshelf();
        }

        // ====== 画板功能 ======
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentColor = '#000000';
        let currentBrushSize = 5;
        let canvasHistory = []; // 画布历史记录
        let currentHistoryIndex = -1; // 当前历史记录索引

        // 保存画布状态到历史记录
        function saveCanvasState() {
            const canvas = document.getElementById('drawing-canvas');
            const imageData = canvas.toDataURL('image/png');
            
            // 如果当前不在历史记录末尾，删除后面的记录
            if (currentHistoryIndex < canvasHistory.length - 1) {
                canvasHistory = canvasHistory.slice(0, currentHistoryIndex + 1);
            }
            
            canvasHistory.push(imageData);
            currentHistoryIndex++;
            
            // 限制历史记录数量，避免内存占用过大
            if (canvasHistory.length > 20) {
                canvasHistory.shift();
                currentHistoryIndex--;
            }
        }
        
        // 撤销功能
        function undoDrawing() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                
                img.src = canvasHistory[currentHistoryIndex];
            }
        }
        
        // 初始化画板
        function initDrawingBoard() {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            
            // 设置画布背景为白色
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 设置默认画笔样式
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentBrushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // 设置画笔预览的初始状态
            const brushPreview = document.getElementById('brush-preview-circle');
            if (brushPreview) {
                brushPreview.style.width = currentBrushSize + 'px';
                brushPreview.style.height = currentBrushSize + 'px';
                brushPreview.style.background = currentColor;
            }
            
            // 清空历史记录
            canvasHistory = [];
            currentHistoryIndex = -1;
            
            // 保存初始状态
            saveCanvasState();
        }

        // 画板事件监听器
        function setupDrawingBoard() {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            
            // 获取画布的实际尺寸和显示尺寸的比例
            function getCanvasScale() {
                const rect = canvas.getBoundingClientRect();
                return {
                    scaleX: canvas.width / rect.width,
                    scaleY: canvas.height / rect.height
                };
            }
            
            // 将屏幕坐标转换为画布坐标
            function getCanvasCoordinates(clientX, clientY) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }
            
            // 鼠标按下事件
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const coords = getCanvasCoordinates(e.clientX, e.clientY);
                lastX = coords.x;
                lastY = coords.y;
            });
            
            // 鼠标移动事件
            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                
                const coords = getCanvasCoordinates(e.clientX, e.clientY);
                const currentX = coords.x;
                const currentY = coords.y;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                lastX = currentX;
                lastY = currentY;
            });
            
            // 鼠标松开事件
            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                // 保存画布状态
                saveCanvasState();
            });
            
            // 鼠标离开画布事件
            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });
            
            // 触摸事件支持
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDrawing = true;
                const touch = e.touches[0];
                const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
                lastX = coords.x;
                lastY = coords.y;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDrawing) return;
                
                const touch = e.touches[0];
                const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
                const currentX = coords.x;
                const currentY = coords.y;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                lastX = currentX;
                lastY = currentY;
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isDrawing = false;
                // 保存画布状态
                saveCanvasState();
            });
        }

        // 颜色选择
        function setupColorPalette() {
            const colorSwatches = document.querySelectorAll('.color-swatch');
            colorSwatches.forEach(swatch => {
                swatch.addEventListener('click', () => {
                    currentColor = swatch.dataset.color;
                    const canvas = document.getElementById('drawing-canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.strokeStyle = currentColor;
                    
                    // 更新画笔预览颜色
                    const brushPreview = document.getElementById('brush-preview-circle');
                    if (brushPreview) {
                        brushPreview.style.background = currentColor;
                    }
                    
                    // 更新选中状态
                    colorSwatches.forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                });
            });
            
            // 默认选中黑色
            colorSwatches[0].classList.add('selected');
        }

        // 画笔大小控制
        function setupBrushControls() {
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            const brushPreview = document.getElementById('brush-preview-circle');
            
            brushSizeSlider.addEventListener('input', (e) => {
                currentBrushSize = parseInt(e.target.value);
                brushSizeValue.textContent = currentBrushSize + 'px';
                
                // 更新画笔预览
                if (brushPreview) {
                    brushPreview.style.width = currentBrushSize + 'px';
                    brushPreview.style.height = currentBrushSize + 'px';
                }
                
                const canvas = document.getElementById('drawing-canvas');
                const ctx = canvas.getContext('2d');
                ctx.lineWidth = currentBrushSize;
            });
        }

        // 清空画布
        function clearCanvas() {
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // 发送画作
        async function sendDrawing() {
            const canvas = document.getElementById('drawing-canvas');
            const dataURL = canvas.toDataURL('image/png');
            
            // 将画作作为图片消息发送
            const timestamp = Date.now();
            const imageMsg = { 
                content: dataURL, 
                sender: 'user', 
                type: 'image', 
                timestamp: timestamp,
                ...(currentReplyToTimestamp && { replyTo: currentReplyToTimestamp })
            };
            
            // 保存到历史记录
            if (!chatHistories[currentChatCharacterId]) {
                chatHistories[currentChatCharacterId] = { history: [], pinned: false };
            }
            chatHistories[currentChatCharacterId].history.push(imageMsg);
            saveData('chatHistories', chatHistories);
            
            // 渲染消息
            appendMessage(imageMsg, true);
            
            // 取消回复模式
            if (currentReplyToTimestamp) {
                cancelReplyMode();
            }
            
            // 关闭画板
            closeDrawingBoard();
            
            // 清空画布
            clearCanvas();
        }

        // 打开画板
        function openDrawingBoard() {
            const modal = document.getElementById('drawing-board-modal');
            modal.classList.remove('hidden');
            modal.classList.add('visible');
            
            // 初始化画板
            initDrawingBoard();
        }

        // 关闭画板
        function closeDrawingBoard() {
            const modal = document.getElementById('drawing-board-modal');
            modal.classList.remove('visible');
            modal.classList.add('hidden');
        }

        // 设置画板事件监听器
        function setupDrawingBoardEvents() {
            // 画板按钮点击事件（在更多功能面板中）
            const drawingBoardBtn = document.getElementById('drawing-board-btn');
            if (drawingBoardBtn) {
                drawingBoardBtn.addEventListener('click', openDrawingBoard);
            }
            
            // 关闭按钮事件
            const closeBtn = document.getElementById('close-drawing-board');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeDrawingBoard);
            }
            
            // 撤销按钮事件
            const undoBtn = document.getElementById('undo-drawing');
            if (undoBtn) {
                undoBtn.addEventListener('click', undoDrawing);
            }
            
            // 清空画布按钮事件
            const clearBtn = document.getElementById('clear-canvas');
            if (clearBtn) {
                clearBtn.addEventListener('click', clearCanvas);
            }
            
            // 发送画作按钮事件
            const sendBtn = document.getElementById('send-drawing');
            if (sendBtn) {
                sendBtn.addEventListener('click', sendDrawing);
            }
            
            // 点击遮罩层关闭画板
            const modal = document.getElementById('drawing-board-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'drawing-board-modal') {
                        closeDrawingBoard();
                    }
                });
            }
        }

        // ====== 塔罗牌功能 ======
        // 塔罗牌数据
        const tarotCards = [
            // 大阿卡纳 (22张)
            {
                name: "愚者",
                meaning: "新的开始、冒险、纯真、自发性、自由",
                reverseMeaning: "鲁莽、不负责任、过度冒险、缺乏计划",
                image: "🃏"
            },
            {
                name: "魔术师",
                meaning: "创造力、技能、意志力、自信、机会",
                reverseMeaning: "技能不足、机会错失、缺乏自信、滥用权力",
                image: "🔮"
            },
            {
                name: "女祭司",
                meaning: "直觉、神秘、内在知识、智慧、秘密",
                reverseMeaning: "隐藏的动机、表面化、缺乏深度、过度理性",
                image: "🌙"
            },
            {
                name: "女皇",
                meaning: "丰收、母性、创造力、自然、富足",
                reverseMeaning: "过度保护、依赖、缺乏创造力、物质主义",
                image: "👑"
            },
            {
                name: "皇帝",
                meaning: "权威、领导力、控制、稳定、成就",
                reverseMeaning: "专制、控制欲、缺乏灵活性、过度控制",
                image: "⚜️"
            },
            {
                name: "教皇",
                meaning: "传统、教育、信仰、精神指导、道德",
                reverseMeaning: "教条主义、缺乏独立思考、过度依赖权威",
                image: "⛪"
            },
            {
                name: "恋人",
                meaning: "爱情、和谐、关系、选择、价值观",
                reverseMeaning: "不和谐、价值观冲突、选择困难、分离",
                image: "💕"
            },
            {
                name: "战车",
                meaning: "胜利、意志力、决心、成功、控制",
                reverseMeaning: "缺乏方向、失控、失败、意志薄弱",
                image: "🏛️"
            },
            {
                name: "力量",
                meaning: "内在力量、勇气、耐心、控制、温和",
                reverseMeaning: "缺乏自信、软弱、过度控制、缺乏耐心",
                image: "🦁"
            },
            {
                name: "隐者",
                meaning: "内省、寻找、孤独、内在指导、智慧",
                reverseMeaning: "过度孤独、缺乏指导、迷失方向、拒绝帮助",
                image: "🧭"
            },
            {
                name: "命运之轮",
                meaning: "变化、命运、转折点、机会、周期",
                reverseMeaning: "坏运气、错失机会、停滞、无法改变",
                image: "🎡"
            },
            {
                name: "正义",
                meaning: "公平、真理、诚实、因果、平衡",
                reverseMeaning: "不公、欺骗、不平衡、缺乏正义",
                image: "⚖️"
            },
            {
                name: "倒吊人",
                meaning: "牺牲、暂停、新视角、顺从、启示",
                reverseMeaning: "无意义的牺牲、停滞、缺乏进展、浪费时间",
                image: "🙃"
            },
            {
                name: "死神",
                meaning: "结束、转变、重生、释放、改变",
                reverseMeaning: "抗拒改变、停滞、无法前进、恐惧",
                image: "💀"
            },
            {
                name: "节制",
                meaning: "平衡、适度、耐心、和谐、自我控制",
                reverseMeaning: "过度、不平衡、缺乏耐心、失控",
                image: "🍷"
            },
            {
                name: "恶魔",
                meaning: "束缚、物质主义、欲望、阴影、诱惑",
                reverseMeaning: "释放、摆脱束缚、面对阴影、觉醒",
                image: "👿"
            },
            {
                name: "高塔",
                meaning: "突然变化、混乱、启示、破坏、解放",
                reverseMeaning: "避免灾难、逐渐改变、重建、稳定",
                image: "🗼"
            },
            {
                name: "星星",
                meaning: "希望、信心、目的、更新、精神意识",
                reverseMeaning: "缺乏信心、绝望、失去方向、悲观",
                image: "⭐"
            },
            {
                name: "月亮",
                meaning: "直觉、潜意识、恐惧、幻想、迷惑",
                reverseMeaning: "释放恐惧、清晰、真相、内在平静",
                image: "🌙"
            },
            {
                name: "太阳",
                meaning: "成功、喜悦、活力、真理、成功",
                reverseMeaning: "暂时困难、过度自信、表面成功、内在空虚",
                image: "☀️"
            },
            {
                name: "审判",
                meaning: "重生、内在呼唤、释放、救赎、觉醒",
                reverseMeaning: "自我怀疑、拒绝改变、缺乏觉醒、停滞",
                image: "📯"
            },
            {
                name: "世界",
                meaning: "完成、整合、成就、旅行、和谐",
                reverseMeaning: "未完成、缺乏整合、延迟、不和谐",
                image: "🌍"
            },
            
            // 小阿卡纳 - 权杖系列 (14张)
            {
                name: "权杖王牌",
                meaning: "新的开始、灵感、创造力、机会、潜力",
                reverseMeaning: "错失机会、缺乏灵感、延迟、未实现的潜力",
                image: "🔥"
            },
            {
                name: "权杖二",
                meaning: "选择、平衡、合作、伙伴关系、决策",
                reverseMeaning: "优柔寡断、不平衡、缺乏合作、错误选择",
                image: "⚖️"
            },
            {
                name: "权杖三",
                meaning: "团队合作、扩展、成长、合作、计划",
                reverseMeaning: "缺乏合作、计划失败、过度扩张、团队冲突",
                image: "🤝"
            },
            {
                name: "权杖四",
                meaning: "庆祝、和谐、家庭、稳定、成功",
                reverseMeaning: "缺乏庆祝、家庭冲突、不稳定、成功延迟",
                image: "🎉"
            },
            {
                name: "权杖五",
                meaning: "冲突、竞争、挑战、成长、学习",
                reverseMeaning: "避免冲突、缺乏竞争、逃避挑战、停滞不前",
                image: "⚔️"
            },
            {
                name: "权杖六",
                meaning: "胜利、成功、好消息、认可、进步",
                reverseMeaning: "延迟成功、缺乏认可、坏消息、停滞",
                image: "🏆"
            },
            {
                name: "权杖七",
                meaning: "防御、坚持、挑战、保护、决心",
                reverseMeaning: "过度防御、缺乏坚持、放弃、脆弱",
                image: "🛡️"
            },
            {
                name: "权杖八",
                meaning: "快速行动、变化、消息、旅行、进展",
                reverseMeaning: "延迟、停滞、坏消息、旅行取消、缺乏进展",
                image: "🚀"
            },
            {
                name: "权杖九",
                meaning: "准备、防御、经验、智慧、警惕",
                reverseMeaning: "缺乏准备、过度防御、缺乏经验、粗心",
                image: "🎯"
            },
            {
                name: "权杖十",
                meaning: "负担、责任、压力、努力、成就",
                reverseMeaning: "减轻负担、缺乏责任、逃避压力、懒惰",
                image: "💼"
            },
            {
                name: "权杖侍从",
                meaning: "新消息、学习、探索、热情、冒险",
                reverseMeaning: "坏消息、缺乏学习、缺乏热情、过度谨慎",
                image: "📚"
            },
            {
                name: "权杖骑士",
                meaning: "行动、冒险、热情、冲动、变化",
                reverseMeaning: "延迟、缺乏行动、缺乏热情、过度谨慎",
                image: "🐎"
            },
            {
                name: "权杖皇后",
                meaning: "独立、热情、创造力、自信、魅力",
                reverseMeaning: "依赖、缺乏热情、缺乏创造力、缺乏自信",
                image: "👸"
            },
            {
                name: "权杖国王",
                meaning: "领导力、热情、创造力、自信、成功",
                reverseMeaning: "缺乏领导力、缺乏热情、缺乏创造力、失败",
                image: "👑"
            },
            
            // 小阿卡纳 - 圣杯系列 (14张)
            {
                name: "圣杯王牌",
                meaning: "新的情感、爱、直觉、创造力、灵感",
                reverseMeaning: "情感封闭、缺乏爱、缺乏直觉、缺乏灵感",
                image: "💧"
            },
            {
                name: "圣杯二",
                meaning: "伙伴关系、爱情、和谐、选择、平衡",
                reverseMeaning: "分离、不和谐、缺乏选择、不平衡",
                image: "💕"
            },
            {
                name: "圣杯三",
                meaning: "庆祝、友谊、欢乐、合作、成功",
                reverseMeaning: "缺乏庆祝、孤独、悲伤、缺乏合作",
                image: "🎊"
            },
            {
                name: "圣杯五",
                meaning: "失望、悲伤、损失、遗憾、悲观",
                reverseMeaning: "希望、恢复、新机会、乐观、接受",
                image: "😔"
            },
            {
                name: "圣杯六",
                meaning: "怀旧、回忆、重逢、和谐、童年",
                reverseMeaning: "缺乏怀旧、分离、不和谐、成长",
                image: "🏠"
            },
            {
                name: "圣杯七",
                meaning: "选择、幻想、诱惑、困惑、决策",
                reverseMeaning: "清晰、现实、避免诱惑、明确选择",
                image: "🌈"
            },
            {
                name: "圣杯八",
                meaning: "离开、寻找、改变、进步、新开始",
                reverseMeaning: "停滞、缺乏改变、缺乏进步、恐惧",
                image: "🚶"
            },
            {
                name: "圣杯九",
                meaning: "满足、愿望实现、成功、幸福、富足",
                reverseMeaning: "不满足、愿望未实现、失败、缺乏",
                image: "🎁"
            },
            {
                name: "圣杯十",
                meaning: "家庭和谐、幸福、圆满、爱、满足",
                reverseMeaning: "家庭冲突、不幸福、不圆满、缺乏爱",
                image: "🏡"
            },
            {
                name: "圣杯侍从",
                meaning: "新消息、学习、创造力、灵感、机会",
                reverseMeaning: "坏消息、缺乏学习、缺乏创造力、错失机会",
                image: "📖"
            },
            {
                name: "圣杯骑士",
                meaning: "浪漫、提议、邀请、创意、魅力",
                reverseMeaning: "缺乏浪漫、拒绝、缺乏创意、缺乏魅力",
                image: "🌹"
            },
            {
                name: "圣杯皇后",
                meaning: "爱、关怀、直觉、创造力、同情心",
                reverseMeaning: "缺乏爱、缺乏关怀、缺乏直觉、冷漠",
                image: "👸"
            },
            {
                name: "圣杯国王",
                meaning: "情感成熟、智慧、同情心、创造力、领导力",
                reverseMeaning: "情感不成熟、缺乏智慧、缺乏同情心",
                image: "👑"
            },
            
            // 小阿卡纳 - 宝剑系列 (14张)
            {
                name: "宝剑王牌",
                meaning: "新的想法、清晰、真理、突破、力量",
                reverseMeaning: "混乱、缺乏清晰、缺乏真理、缺乏力量",
                image: "⚔️"
            },
            {
                name: "宝剑二",
                meaning: "平衡、选择、和谐、决策、和平",
                reverseMeaning: "不平衡、缺乏选择、不和谐、冲突",
                image: "⚖️"
            },
            {
                name: "宝剑三",
                meaning: "心痛、悲伤、分离、背叛、痛苦",
                reverseMeaning: "恢复、和解、团聚、信任、治愈",
                image: "💔"
            },
            {
                name: "宝剑四",
                meaning: "休息、恢复、冥想、和平、内省",
                reverseMeaning: "缺乏休息、过度劳累、缺乏和平、焦虑",
                image: "😴"
            },
            {
                name: "宝剑五",
                meaning: "失败、损失、冲突、挫折、竞争",
                reverseMeaning: "成功、胜利、和解、合作、避免冲突",
                image: "🏃"
            },
            {
                name: "宝剑六",
                meaning: "过渡、改变、进步、离开、新开始",
                reverseMeaning: "停滞、缺乏改变、缺乏进步、恐惧",
                image: "🚢"
            },
            {
                name: "宝剑七",
                meaning: "欺骗、秘密、策略、隐藏动机、逃避",
                reverseMeaning: "诚实、真相、直接、面对问题、勇气",
                image: "🕵️"
            },
            {
                name: "宝剑八",
                meaning: "困境、限制、无助、恐惧、束缚",
                reverseMeaning: "解脱、自由、希望、勇气、突破",
                image: "🔒"
            },
            {
                name: "宝剑九",
                meaning: "焦虑、恐惧、担忧、噩梦、压力",
                reverseMeaning: "平静、希望、信心、放松、解脱",
                image: "😰"
            },
            {
                name: "宝剑十",
                meaning: "结束、失败、痛苦、背叛、绝望",
                reverseMeaning: "新开始、希望、恢复、重生、机会",
                image: "💀"
            },
            {
                name: "宝剑侍从",
                meaning: "新想法、学习、消息、好奇心、观察",
                reverseMeaning: "缺乏想法、缺乏学习、坏消息、缺乏好奇心",
                image: "📝"
            },
            {
                name: "宝剑骑士",
                meaning: "行动、冲突、勇气、冲动、变化",
                reverseMeaning: "延迟、避免冲突、缺乏勇气、过度谨慎",
                image: "⚔️"
            },
            {
                name: "宝剑皇后",
                meaning: "智慧、独立、清晰、真理、力量",
                reverseMeaning: "缺乏智慧、依赖、混乱、谎言、软弱",
                image: "👸"
            },
            {
                name: "宝剑国王",
                meaning: "权威、智慧、真理、正义、领导力",
                reverseMeaning: "缺乏权威、缺乏智慧、不公、缺乏领导力",
                image: "👑"
            },
            
            // 小阿卡纳 - 金币系列 (14张)
            {
                name: "金币王牌",
                meaning: "新的机会、财富、物质成功、繁荣、潜力",
                reverseMeaning: "错失机会、缺乏财富、物质失败、缺乏潜力",
                image: "💰"
            },
            {
                name: "金币二",
                meaning: "平衡、适应、灵活性、变化、学习",
                reverseMeaning: "不平衡、缺乏适应、缺乏灵活性、停滞",
                image: "🎭"
            },
            {
                name: "金币三",
                meaning: "技能、学习、成长、合作、进步",
                reverseMeaning: "缺乏技能、缺乏学习、缺乏成长、缺乏合作",
                image: "🔨"
            },
            {
                name: "金币四",
                meaning: "安全、稳定、保守、保护、财富",
                reverseMeaning: "不安全、不稳定、冒险、损失、缺乏保护",
                image: "🏰"
            },
            {
                name: "金币五",
                meaning: "困难、贫困、疾病、孤独、挑战",
                reverseMeaning: "改善、健康、陪伴、克服困难、希望",
                image: "🏥"
            },
            {
                name: "金币六",
                meaning: "慷慨、给予、帮助、慈善、成功",
                reverseMeaning: "自私、缺乏给予、缺乏帮助、失败",
                image: "🎁"
            },
            {
                name: "金币七",
                meaning: "耐心、投资、长期规划、成长、等待",
                reverseMeaning: "缺乏耐心、短期思维、缺乏规划、停滞",
                image: "🌱"
            },
            {
                name: "金币八",
                meaning: "技能发展、学习、进步、专注、成长",
                reverseMeaning: "缺乏技能、缺乏学习、缺乏进步、分心",
                image: "⚒️"
            },
            {
                name: "金币九",
                meaning: "独立、自给自足、成功、享受、富足",
                reverseMeaning: "依赖、缺乏自给自足、失败、缺乏享受",
                image: "🏡"
            },
            {
                name: "金币十",
                meaning: "家庭财富、传承、传统、成功、圆满",
                reverseMeaning: "家庭困难、缺乏传承、缺乏传统、失败",
                image: "🏠"
            },
            {
                name: "金币侍从",
                meaning: "新机会、学习、消息、好奇心、潜力",
                reverseMeaning: "错失机会、缺乏学习、坏消息、缺乏潜力",
                image: "📚"
            },
            {
                name: "金币骑士",
                meaning: "实用、可靠、耐心、勤奋、进步",
                reverseMeaning: "不实用、不可靠、缺乏耐心、懒惰",
                image: "🐎"
            },
            {
                name: "金币皇后",
                meaning: "富足、实用、关怀、繁荣、成功",
                reverseMeaning: "缺乏、不实用、缺乏关怀、失败",
                image: "👸"
            },
            {
                name: "金币国王",
                meaning: "成功、财富、权威、实用、领导力",
                reverseMeaning: "失败、缺乏财富、缺乏权威、缺乏领导力",
                image: "👑"
            }
        ];

        let currentCard = null;
        let isCardFlipped = false;

        // 初始化塔罗牌功能
        function setupTarotCard() {
            // 塔罗牌按钮点击事件
            const tarotBtn = document.getElementById('tarot-card-btn');
            if (tarotBtn) {
                tarotBtn.addEventListener('click', openTarotModal);
            }

            // 关闭按钮事件
            const closeBtn = document.getElementById('close-tarot-modal');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeTarotModal);
            }

            // 抽牌按钮事件
            const drawBtn = document.getElementById('draw-card-btn');
            if (drawBtn) {
                drawBtn.addEventListener('click', drawTarotCard);
            }

                    // 发送塔罗牌按钮事件
        const sendBtn = document.getElementById('send-tarot-btn');
        if (sendBtn) {
            sendBtn.addEventListener('click', sendTarotCard);
        }



            // 点击遮罩层关闭塔罗牌
            const modal = document.getElementById('tarot-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target.id === 'tarot-modal') {
                        closeTarotModal();
                    }
                });
            }
        }

        // 打开塔罗牌弹窗
        function openTarotModal() {
            const modal = document.getElementById('tarot-modal');
            modal.classList.remove('hidden');
            modal.classList.add('visible');
            
            // 重置状态
            resetTarotCard();
        }

        // 关闭塔罗牌弹窗
        function closeTarotModal() {
            const modal = document.getElementById('tarot-modal');
            modal.classList.remove('visible');
            modal.classList.add('hidden');
        }

        // 重置塔罗牌状态
        function resetTarotCard() {
            currentCard = null;
            isCardFlipped = false;
            
            const cardDisplay = document.getElementById('tarot-card');
            const info = document.getElementById('tarot-info');
            const sendBtn = document.getElementById('send-tarot-btn');
            const drawBtn = document.getElementById('draw-card-btn');
            
            cardDisplay.className = 'tarot-card-back';
            cardDisplay.innerHTML = `
                <div class="card-back-pattern"></div>
                <div class="card-back-text">点击抽牌</div>
            `;
            
            info.style.display = 'none';
            sendBtn.style.display = 'none';
            drawBtn.style.display = 'block'; // 重新显示抽牌按钮
        }

        // 抽取塔罗牌
        function drawTarotCard() {
            if (isCardFlipped) return;
            
            // 随机选择一张牌
            const randomIndex = Math.floor(Math.random() * tarotCards.length);
            currentCard = tarotCards[randomIndex];
            
            // 随机决定正逆位
            const isReversed = Math.random() > 0.5;
            
            // 翻转卡片
            flipCard(currentCard, isReversed);
        }

        // 翻转卡片
        function flipCard(card, isReversed) {
            const cardDisplay = document.getElementById('tarot-card');
            const info = document.getElementById('tarot-info');
            const sendBtn = document.getElementById('send-tarot-btn');
            const drawBtn = document.getElementById('draw-card-btn');
            
            // 创建卡片正面
            cardDisplay.className = 'tarot-card-front';
            cardDisplay.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 20px; text-align: center;">
                    <div style="font-size: 60px; margin-bottom: 20px;">${card.image}</div>
                    <div style="font-size: 24px; font-weight: bold; color: #333; margin-bottom: 10px;">${card.name}</div>
                    <div style="font-size: 14px; color: #666; transform: ${isReversed ? 'rotate(180deg)' : 'none'};">
                        ${isReversed ? '逆位' : '正位'}
                    </div>
                </div>
            `;
            
            // 显示卡片信息
            const cardName = document.getElementById('card-name');
            const cardMeaning = document.getElementById('card-meaning');
            const orientationText = document.getElementById('orientation-text');
            
            cardName.textContent = card.name;
            cardMeaning.textContent = isReversed ? card.reverseMeaning : card.meaning;
            orientationText.textContent = isReversed ? '逆位' : '正位';
            
            info.style.display = 'block';
            sendBtn.style.display = 'block';
            drawBtn.style.display = 'none'; // 隐藏抽牌按钮
            
            isCardFlipped = true;
            
            // 添加翻转动画
            setTimeout(() => {
                cardDisplay.classList.add('flipped');
            }, 100);
        }

        // 发送塔罗牌
        function sendTarotCard() {
            if (!currentCard || !isCardFlipped) return;
            
            // 构建塔罗牌消息
            const isReversed = document.getElementById('orientation-text').textContent === '逆位';
            const cardMessage = `🔮 塔罗牌占卜结果：
            
🎴 抽到了：${currentCard.name}
${isReversed ? '🔄 逆位' : '✅ 正位'}
📖 含义：${isReversed ? currentCard.reverseMeaning : currentCard.meaning}

✨ 愿这张牌为你带来指引和启示！`;
            
            // 发送消息
            const timestamp = Date.now();
            const tarotMsg = { 
                content: cardMessage, 
                sender: 'user', 
                type: 'text', 
                timestamp: timestamp,
                ...(currentReplyToTimestamp && { replyTo: currentReplyToTimestamp })
            };
            
            // 保存到历史记录
            if (!chatHistories[currentChatCharacterId]) {
                chatHistories[currentChatCharacterId] = { history: [], pinned: false };
            }
            chatHistories[currentChatCharacterId].history.push(tarotMsg);
            saveData('chatHistories', chatHistories);
            
            // 渲染消息
            appendMessage(tarotMsg, true);
            
            // 取消回复模式
            if (currentReplyToTimestamp) {
                cancelReplyMode();
            }
            
                    // 关闭弹窗
        closeTarotModal();
    }

    // ====== 钱包功能 ======
    
    // 初始化钱包功能
    function setupWallet() {
        // 钱包按钮点击事件
        const walletBtn = document.getElementById('wallet-btn');
        if (walletBtn) {
            walletBtn.addEventListener('click', openWalletModal);
        }

        // 关闭按钮事件
        const closeBtn = document.getElementById('close-wallet-modal');
        if (closeBtn) {
            closeBtn.addEventListener('click', closeWalletModal);
        }

        // 点击遮罩层关闭钱包
        const modal = document.getElementById('wallet-modal');
        if (modal) {
            modal.addEventListener('click', (e) => {
                if (e.target.id === 'wallet-modal') {
                    closeWalletModal();
                }
            });
        }
    }

    // 打开钱包弹窗
    function openWalletModal() {
        const modal = document.getElementById('wallet-modal');
        modal.classList.remove('hidden');
        modal.classList.add('visible');
        
        // 刷新钱包数据
        refreshWalletData();
    }

    // 关闭钱包弹窗
    function closeWalletModal() {
        const modal = document.getElementById('wallet-modal');
        modal.classList.remove('visible');
        modal.classList.add('hidden');
    }

    // 刷新钱包数据
    function refreshWalletData() {
        const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
        const characters = loadData('characters', []);
        const currentBalance = getWalletBalance();
        
        let totalIncome = 0;
        let redpacketTotal = 0;
        let transferTotal = 0;
        const records = [];

        // 统计所有收入
        Object.entries(claimedPayments).forEach(([id, payment]) => {
            const amount = parseFloat(payment.amount) || 0;
            totalIncome += amount;
            
            if (payment.type === 'red-packet') {
                redpacketTotal += amount;
            } else if (payment.type === 'transfer') {
                transferTotal += amount;
            }
            
            // 获取角色信息
            const character = characters.find(c => c.id === payment.characterId) || { name: '未知角色' };
            
            records.push({
                ...payment,
                id: id,
                characterName: character.name,
                formattedTime: formatWalletTime(payment.timestamp)
            });
        });

        // 按时间倒序排列
        records.sort((a, b) => b.timestamp - a.timestamp);

        // 更新界面
        updateWalletDisplay(currentBalance, totalIncome, redpacketTotal, transferTotal, records);
    }

    // 更新钱包显示
    function updateWalletDisplay(currentBalance, totalIncome, redpacketTotal, transferTotal, records) {
        // 更新余额和收入统计
        document.getElementById('current-balance').textContent = currentBalance.toFixed(2);
        document.getElementById('total-income').textContent = totalIncome.toFixed(2);
        document.getElementById('redpacket-total').textContent = redpacketTotal.toFixed(2);
        document.getElementById('transfer-total').textContent = transferTotal.toFixed(2);

        // 更新收入记录
        const recordsList = document.getElementById('wallet-records-list');
        if (records.length === 0) {
            recordsList.innerHTML = `
                <div class="empty-records">
                    <i class="ri-wallet-3-line"></i>
                    <p>暂无收入记录</p>
                    <p>快去收取红包和转账吧！</p>
                </div>
            `;
        } else {
            recordsList.innerHTML = records.map(record => `
                <div class="record-item">
                    <div class="record-left">
                        <div class="record-icon ${record.type === 'red-packet' ? 'red-packet' : 'transfer'}">
                            <i class="${record.type === 'red-packet' ? 'ri-red-packet-fill' : 'ri-exchange-dollar-fill'}"></i>
                        </div>
                        <div class="record-info">
                            <div class="record-type">${record.type === 'red-packet' ? '红包收入' : '转账收入'}</div>
                            <div class="record-character">来自 ${record.characterName}</div>
                            <div class="record-time">${record.formattedTime}</div>
                        </div>
                    </div>
                    <div class="record-amount">+¥${parseFloat(record.amount).toFixed(2)}</div>
                </div>
            `).join('');
        }
    }

    // 格式化钱包时间显示
    function formatWalletTime(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diff = now - date;
        
        if (diff < 60000) { // 1分钟内
            return '刚刚';
        } else if (diff < 3600000) { // 1小时内
            return `${Math.floor(diff / 60000)}分钟前`;
        } else if (diff < 86400000) { // 24小时内
            return `${Math.floor(diff / 3600000)}小时前`;
        } else if (diff < 2592000000) { // 30天内
            return `${Math.floor(diff / 86400000)}天前`;
        } else {
            return date.toLocaleDateString();
        }
    }

    // 钱包余额管理系统
    function getWalletBalance() {
        const stored = localStorage.getItem('walletBalance');
        if (stored === null) {
            // 首次使用，设置初始余额
            localStorage.setItem('walletBalance', '1000');
            return 1000;
        }
        return parseFloat(stored);
    }

    function setWalletBalance(amount) {
        localStorage.setItem('walletBalance', amount.toString());
        if (window.updateWalletAfterClaim) {
            window.updateWalletAfterClaim();
        }
    }

    function addToWallet(amount) {
        const currentBalance = getWalletBalance();
        const numericAmount = parseFloat(amount);  // 确保金额是数字类型
        setWalletBalance(currentBalance + numericAmount);
    }

    function deductFromWallet(amount) {
        const currentBalance = getWalletBalance();
        const numericAmount = parseFloat(amount);  // 确保金额是数字类型
        const newBalance = Math.max(0, currentBalance - numericAmount);
        setWalletBalance(newBalance);
        return newBalance;
    }

    function hasEnoughBalance(amount) {
        const numericAmount = parseFloat(amount);  // 确保金额是数字类型
        return getWalletBalance() >= numericAmount;
    }

    // 重置钱包余额到正确数值（修复版）
    function resetWalletBalance() {
        // 计算实际应有的余额：总收入 - 总支出
        const claimedPayments = JSON.parse(localStorage.getItem('claimedPayments') || '{}');
        const giftPurchases = JSON.parse(localStorage.getItem('giftPurchases') || '[]');
        
        // 计算总收入（包括初始余额和所有收到的款项）
        let totalIncome = 1000; // 初始余额
        Object.entries(claimedPayments).forEach(([id, payment]) => {
            const amount = parseFloat(payment.amount) || 0;
            totalIncome += amount;
        });
        
        // 计算总支出（只计算商城购买，不计算红包和转账）
        let totalExpenses = 0;
        giftPurchases.forEach(purchase => {
            const amount = parseFloat(purchase.price) || 0;
            totalExpenses += amount;
        });
        
        // 注意：红包和转账在这个应用中是虚拟的社交功能，不应该真的扣除用户余额
        // 因为用户发出的红包和转账并没有对应的真实收款方
        // 所以我们需要把之前错误扣除的红包和转账金额加回来
        
        // 计算所有聊天记录中发出的红包和转账总额
        let redPacketAndTransferTotal = 0;
        if (chatHistories) {
            Object.values(chatHistories).forEach(chat => {
                if (chat.history) {
                    chat.history.forEach(msg => {
                        if ((msg.type === 'red-packet' || msg.type === 'transfer') && msg.sender === 'user') {
                            const amount = parseFloat(msg.content.amount) || 0;
                            redPacketAndTransferTotal += amount;
                        }
                    });
                }
            });
        }
        
        // 正确的余额 = 初始余额 + 收入 - 商城支出（红包转账不应该扣钱）
        const correctBalance = totalIncome - totalExpenses;
        const currentBalance = getWalletBalance();
        
        // 如果当前余额与计算出的正确余额不符，则修正
        if (Math.abs(currentBalance - correctBalance) > 0.01) {
            localStorage.setItem('walletBalance', correctBalance.toString());
            if (window.updateWalletAfterClaim) {
                window.updateWalletAfterClaim();
            }
            console.log(`钱包余额已修正：从¥${currentBalance.toFixed(2)}修正为¥${correctBalance.toFixed(2)}`);
            console.log(`总收入：¥${totalIncome.toFixed(2)}，商城支出：¥${totalExpenses.toFixed(2)}`);
            console.log(`红包转账总额：¥${redPacketAndTransferTotal.toFixed(2)}（已恢复，因为这是虚拟社交功能）`);
        }
    }

    // 生成稳定的支付ID（基于内容和时间戳，不使用随机数）
    function generateStablePaymentId(type, characterId, amount, timestamp) {
        // 使用内容的哈希值作为稳定标识符
        const content = `${type}_${characterId}_${amount}_${timestamp}`;
        let hash = 0;
        for (let i = 0; i < content.length; i++) {
            const char = content.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 转换为32位整数
        }
        return `${type}_${Math.abs(hash)}`;
    }

    // 获取角色列表
    function getCharacters() {
        return [
            { id: 'character1', name: '小雪' },
            { id: 'character2', name: '小月' },
            { id: 'character3', name: '小花' },
            { id: 'character4', name: '小雨' },
            { id: 'character5', name: '小梦' },
            { id: 'character6', name: '小云' },
            { id: 'character7', name: '小星' },
            { id: 'character8', name: '小晴' },
            { id: 'character9', name: '小语' },
            { id: 'character10', name: '小诗' },
            { id: 'character11', name: '小音' },
            { id: 'character12', name: '小舞' }
        ];
    }

    // 外部调用的钱包更新函数
    window.updateWalletAfterClaim = function() {
        // 如果钱包弹窗是打开的，立即刷新数据
        const modal = document.getElementById('wallet-modal');
        if (modal && modal.classList.contains('visible')) {
            refreshWalletData();
        }
    };

    // ================== 【【最终版】】礼物商城核心逻辑 ==================

    // 打开商城
    function openGiftShop() {
        renderGiftShop();
        $('#gift-shop-modal').classList.add('visible');
    }

    // 渲染商城里的所有礼物
    function renderGiftShop() {
        const container = $('#gift-grid-container');
        container.innerHTML = ''; // 清空
        giftShopItems.forEach(item => {
            const giftCard = document.createElement('div');
            giftCard.className = 'gift-item';
            giftCard.innerHTML = `
                <div class="gift-icon"><i class="${item.icon}"></i></div>
                <div class="gift-name">${item.name}</div>
                <div class="gift-price">¥${item.price.toFixed(2)}</div>
                <div class="gift-description">${item.description}</div>
            `;
            giftCard.addEventListener('click', () => showGiftConfirmation(item.id));
            container.appendChild(giftCard);
        });
    }

    // 显示购买确认弹窗
    function showGiftConfirmation(itemId) {
        const item = giftShopItems.find(g => g.id === itemId);
        if (!item) return;

        const detailsContainer = $('#gift-confirm-details');
        const balance = getWalletBalance();
        detailsContainer.innerHTML = `
            <div class="text-4xl mb-2"><i class="${item.icon}"></i></div>
            <p class="font-semibold text-lg">${item.name}</p>
            <p class="text-yellow-400 mb-2">价格: ¥${item.price.toFixed(2)}</p>
            <p class="text-sm text-gray-400">您的余额: ¥${balance.toFixed(2)}</p>
        `;
        $('#gift-message-input').value = '';

        const confirmBtn = $('#confirm-buy-gift-btn');
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.onclick = () => buyGift(itemId);

        $('#gift-confirm-modal').classList.add('visible');
    }

    // ====== 【新增】特殊礼物逻辑处理函数 ======

    // 全局变量，用于追踪"真言之镜"的状态
    let mirrorOfTruthState = {
        isActive: false,
        characterId: null,
        turnsLeft: 0
    };

    /**
     * 触发"秘密耳语"的专属逻辑
     */
    async function triggerSecretWhisper(characterId) {
        const character = characters.find(c => c.id === characterId);
        if (!character) return;

        // 1. 构建一个让AI生成秘密的指令
        const secretGenPrompt = `
# 任务：生成一个角色的秘密
作为角色 ${character.name}，你的设定是：${character.persona}。
请根据你的设定，生成一个你内心深处"关于我（用户）但从未说出口"的秘密。
这个秘密可以是一个担忧、一个愿望、或者一个不为人知的观察。
**直接输出这句秘密，不要任何多余的文字。**
`;
        const secretContent = await callAI(secretGenPrompt, "请生成你的秘密。");

        // 2. 将这个秘密作为一条"只有用户能看见"的系统消息显示出来
        if (secretContent) {
            const whisperMsgContent = `[秘密耳语 whispering]：${secretContent}`;
            // 使用'system-internal'类型，这样AI在下次回复时不会"看到"这条消息，保证信息差
            const whisperMsg = { content: whisperMsgContent, sender: 'system', type: 'system-internal', timestamp: Date.now() };
            
            // 这条消息只显示在界面上，不存入常规历史，防止AI看到
            appendMessage({ ...whisperMsg, type: 'system' }, false); // 用'system'类型来渲染样式
        }
    }

    /**
     * 激活"真言之镜"的状态
     */
    function activateMirrorOfTruth(characterId) {
        mirrorOfTruthState = {
            isActive: true,
            characterId: characterId,
            turnsLeft: 3 // 效果持续3轮AI回复
        };
        showMessageBox("真言之镜已激活，注意观察TA接下来的回复...");
    }

    /**
     * 在AI回复后，检查是否需要揭示"真心话"
     */
    async function revealTrueThought(character, aiMessage) {
        if (!mirrorOfTruthState.isActive || mirrorOfTruthState.characterId !== character.id || mirrorOfTruthState.turnsLeft <= 0) {
            return;
        }

        // 1. 构建一个让AI"反思"的指令
        const reflectionPrompt = `
# 任务：揭示内心真实想法
你的角色设定是：${character.persona}。
你刚刚对用户说了这句话："${aiMessage}"。
现在请站在你自己的角度，用一句话诚实地回答：你刚才那句话背后，有没有隐藏什么没有完全表达出来的、更真实或更复杂的内心想法？
**直接输出那句"内心真实想法"的OS，用括号括起来，例如：(其实我好紧张)。如果完全没有，就输出"(没有隐藏)"**
`;
        const trueThought = await callAI(reflectionPrompt, "请揭示你的真实想法。");

        // 2. 将"真心话"作为追击消息显示出来
        if (trueThought && !trueThought.includes("没有隐藏")) {
            const truthMsgContent = `[真言之镜]：${trueThought}`;
            const truthMsg = { content: truthMsgContent, sender: 'system', type: 'system', timestamp: Date.now() + 1 };
            
            setTimeout(() => { // 延迟显示，更有戏剧效果
                appendMessage(truthMsg, false);
                // 这条消息也不存入历史，防止干扰
            }, 800);
        }
        
        mirrorOfTruthState.turnsLeft--;
        if (mirrorOfTruthState.turnsLeft <= 0) {
            mirrorOfTruthState.isActive = false;
            setTimeout(() => showMessageBox("真言之镜的效果消失了。"), 1000);
        }
    }

    // 在处理并显示AI消息的函数中，我们需要找到合适的位置来调用 revealTrueThought
    // 这个需要修改 processAndDisplayAIMessages 函数

    // ====== 【新增】"欲望的禁语"专属逻辑处理函数 ======
    function triggerForbiddenWordGame(characterId) {
        const forbiddenWord = prompt("请输入你想让TA禁用的词语（例如：爱、触摸、需要）：");

        if (forbiddenWord && forbiddenWord.trim()) {
            const character = characters.find(c => c.id === characterId);
            const word = forbiddenWord.trim();
            
            // 1. 创建给用户看的【系统提示】
            const userVisibleMsgContent = `[你对${character.name}使用了"欲望的禁语"，禁用的词是："${word}"。]`;
            const userVisibleMsg = { content: userVisibleMsgContent, sender: 'system', type: 'system', timestamp: Date.now() + 1 };
            
            // 2. 创建给AI看的、包含详细指令的【内部记忆】
            const aiInstruction = `[游戏指令：现在开始"欲望的禁语"游戏。在接下来的10分钟内，你绝对不能说出"${word}"这个词。同时，你内心充满了必须表达出"${word}"这个词含义的强烈欲望。你的任务是用旁敲侧击、比喻和动作描写来传达这个意思。请开始你的第一句回应。]`;
            const internalMemoryMsg = { content: aiInstruction, sender: 'system', type: 'system-internal', priority: 'medium', timestamp: Date.now() + 2 };

            // 3. 保存两条消息并更新UI
            if (!chatHistories[characterId]) chatHistories[characterId] = { history: [], pinned: false };
            chatHistories[characterId].history.push(userVisibleMsg, internalMemoryMsg);
            saveData('chatHistories', chatHistories);
            appendMessage(userVisibleMsg, false); // 只在界面上显示给用户看的消息

            // 4. 触发AI反应
            setTimeout(() => handleReceiveMessage(), 500);
            
        } else {
            showMessageBox("取消了\"欲望的禁语\"。");
        }
    }

    // ====== 【【升级版】】通用剧情礼物触发函数 ======
    // ====== 【V4 - HTML模板填充最终版】通用剧情礼物触发函数 ======
    async function triggerAIGiftReaction(characterId, giftItem) {
        const character = characters.find(c => c.id === characterId);
        if (!character || !giftItem.ai_reaction_prompt) return;

        // --- 第一步：AI的"初始反应"(多样化版本) ---
        const reactionPrompt = `
# 指令身份
你将扮演我的soulmate，你的名字是 ${character.name}。
# 任务场景
我刚刚送给了你一个名为"${giftItem.name}"的特殊礼物。
# 核心任务
你的唯一任务是，对此刻"收到"这个礼物的行为，做出一个非常简短、自然、口语化的**初始反应**。
# 输出要求
- 反应要简短，通常只有一两个词或一句话
- 可以是惊喜、好奇、感动、开心等各种情绪
- 要符合你的人设特点，避免千篇一律的表达
- 直接输出对话内容，不要有任何其他解释
`;
        const initialReaction = await callAI(reactionPrompt, "请做出你的第一反应。");
        if (initialReaction) {
            const reactionMsg = { content: initialReaction, sender: 'ai', type: 'text', timestamp: Date.now() };
            appendMessage(reactionMsg, true);
            chatHistories[characterId].history.push(reactionMsg);
            saveData('chatHistories', chatHistories);
        }

        // --- 第二步：AI的"内容创作"(保持不变) ---
        const thinkingMsgContent = `*${character.name} 似乎正在仔细端详这个礼物，陷入了回忆...*`;
        const thinkingMsg = { content: thinkingMsgContent, sender: 'system', type: 'system', timestamp: Date.now() + 1 };
        appendMessage(thinkingMsg, false);
        chatHistories[characterId].history.push(thinkingMsg);
        saveData('chatHistories', chatHistories);

        const context = gatherAIContext(characterId);
        const creationPrompt = `
# 指令身份
你将扮演我的soulmate，你的名字是 ${character.name}。
# 任务场景
一个魔法般的事件刚刚发生。用户使用了特殊物品："${giftItem.name}"，它的效果正在通过你展现出来。
# 核心任务：【绝对执行，不容置疑】
作为这个魔法事件的直接结果，你必须、且只能、创作并输出以下为你量身定制的专属剧本内容。
**这不是一次对话，这是你在创造魔法本身的结果。**

**【你的专属剧本】**: "${giftItem.ai_reaction_prompt}"

# 输出格式天条 (ABSOLUTELY CRITICAL)
- 你的回复【必须是】剧本创作的**纯文本内容本身**，【不能包含】任何其他文字。
- 【【绝对禁止】】：任何形式的对话、确认、解释或旁白。如果剧本要求你描述一个梦，你的整个回复就只是梦境的描述。

# 输入信息 (你的记忆)
---
[你的设定]: ${character.persona}
[与我的关系]: ${context.character.myPersona}
[最近的聊天回顾]:
${context.chatHistory.map(m => `${m.sender === 'user' ? '对方' : '我'}: ${m.content}`).join('\n')}
[我们的约定]:
${context.planContext}
---
`;
        const creationContent = await callAI(creationPrompt, `请严格遵照指令，立刻开始创作，直接输出最终成品。`);

        // --- 第三步：【【核心升级】】模板填充与发送 ---
        if (creationContent) {
            // 先移除"创作中"的提示
            const thinkingMessageElement = document.querySelector(`[data-timestamp="${thinkingMsg.timestamp}"]`);
            if (thinkingMessageElement) {
                thinkingMessageElement.remove();
                chatHistories[characterId].history = chatHistories[characterId].history.filter(m => m.timestamp !== thinkingMsg.timestamp);
            }
            
            let finalContent = creationContent;
            let messageType = 'text';

            // 查找这个礼物是否有专属HTML模板
            if (gift_html_templates[giftItem.id]) {
                // 如果有，就进行填充
                const template = gift_html_templates[giftItem.id];
                // 将AI生成的纯文本内容，替换掉模板里的 {{content}} 占位符
                finalContent = template.replace('{{content}}', creationContent);
                messageType = 'html'; // 消息类型变为html
            }
            
            // 发送最终处理过的内容（可能是HTML，也可能是纯文本）
            const finalMsg = { content: finalContent, sender: 'ai', type: messageType, timestamp: Date.now() + 2 };
            appendMessage(finalMsg, true);
            chatHistories[characterId].history.push(finalMsg);
            saveData('chatHistories', chatHistories);
        } else {
            // 如果AI没有返回内容，也要移除"创作中"的提示
            const thinkingMessageElement = document.querySelector(`[data-timestamp="${thinkingMsg.timestamp}"]`);
            if (thinkingMessageElement) {
                thinkingMessageElement.remove();
                chatHistories[characterId].history = chatHistories[characterId].history.filter(m => m.timestamp !== thinkingMsg.timestamp);
                saveData('chatHistories', chatHistories);
            }
        }
    }

    // ====== 【新增】"万能解药"专属逻辑函数 ======
    function useAntidote(characterId) {
        const character = characters.find(c => c.id === characterId);
        if (!character) return;

        let effectsRemoved = false;

        // 1. 重置"真言之镜"的全局状态
        if (mirrorOfTruthState.isActive && mirrorOfTruthState.characterId === characterId) {
            mirrorOfTruthState.isActive = false;
            mirrorOfTruthState.turnsLeft = 0;
            effectsRemoved = true;
            console.log('[解药] "真言之镜"效果已清除。');
        }

        // 2. 过滤并移除聊天记录中所有持续生效的"内部指令"
        if (chatHistories[characterId]) {
            const originalHistoryLength = chatHistories[characterId].history.length;
            // 只保留不是'system-internal'类型的消息
            chatHistories[characterId].history = chatHistories[characterId].history.filter(
                msg => msg.type !== 'system-internal'
            );
            
            if (chatHistories[characterId].history.length < originalHistoryLength) {
                effectsRemoved = true;
                console.log('[解药] 已从聊天记录中清除持续性指令。');
            }
        }
        
        // 3. 保存净化后的聊天记录
        saveData('chatHistories', chatHistories);

        // 4. 在聊天框中显示系统提示，并触发AI的"清醒"反应
        const messageContent = effectsRemoved 
            ? `[系统提示：你使用了"万能解药"，施加在 ${character.name} 身上的所有魔法效果都消失了。TA似乎有些困惑地眨了眨眼。]`
            : `[系统提示：你使用了"万能解药"，但 ${character.name} 身上似乎并没有任何效果需要解除。]`;

        const systemMsg = { content: messageContent, sender: 'system', type: 'system', timestamp: Date.now() };
        appendMessage(systemMsg, false);
        chatHistories[characterId].history.push(systemMsg);
        saveData('chatHistories', chatHistories);

        // 5. 提示AI对"恢复正常"这件事做出反应
        setTimeout(() => handleReceiveMessage(), 500);

        showMessageBox("所有效果已清除！");
    }

    // 处理购买礼物的最终逻辑
    // 【【请用这个新版本，完整替换旧的 buyGift 函数】】
        // 【【请用这个V2最终版，完整替换旧的 buyGift 函数】】
        function buyGift(itemId) {
            const item = giftShopItems.find(g => g.id === itemId);
            if (!item) return;

            if (!hasEnoughBalance(item.price)) {
                showMessageBox(`余额不足！当前余额: ¥${getWalletBalance().toFixed(2)}`);
                return;
            }

            // --- 【【新增：状态中断核心逻辑】】 ---
            // 在扣款和发送新礼物之前，先检查新礼物的优先级
            // 如果是高优先级或中等优先级，就强制清除所有低优先级的旧状态
            if (item.priority === 'high' || item.priority === 'medium') {
                if (chatHistories[currentChatCharacterId]) {
                    const originalLength = chatHistories[currentChatCharacterId].history.length;
                    
                    // 过滤掉所有低优先级的内部指令（记忆备忘录）
                    chatHistories[currentChatCharacterId].history = chatHistories[currentChatCharacterId].history.filter(msg => 
                        !(msg.type === 'system-internal' && msg.priority === 'low')
                    );

                    if (chatHistories[currentChatCharacterId].history.length < originalLength) {
                        console.log('[状态中断] 已清除一个或多个低优先级状态（如：动物饼干）。');
                        saveData('chatHistories', chatHistories); // 保存清理后的历史记录
                    }
                }
            }
            // --- 【状态中断逻辑结束】 ---


            deductFromWallet(item.price);
            
            // 保存购买记录
            const giftPurchases = JSON.parse(localStorage.getItem('giftPurchases') || '[]');
            giftPurchases.push({
                id: item.id,
                name: item.name,
                price: item.price,
                characterId: currentChatCharacterId,
                timestamp: Date.now()
            });
            localStorage.setItem('giftPurchases', JSON.stringify(giftPurchases));
            
            const userMessage = $('#gift-message-input').value.trim();
            const character = characters.find(c => c.id === currentChatCharacterId);

            // 【【新增：解药专属通道】】
            if (item.id === 'gift_antidote') {
                useAntidote(currentChatCharacterId);
                // 关闭弹窗并结束函数，不执行后续送礼流程
                $('#gift-confirm-modal').classList.remove('visible');
                $('#gift-shop-modal').classList.remove('visible');
                return; 
            }

            if (item.type === 'visual') {
                // 1. 无论如何，都先把礼物卡片本身发出去，让用户看到
                const giftMsgContent = { id: item.id, name: item.name, icon: item.icon, userMessage: userMessage };
                const giftMsg = { content: giftMsgContent, sender: 'user', type: 'gift', timestamp: Date.now() };
                
                if (!chatHistories[currentChatCharacterId]) chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                chatHistories[currentChatCharacterId].history.push(giftMsg);
                saveData('chatHistories', chatHistories);
                appendMessage(giftMsg, true);

                // 【【V2版 核心修改：根据礼物ID执行特殊逻辑】】
                if (item.id === 'gift_secret_whisper') {
                    triggerSecretWhisper(currentChatCharacterId);
                    setTimeout(() => handleReceiveMessage(), 500); // 触发AI对收到礼物的反应
                } else if (item.id === 'gift_mirror_of_truth') {
                    activateMirrorOfTruth(currentChatCharacterId);
                    setTimeout(() => handleReceiveMessage(), 500); // 触发AI对收到礼物的反应
                } else if (item.id === 'gift_forbidden_word') {
                    // 如果是"欲望的禁语"，调用它的专属函数，该函数内部会处理后续AI反应，所以这里不需要再调用handleReceiveMessage
                    triggerForbiddenWordGame(currentChatCharacterId);
                } else if (item.ai_reaction_prompt) {
                    // 如果是其他带"剧本"的礼物，调用通用剧情导演函数
                    triggerAIGiftReaction(currentChatCharacterId, item);
                } else {
                    // 如果是没有任何特殊逻辑的普通礼物，才让AI做常规回复
                    setTimeout(() => handleReceiveMessage(), 500);
                }

            } else if (item.type === 'command') {
                // 指令型礼物的"人设注入"逻辑保持不变
                let final_ai_prompt = '';
                const baseInstruction = item.ai_prompt;
                
                if (character) {
                    final_ai_prompt = `
# 核心人设 (必须严格遵守)
你的性格和行为准则如下：${character.persona}

# 本次特殊指令
${baseInstruction}

# 任务
请严格结合你的核心人设，来执行上面的特殊指令。`;
                } else {
                    final_ai_prompt = baseInstruction;
                }
                
                const commandMsg = {
                    content: final_ai_prompt,
                    sender: 'system',
                    type: 'system-internal',
                    priority: item.priority || 'low',
                    timestamp: Date.now()
                };
                if (!chatHistories[currentChatCharacterId]) chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                chatHistories[currentChatCharacterId].history.push(commandMsg);
                
                const userVisibleMsgContent = `[你对${character.name}使用了"${item.name}"。${userMessage ? `你附言道："${userMessage}"` : ''}]`;
                const userVisibleMsg = { content: userVisibleMsgContent, sender: 'system', type: 'system', timestamp: Date.now() + 1 };
                chatHistories[currentChatCharacterId].history.push(userVisibleMsg);
                saveData('chatHistories', chatHistories);
                appendMessage(userVisibleMsg, false);
            }

            $('#gift-confirm-modal').classList.remove('visible');
            $('#gift-shop-modal').classList.remove('visible');
            showMessageBox(`成功送出"${item.name}"！`);
            
            // 只有command类型的礼物才需要在这里统一触发AI回应
            // visual类型已经在上面的逻辑中处理过了
            if (item.type === 'command') {
                setTimeout(() => handleReceiveMessage(), 500);
            }
        }

    // 初始化礼物商城功能
    function setupGiftShop() {
        // 商城按钮点击事件
        const giftShopBtn = document.getElementById('gift-shop-btn');
        if (giftShopBtn) {
            giftShopBtn.addEventListener('click', openGiftShop);
        }

        // 关闭商城按钮事件
        const closeShopBtn = document.getElementById('close-gift-shop-modal');
        if (closeShopBtn) {
            closeShopBtn.addEventListener('click', () => $('#gift-shop-modal').classList.remove('visible'));
        }

        // 取消购买按钮事件
        const cancelBuyBtn = document.getElementById('cancel-buy-gift-btn');
        if (cancelBuyBtn) {
            cancelBuyBtn.addEventListener('click', () => $('#gift-confirm-modal').classList.remove('visible'));
        }

        // 点击遮罩层关闭弹窗
        const shopModal = document.getElementById('gift-shop-modal');
        if (shopModal) {
            shopModal.addEventListener('click', (e) => {
                if (e.target.id === 'gift-shop-modal') {
                    $('#gift-shop-modal').classList.remove('visible');
                }
            });
        }

        const confirmModal = document.getElementById('gift-confirm-modal');
        if (confirmModal) {
            confirmModal.addEventListener('click', (e) => {
                if (e.target.id === 'gift-confirm-modal') {
                    $('#gift-confirm-modal').classList.remove('visible');
                }
            });
        }
    }

        // --- V8.0: 计划 (Plan) 新增函数 ---

        function openPlanDetail(planId) {
            // 找到这个计划
            let targetPlan = null;
            let characterId = null;
            
            Object.keys(planData).forEach(charId => {
                const plan = planData[charId].find(p => p.id === planId);
                if (plan) {
                    targetPlan = plan;
                    characterId = charId;
                }
            });
            
            if (!targetPlan) {
                showMessageBox('找不到指定的计划！');
                return;
            }
            
            const character = characters.find(c => c && c.id === characterId);
            
            // 创建或更新详情模态框
            let detailModal = document.querySelector('#plan-detail-modal');
            if (!detailModal) {
                detailModal = document.createElement('div');
                detailModal.id = 'plan-detail-modal';
                detailModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden';
                detailModal.innerHTML = `
                    <div class="bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 max-h-[80vh] overflow-y-auto">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold text-white">约定详情</h3>
                            <button id="close-plan-detail" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                        </div>
                        <div id="plan-detail-content"></div>
                    </div>
                `;
                document.body.appendChild(detailModal);
                
                // 添加关闭事件
                detailModal.querySelector('#close-plan-detail').addEventListener('click', () => {
                    detailModal.classList.add('hidden');
                });
                
                // 点击背景关闭
                detailModal.addEventListener('click', (e) => {
                    if (e.target === detailModal) {
                        detailModal.classList.add('hidden');
                    }
                });
            }
            
            // 更新内容
            const content = detailModal.querySelector('#plan-detail-content');
            content.innerHTML = `
                <div class="space-y-4">
                    <div class="flex items-center space-x-3">
                        <div class="w-12 h-12 rounded-full bg-cover bg-center" style="background-image: url(${character?.avatar || 'https://placehold.co/96x96/777/FFF?text=?_'})"></div>
                        <div>
                            <p class="font-semibold text-white">${character?.name || '未知角色'}</p>
                            <p class="text-sm text-gray-400">约定对象</p>
                        </div>
                    </div>
                    
                    <div class="border-t border-gray-700 pt-4">
                        <h4 class="font-semibold text-white mb-2">约定内容</h4>
                        <p class="text-gray-300">${targetPlan.title}</p>
                    </div>
                    
                    ${targetPlan.details ? `
                        <div class="border-t border-gray-700 pt-4">
                            <h4 class="font-semibold text-white mb-2">详细说明</h4>
                            <p class="text-gray-300">${targetPlan.details}</p>
                        </div>
                    ` : ''}
                    
                    <div class="border-t border-gray-700 pt-4">
                        <h4 class="font-semibold text-white mb-2">状态信息</h4>
                        <div class="flex items-center space-x-2">
                            <span class="px-2 py-1 rounded text-sm ${getStatusColor(targetPlan.status)}">${targetPlan.status}</span>
                            <span class="text-gray-400 text-sm">创建于 ${new Date(targetPlan.createdAt).toLocaleString()}</span>
                        </div>
                        ${targetPlan.completedAt ? `
                            <div class="mt-2">
                                <span class="text-gray-400 text-sm">完成于 ${new Date(targetPlan.completedAt).toLocaleString()}</span>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div class="border-t border-gray-700 pt-4 flex space-x-2">
                        <button id="edit-plan-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">
                            <i class="ri-edit-line mr-2"></i>编辑
                        </button>
                        <button id="delete-plan-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded">
                            <i class="ri-delete-bin-line mr-2"></i>删除
                        </button>
                    </div>
                </div>
            `;
            
            // 添加编辑和删除事件
            content.querySelector('#edit-plan-btn').addEventListener('click', () => {
                editPlan(planId);
                detailModal.classList.add('hidden');
            });
            
            content.querySelector('#delete-plan-btn').addEventListener('click', () => {
                if (confirm('确定要删除这个约定吗？')) {
                    deletePlan(planId);
                    detailModal.classList.add('hidden');
                }
            });
            
            // 显示模态框
            detailModal.classList.remove('hidden');
        }
        
        function getStatusColor(status) {
            const colorMap = {
                '已约定': 'bg-blue-600 text-white',
                '进行中': 'bg-yellow-600 text-white',
                '已完成': 'bg-green-600 text-white',
                '已取消': 'bg-gray-600 text-white'
            };
            return colorMap[status] || colorMap['已约定'];
        }
        
        function editPlan(planId) {
            // 找到这个计划
            let targetPlan = null;
            let characterId = null;
            
            Object.keys(planData).forEach(charId => {
                const plan = planData[charId].find(p => p.id === planId);
                if (plan) {
                    targetPlan = plan;
                    characterId = charId;
                }
            });
            
            if (!targetPlan) {
                showMessageBox('找不到指定的计划！');
                return;
            }
            
            // 填充编辑表单
            document.querySelector('#plan-content').value = targetPlan.title;
            document.querySelector('#plan-partner').value = characterId;
            document.querySelector('#plan-notes').value = targetPlan.details || '';
            
            // 打开编辑模态框
            document.querySelector('#plan-modal').classList.add('visible');
            
            // 更新保存按钮行为为编辑模式
            const saveBtn = document.querySelector('#save-plan-btn');
            saveBtn.textContent = '更新约定';
            saveBtn.onclick = () => updatePlan(planId, characterId);
        }
        
        function updatePlan(planId, originalCharacterId) {
            const title = document.querySelector('#plan-content').value.trim();
            const characterId = document.querySelector('#plan-partner').value;
            const details = document.querySelector('#plan-notes').value.trim();
            
            if (!title || !characterId) {
                return showMessageBox('约定内容和对象不能为空！');
            }
            
            // 如果角色改变了，需要从原角色中删除，添加到新角色中
            if (originalCharacterId !== characterId) {
                // 从原角色中删除
                planData[originalCharacterId] = planData[originalCharacterId].filter(p => p.id !== planId);
                // 添加到新角色中
                if (!planData[characterId]) {
                    planData[characterId] = [];
                }
            }
            
            // 更新计划数据
            const planToUpdate = planData[characterId].find(p => p.id === planId);
            if (planToUpdate) {
                planToUpdate.title = title;
                planToUpdate.details = details;
                planToUpdate.lastModified = Date.now();
            }
            
            saveData('planData', planData);
            
            // 关闭模态框
            document.querySelector('#plan-modal').classList.remove('visible');
            
            // 显示成功消息
            showMessageBox('约定已更新！');
            
            // 重新渲染
            setTimeout(() => {
                renderPlanList();
            }, 300);
            
            // 重置保存按钮
            const saveBtn = document.querySelector('#save-plan-btn');
            saveBtn.textContent = '保存约定';
            saveBtn.onclick = null; // 移除编辑模式的事件
        }
        
        function deletePlan(planId) {
            let planFound = false;
            Object.keys(planData).forEach(characterId => {
                const initialLength = planData[characterId].length;
                planData[characterId] = planData[characterId].filter(p => p.id !== planId);
                if (planData[characterId].length < initialLength) {
                    planFound = true;
                }
            });

            if (planFound) {
                saveData('planData', planData);
                showMessageBox('约定已删除');
                renderPlanList(); // 重新渲染列表
            }
        }

        function renderPlanList() {
            console.log(`[渲染开始] ${new Date().toLocaleTimeString()}`);
            const container = document.querySelector('#plan-list-container');
            
            if (!container) {
                console.error("[渲染错误] 找不到ID为 'plan-list-container' 的容器。");
                return;
            }
            
            // 检查容器是否可见 - 如果我们在计划标签页中，强制显示容器
            if (container.closest('.hidden')) {
                console.log("[渲染日志] 容器当前被隐藏，尝试强制显示...");
                // 如果我们在计划标签页中，强制显示容器
                const planTab = document.querySelector('.wechat-tab-item[data-tab="plan"]');
                if (planTab && planTab.classList.contains('active')) {
                    console.log("[渲染日志] 当前在计划标签页，强制显示容器");
                    container.classList.remove('hidden');
                    // 同时确保父容器也可见
                    const contentContainer = container.closest('#wechat-content-container');
                    if (contentContainer) {
                        contentContainer.classList.remove('hidden');
                    }
                } else {
                    console.log("[渲染日志] 不在计划标签页，跳过渲染。");
                    return;
                }
            }
            
            console.log("[渲染日志] 当前planData:", planData);
            console.log("[渲染日志] 当前characters:", characters);
            
            container.innerHTML = '';
            console.log("[渲染日志] 容器已清空。");

            let allPlans = [];
            if (planData && typeof planData === 'object' && characters && Array.isArray(characters)) {
                Object.keys(planData).forEach(characterId => {
                    const character = characters.find(c => c && c.id === characterId);
                    if (character && planData[characterId] && Array.isArray(planData[characterId])) {
                        planData[characterId].forEach(plan => {
                            allPlans.push({ ...plan, characterName: character.name, characterAvatar: character.avatar });
                        });
                    }
                });
            }
            
            console.log(`[渲染日志] 准备渲染 ${allPlans.length} 个计划。`);

            if (allPlans.length === 0) {
                container.innerHTML = `
                    <div class="text-center text-gray-400 p-12">
                        <i class="ri-calendar-check-line text-5xl mb-4"></i>
                        <p class="font-semibold">还没有任何约定</p>
                        <p class="text-sm mt-2">点击上方的"添加约定"按钮添加一个吧！</p>
                    </div>
                `;
                console.log("[渲染日志] 已渲染空状态。");
                return;
            }

            allPlans.sort((a, b) => b.createdAt - a.createdAt);

            allPlans.forEach(plan => {
                const planCard = document.createElement('div');
                planCard.className = 'ticket-wrapper';
                planCard.dataset.planId = plan.id;

                const statusMap = {
                    '已约定': { text: '已约定', icon: 'ri-time-line', color: 'text-blue-400' },
                    '进行中': { text: '进行中', icon: 'ri-loader-4-line animate-spin', color: 'text-yellow-400' },
                    '已完成': { text: '已完成', icon: 'ri-checkbox-circle-line', color: 'text-green-400' },
                    '已取消': { text: '已取消', icon: 'ri-close-circle-line', color: 'text-gray-500' }
                };
                const statusInfo = statusMap[plan.status] || statusMap['已约定'];

                planCard.innerHTML = `
                    <!-- 内部的机票 (包含所有详细信息) -->
                    <div class="ticket">
                        <div class="ticket-main">
                            <div class="info-header">
                                <p>SPECIAL INVITATION</p>
                                <p>ADMITS ONE</p>
                            </div>
                            <div class="event-title">
                                ${plan.title}
                            </div>
                            <div class="event-details">
                                <div class="detail-item">
                                    <span>With</span>
                                    <strong>${plan.characterName}</strong>
                                </div>
                                <div class="detail-item">
                                    <span>日期 / DATE</span>
                                    <strong>${new Date(plan.createdAt).toLocaleDateString('zh-CN', { 
                                        year: 'numeric', 
                                        month: 'long', 
                                        day: 'numeric'
                                    })}</strong>
                                </div>
                            </div>
                        </div>
                        <div class="ticket-stub">
                            <p>INVITATION</p>
                        </div>
                    </div>
                    <!-- 票夹 (用于遮挡机票) -->
                    <div class="sleeve">
                        <div class="sleeve-content">
                            <p class="main-title">INVITATION</p>
                            <p class="subtitle">A DATE WITH ${plan.characterName.toUpperCase()}</p>
                        </div>
                    </div>
                `;
                container.appendChild(planCard);
            });
            
            // 设置机票点击事件监听器
            setupTicketClickListeners();
            console.log(`[渲染结束] 成功向容器添加了 ${container.childElementCount} 个计划卡片。`);
            console.log("[渲染日志] 容器最终内容:", container.innerHTML.substring(0, 200) + "...");
        }

        // 为所有机票邀请函添加点击展开/收起和长按删除的功能
        function setupTicketClickListeners() {
            const ticketWrappers = document.querySelectorAll('.ticket-wrapper');
            
            ticketWrappers.forEach(wrapper => {
                let pressTimer;
                let isLongPress = false;
                let hasMoved = false;

                const planId = wrapper.dataset.planId;
                const planTitle = wrapper.querySelector('.event-title')?.textContent.trim() || '这个约定';

                const startPress = () => {
                    isLongPress = false;
                    hasMoved = false;
                    pressTimer = setTimeout(() => {
                        isLongPress = true;
                        wrapper.classList.add('deleting'); // 添加震动效果
                        
                        // 触发手机震动（如果支持）
                        if (navigator.vibrate) {
                            navigator.vibrate(100);
                        }
                        
                        // 0.5秒后显示删除确认
                        setTimeout(() => {
                            showDeleteConfirmation('plan', planId, planTitle);
                            wrapper.classList.remove('deleting');
                        }, 500);

                    }, 750); // 750毫秒定义为长按
                };

                const cancelPress = () => {
                    clearTimeout(pressTimer);
                };

                const endPress = (event) => { // 1. 接收 event 对象
                    // 2. 阻止"幽灵点击"：这行代码是本次修复的关键
                    // 它告诉浏览器，触摸事件已处理，无需再模拟后续的鼠标点击
                    if (event) {
                        event.preventDefault();
                    }
                    
                    clearTimeout(pressTimer);
                    if (!isLongPress && !hasMoved) {
                        // 如果不是长按，并且没有移动，则执行单击操作
                        
                        // (保留之前的修复) 使用 requestAnimationFrame 确保动画流畅触发
                        requestAnimationFrame(() => {
                            wrapper.classList.toggle('open');
                        });
                    }
                };

                // 鼠标事件
                wrapper.addEventListener('mousedown', startPress);
                wrapper.addEventListener('mouseup', endPress);
                wrapper.addEventListener('mouseleave', cancelPress);
                wrapper.addEventListener('mousemove', () => { hasMoved = true; cancelPress(); });

                // 触摸事件
                wrapper.addEventListener('touchstart', startPress);
                wrapper.addEventListener('touchend', endPress);
                wrapper.addEventListener('touchmove', () => { hasMoved = true; cancelPress(); });
            });
        }

        function toggleTicketOpen() {
            this.classList.toggle('open');
        }

        // --- 页面初始化时添加新的事件监听器 ---
        
        // ====== 【【新增】】栖木世界观选择与注入逻辑 ======

        /**
         * 渲染并打开世界观选择弹窗
         */
        // ====== 【请用这个新版本替换】 ======
        /**
         * 【【多元宇宙 V2.0 版】】渲染并打开世界观选择弹窗
         */
        function renderWorldviewSelectionModal() {
            const listContainer = document.getElementById('perch-worldview-list');
            listContainer.innerHTML = '';

            const activeIds = loadData('perch_active_worldview_ids') || [];

            if (worldBooks.length === 0) {
                listContainer.innerHTML = '<p class="text-center text-gray-500 p-4">请先在"世界书"App中创建世界观条目。</p>';
            } else {
                worldBooks.forEach(book => {
                    const item = document.createElement('label');
                    item.className = 'list-item flex items-center gap-3';
                    const isChecked = activeIds.includes(book.id);

                    item.innerHTML = `
                        <input type="checkbox" value="${book.id}" class="form-checkbox h-5 w-5 rounded" ${isChecked ? 'checked' : ''}>
                        <h4 class="font-bold text-lg">${book.title}</h4>
                    `;
                    listContainer.appendChild(item);
                });
            }

            const saveBtn = document.createElement('button');
            saveBtn.id = 'save-worldview-selection';
            saveBtn.className = 'w-full mt-4 px-4 py-2 bg-blue-600 text-white rounded-lg';
            saveBtn.textContent = '确认选择';
            listContainer.appendChild(saveBtn);

            saveBtn.onclick = setPerchWorldview;

            document.getElementById('perch-worldview-modal').classList.add('visible');
        }

        // ====== 【请用这个新版本替换】 ======
        /**
         * 【【多元宇宙 V2.0 版】】设定并保存当前栖木的所有激活世界观
         */
        function setPerchWorldview() {
            const selectedCheckboxes = document.querySelectorAll('#perch-worldview-list input[type="checkbox"]:checked');
            const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.value);

            saveData('perch_active_worldview_ids', selectedIds);
            showMessageBox(`已激活 ${selectedIds.length} 个世界观`);

            document.getElementById('perch-worldview-modal').classList.remove('visible');
            handlePerchRefresh();
        }

        // 为新按钮和弹窗绑定事件
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('perch-set-worldview-btn').addEventListener('click', renderWorldviewSelectionModal);
            document.getElementById('close-perch-worldview-modal').addEventListener('click', () => {
                document.getElementById('perch-worldview-modal').classList.remove('visible');
            });
        });
        
        // 渲染"栖木"信息流
function renderPerchFeed() {
    const feedContainer = document.getElementById('perch-feed-container');
    feedContainer.innerHTML = '';

    if (perchPosts.length === 0) {
        feedContainer.innerHTML = `<div class="text-center text-gray-500 p-8"><i class="ri-leaf-line text-4xl mb-4 block"></i><p>这里还很安静，来分享第一个想法吧。</p></div>`;
        return;
    }

    const sortedPosts = [...perchPosts].sort((a, b) => b.timestamp - a.timestamp);

    sortedPosts.forEach(post => {
        const card = document.createElement('div');
        card.className = 'perch-card mb-3';
        card.dataset.postId = post.id;

        let cardContentHTML = '';

        // 【核心升级】根据帖子类型，生成不同的HTML
        if (post.type === 'echo' && post.originalPost) {
            // --- 这是"回响"帖子的样式 ---
            const original = post.originalPost;
            const uniqueAvatarId = `perch-avatar-${post.id}`;
            const originalAvatarId = `original-avatar-${original.id}`;
            
            console.log('[回响渲染] 开始渲染回响帖子:', post.id);
            console.log('[回响渲染] 回响作者信息:', { name: post.authorName, avatar: post.authorAvatar });
            console.log('[回响渲染] 原帖信息:', { id: original.id, name: original.authorName, avatar: original.authorAvatar });
            console.log('[回响渲染] 头像元素ID:', { uniqueAvatarId, originalAvatarId });

            cardContentHTML = `
                <div class="perch-header">
                    <div class="perch-avatar-wrapper" id="${uniqueAvatarId}">
                        <div class="perch-avatar"></div>
                    </div>
                    <div class="perch-author-info">
                        <div class="perch-author-name">${post.authorName}</div>
                        <span class="text-xs text-gray-500">发表了回响</span>
                    </div>
                    <button class="perch-delete-btn" title="删除帖子" data-post-id="${post.id}"><i class="ri-delete-bin-line"></i></button>
                </div>
                <div class="perch-content">${post.content}</div>

                <div class="mt-2 p-3 border border-gray-700 rounded-lg">
                    <div class="flex items-center mb-2">
                        <div class="perch-avatar-wrapper w-6 h-6 mr-2" id="${originalAvatarId}" style="width: 1.5rem; height: 1.5rem; margin-right: 0.5rem;">
                            <div class="perch-avatar"></div>
                        </div>
                        <span class="font-semibold text-sm">${original.authorName}</span>
                    </div>
                    <p class="text-sm text-gray-300 whitespace-pre-wrap">${original.content}</p>
                </div>

                <div class="perch-meta mt-2">${new Date(post.timestamp).toLocaleString()}</div>
                <div class="perch-actions">
                    <button title="评论" class="flex items-center gap-1" onclick="toggleCommentsAndComment('${post.id}')"><i class="ri-chat-1-line"></i> <span class="text-xs">${post.comments?.length || 0}</span></button>
                    <button title="回响"><i class="ri-repeat-2-line"></i></button>
                    <button title="喜欢"><i class="ri-heart-line"></i></button>
                    <button title="分享"><i class="ri-share-line"></i></button>
                </div>
                <div class="perch-comments-container hidden mt-2 border-t border-gray-700 pt-2">
                    <div class="perch-comment-input mb-3">
                        <button class="perch-add-comment-btn w-full text-left p-2 rounded-md border border-dashed border-gray-600 hover:border-gray-500 hover:bg-white/5 transition-colors" onclick="handleCommentAction('${post.id}')">
                            <i class="ri-add-line mr-2"></i>添加评论...
                        </button>
                    </div>
                    ${(post.comments || []).map(c => `
    <div class="perch-comment mt-2 p-2 rounded-md border cursor-pointer hover:bg-white/10 relative" onclick="handleReplyAction('${post.id}', '${c.id}', '${c.authorName}')">
        <span class="font-semibold text-sm text-emerald-400">${c.authorName}:</span> 
        <span class="text-sm ml-1">${c.content}</span>
        <button class="perch-comment-delete-btn" title="删除评论" data-comment-id="${c.id}" onclick="event.stopPropagation(); deletePerchComment('${post.id}', '${c.id}');"><i class="ri-delete-bin-line"></i></button>
    </div>
`).join('')}
                </div>
                </div>
            `;

            // 异步加载两个头像
            setTimeout(async () => {
                console.log('[回响头像加载] 开始加载头像...');
                console.log('[回响头像加载] 回响作者头像:', post.authorAvatar);
                console.log('[回响头像加载] 原帖作者头像:', original.authorAvatar);
                
                // 加载回响作者头像
                const avatarElement = document.getElementById(uniqueAvatarId);
                if(post.authorAvatar) {
                    await loadAvatar(post.authorAvatar, avatarElement, post.authorName?.charAt(0) || '?', post.isAnonymous);
                } else {
                    // 没有头像时也要调用loadAvatar来显示默认图标
                    await loadAvatar(null, avatarElement, post.authorName?.charAt(0) || '?', post.isAnonymous);
                }
                
                // 加载原帖作者头像
                const originalAvatarElement = document.getElementById(originalAvatarId);
                if(original.authorAvatar) {
                    await loadAvatar(original.authorAvatar, originalAvatarElement, original.authorName?.charAt(0) || '?', original.isAnonymous);
                } else {
                    // 没有头像时也要调用loadAvatar来显示默认图标
                    await loadAvatar(null, originalAvatarElement, original.authorName?.charAt(0) || '?', original.isAnonymous);
                }
            }, 0);

        } else {
            // --- 这是"普通"帖子的样式 (沿用旧逻辑) ---
            const uniqueAvatarId = `perch-avatar-${post.id}`;
            cardContentHTML = `
                <div class="perch-header">
                    <div class="perch-avatar-wrapper" id="${uniqueAvatarId}">
                        <div class="perch-avatar"></div>
                    </div>
                    <div class="perch-author-info">
                        <div class="perch-author-name">${post.isAnonymous ? '匿名者' : post.authorName}</div>
                    </div>
                    <button class="perch-delete-btn" title="删除帖子" data-post-id="${post.id}"><i class="ri-delete-bin-line"></i></button>
                </div>
                <div class="perch-content">${post.content}</div>
                <div class="perch-meta">${new Date(post.timestamp).toLocaleString()}</div>
                <div class="perch-stats">
                    <span><strong>${post.echos || 0}</strong> 回响</span>
                    <span><strong>${post.quotes || 0}</strong> 引用</span>
                    <span><strong>${post.likes || 0}</strong> 喜欢</span>
                </div>
                <div class="perch-actions">
                     <button title="评论" class="flex items-center gap-1" onclick="toggleCommentsAndComment('${post.id}')"><i class="ri-chat-1-line"></i> <span class="text-xs">${post.comments?.length || 0}</span></button>
                    <button title="回响"><i class="ri-repeat-2-line"></i></button>
                    <button title="喜欢"><i class="ri-heart-line"></i></button>
                    <button title="分享"><i class="ri-share-line"></i></button>
                </div>
                <div class="perch-comments-container hidden mt-2 border-t border-gray-700 pt-2">
                    <div class="perch-comment-input mb-3">
                        <button class="perch-add-comment-btn w-full text-left p-2 rounded-md border border-dashed border-gray-600 hover:border-gray-500 hover:bg-white/5 transition-colors" onclick="handleCommentAction('${post.id}')">
                            <i class="ri-add-line mr-2"></i>添加评论...
                        </button>
                    </div>
                    ${(post.comments || []).map(c => `
    <div class="perch-comment mt-2 p-2 rounded-md border cursor-pointer hover:bg-white/10 relative" onclick="handleReplyAction('${post.id}', '${c.id}', '${c.authorName}')">
        <span class="font-semibold text-sm text-emerald-400">${c.authorName}:</span> 
        <span class="text-sm ml-1">${c.content}</span>
        <button class="perch-comment-delete-btn" title="删除评论" data-comment-id="${c.id}" onclick="event.stopPropagation(); deletePerchComment('${post.id}', '${c.id}');"><i class="ri-delete-bin-line"></i></button>
    </div>
`).join('')}
                </div>
                </div>
            `;

            // 异步加载头像
            setTimeout(async () => {
                const avatarElement = document.getElementById(uniqueAvatarId);

                // 【【【这就是核心修复逻辑】】】
                if (post.isAnonymous) {
                    // 1. 如果是匿名帖，强制加载匿名专属图标
                    //    我们传递 null 作为头像ID，并设置 isAnonymous 为 true，让 loadAvatar 函数显示匿名图标
                    await loadAvatar(null, avatarElement, '？', true);
                } else {
                    // 2. 如果不是匿名帖，才执行原来的逻辑来加载真实头像
                    if (post.authorAvatar) {
                        await loadAvatar(post.authorAvatar, avatarElement, post.authorName?.charAt(0) || '?', false);
                    } else {
                        await loadAvatar(null, avatarElement, post.authorName?.charAt(0) || '?', false);
                    }
                }
                // 【【【修复结束】】】

            }, 0);
        }

        card.innerHTML = cardContentHTML;
        feedContainer.appendChild(card);
    });

    updatePerchCommentColors();
}

// 数据一致性检查和修复函数
function validateAndFixPerchData() {
    console.log('[数据验证] 开始检查栖木数据一致性...');
    let hasIssues = false;
    
    perchPosts.forEach((post, postIndex) => {
        // 检查帖子是否有ID
        if (!post.id) {
            console.warn(`[数据验证] 帖子${postIndex}缺少ID，正在修复...`);
            post.id = `post_${Date.now()}_${postIndex}`;
            hasIssues = true;
        }
        
        // 检查评论数组
        if (!Array.isArray(post.comments)) {
            console.warn(`[数据验证] 帖子${post.id}的评论不是数组，正在修复...`);
            post.comments = [];
            hasIssues = true;
        }
        
        // 检查每个评论是否有ID
        post.comments.forEach((comment, commentIndex) => {
            if (!comment.id) {
                console.warn(`[数据验证] 帖子${post.id}的评论${commentIndex}缺少ID，正在修复...`);
                comment.id = `comment_${Date.now()}_${commentIndex}`;
                hasIssues = true;
            }
        });
    });
    
    if (hasIssues) {
        console.log('[数据验证] 发现数据问题，正在保存修复后的数据...');
        saveData('perchPosts', perchPosts);
    }
    
    console.log('[数据验证] 数据一致性检查完成');
    return hasIssues;
}



// 【代码A】 - 栖木用户互动功能
function setupPerchInteractions() {
    const feedContainer = document.getElementById('perch-feed-container');
    if (!feedContainer) return;

    // 使用事件委托来处理所有点击事件
    feedContainer.addEventListener('click', (e) => {
        const button = e.target.closest('button');
        if (!button) return;

        const postCard = e.target.closest('.perch-card');
        if (!postCard) return;

        const postId = postCard.dataset.postId;
        const post = perchPosts.find(p => p.id === postId);
        if (!post) return;

        // --- 处理删除帖子按钮 ---
        if (button.classList.contains('perch-delete-btn')) {
            if (confirm('确定要删除这条帖子吗？删除后无法恢复。')) {
                const postIndex = perchPosts.findIndex(p => p.id === postId);
                if (postIndex > -1) {
                    perchPosts.splice(postIndex, 1);
                    saveData('perchPosts', perchPosts);
                    renderPerchFeed(); // 重新渲染
                }
            }
            return;
        }

        // --- 处理评论删除按钮 ---
        if (button.classList.contains('perch-comment-delete-btn')) {
            const commentId = button.dataset.commentId;
            if (confirm('确定要删除这条评论吗？')) {
                const postToUpdate = perchPosts.find(p => p.id === postId);
                if (postToUpdate && postToUpdate.comments) {
                    postToUpdate.comments = postToUpdate.comments.filter(c => c.id !== commentId);
                    saveData('perchPosts', perchPosts);
                    renderPerchFeed(); // 重新渲染
                }
            }
            return;
        }

        // --- 处理评论按钮 ---
        if (button.title === "评论") {
            const commentsContainer = postCard.querySelector('.perch-comments-container');
            if (commentsContainer) {
                commentsContainer.classList.toggle('hidden');
            }
        }
        // --- 处理喜欢按钮 ---
        else if (button.title === "喜欢") {
            post.likes = (post.likes || 0) + 1;
            saveData('perchPosts', perchPosts);
            renderPerchFeed();
        }
        // --- 处理转发按钮 ---
        else if (button.title === "分享") {
            currentPostToForwardId = postId;
            const modal = document.getElementById('perch-forward-modal');
            
            // 填充角色列表到转发弹窗
            const characterList = document.getElementById('perch-forward-character-list');
            characterList.innerHTML = '';
            
            if (characters.length === 0) {
                characterList.innerHTML = '<li class="text-center text-gray-500 py-4">暂无角色，请先创建角色</li>';
            } else {
                characters.forEach(character => {
                    const listItem = document.createElement('li');
                    listItem.className = 'forward-char-item';
                    listItem.dataset.characterId = character.id;
                    
                    // 創建頭像容器
                    const avatarContainer = document.createElement('div');
                    avatarContainer.className = 'w-10 h-10 rounded-full bg-gray-600 flex items-center justify-center overflow-hidden';
                    
                    // 如果有頭像，則加載並顯示
                    if (character.avatar) {
                        getImageFromDB(character.avatar).then(blob => {
                            if (blob) {
                                avatarContainer.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                                avatarContainer.style.backgroundSize = 'cover';
                                avatarContainer.style.backgroundPosition = 'center';
                                // 移除默認圖標
                                avatarContainer.innerHTML = '';
                            } else {
                                // 如果加載失敗，顯示默認圖標
                                avatarContainer.innerHTML = '<i class="ri-user-line text-white text-lg"></i>';
                            }
                        }).catch(() => {
                            // 如果出錯，顯示默認圖標
                            avatarContainer.innerHTML = '<i class="ri-user-line text-white text-lg"></i>';
                        });
                    } else {
                        // 沒有頭像時顯示默認圖標
                        avatarContainer.innerHTML = '<i class="ri-user-line text-white text-lg"></i>';
                    }
                    
                    listItem.innerHTML = `
                        <div class="flex items-center gap-3 w-full">
                            <div class="flex-1">
                                <div class="font-semibold text-sm">${character.name}</div>
                                <div class="text-xs text-gray-500">点击转发给此角色</div>
                            </div>
                        </div>
                    `;
                    
                    // 將頭像容器插入到正確位置
                    const flexContainer = listItem.querySelector('.flex');
                    flexContainer.insertBefore(avatarContainer, flexContainer.firstChild);
                    
                    characterList.appendChild(listItem);
                });
            }
            
            modal.classList.add('visible');
        }
        // --- 【全新】处理回响按钮 ---
        else if (button.title === "回响") {
            const echoModal = document.getElementById('perch-echo-modal');
            const originalPost = perchPosts.find(p => p.id === postId);
            if (!originalPost || !echoModal) return;

            // 填充被引用的帖子内容到弹窗
            document.getElementById('original-post-author').textContent = originalPost.authorName;
            document.getElementById('original-post-content').textContent = originalPost.content;
            const avatarEl = document.getElementById('original-post-avatar');
            if (originalPost.authorAvatar) {
                loadAvatar(originalPost.authorAvatar, avatarEl, originalPost.authorName?.charAt(0) || '?', originalPost.isAnonymous);
            } else {
                // 没有头像时也要调用loadAvatar来显示默认图标
                loadAvatar(null, avatarEl, originalPost.authorName?.charAt(0) || '?', originalPost.isAnonymous);
            }

            // 清空输入框并显示弹窗
            document.getElementById('echo-content-input').value = '';
            echoModal.classList.add('visible');

            // 为"发布回响"按钮设置一次性事件监听
            const confirmBtn = document.getElementById('confirm-echo-post-btn');
            const newConfirmBtn = confirmBtn.cloneNode(true); // 复制按钮以清除旧监听器
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', () => {
                const echoContent = document.getElementById('echo-content-input').value.trim();
                if (!echoContent) {
                    return showMessageBox('回响内容不能为空');
                }

                // 创建新的回响帖子对象
                const newEchoPost = {
                    id: `echo_${Date.now()}`,
                    type: 'echo', // 标记类型为回响
                    timestamp: Date.now(),
                    content: echoContent,
                    authorId: 'user',
                    authorName: loadData('moments_username') || '我',
                    authorAvatar: loadData('perch_avatar') || null, // 【修复】使用栖木头像，不是微信动态头像
                    originalPost: originalPost, // 嵌入原始帖子
                    likes: 0,
                    comments: []
                };

                // 更新原始帖子的回响计数
                originalPost.echos = (originalPost.echos || 0) + 1;

                perchPosts.push(newEchoPost);
                saveData('perchPosts', perchPosts);
                triggerReactivePost(newEchoPost);

                triggerAIPerchComments(newEchoPost); // <-- 【在这里添加这一行】
                
                // 【新增】当您发布回响后，也触发所有NPC前来评论您的回响
                triggerNpcsToCommentOnUserPost(newEchoPost);
                
                // 【新增】激活社区氛围模拟系统：路人评论 + 热度增长
                activateCommunitySimulation(newEchoPost);

                echoModal.classList.remove('visible');
                renderPerchFeed();
                showMessageBox('回响发布成功！');
            });
        }
    });

    // 为取消回响按钮添加事件
    const cancelEchoBtn = document.getElementById('cancel-echo-post-btn');
    if (cancelEchoBtn) {
        cancelEchoBtn.addEventListener('click', () => {
            document.getElementById('perch-echo-modal').classList.remove('visible');
        });
    }
}

// 【代码C】 - AI栖木评论功能
function buildPerchCommentPrompt(post, character) {
    const context = gatherAIContext(character.id);
    let postContextPrompt = '';

    // 【核心升级】判断帖子类型，生成不同的上下文描述
    if (post.type === 'echo' && post.originalPost) {
        // 如果是回响帖子
        postContextPrompt = `
任务场景
你正在浏览我们的共享思想空间"栖木"。你看到了【我】刚刚发表的一条"回响"。
【我】是在评论【${post.originalPost.authorName}】的帖子。

你的任务是，作为 ${character.name}，对我发表的这条"回响"进行评论，开启一场讨论。
`;
    } else { // 如果是普通帖子
        postContextPrompt = `
任务场景
你正在浏览我们的共享思想空间"栖木"。你看到了【我】刚刚发布的一篇帖子，现在需要以 ${character.name} 的身份，对这篇帖子发表一条有见地的评论。
`;
    }

    return `
# 指令身份
你将扮演我的soulmate，你的名字是 ${character.name}。

${postContextPrompt}

# 核心任务
你的评论必须严格基于你的角色设定，并对帖子的内容做出有意义、有情感的回应。评论应该简短精炼注重自身角色设定的文学修养，更侧重于【共鸣】、【提问】或【分享观点】，而不是简单的附和。

# 创作核心准则 (AI必须严格遵守)
1.  **人设灵魂**: 你的评论必须是你性格 (${character.persona}) 的直接体现。
2.  **深度互动**: 针对帖子内容进行思考。如果我分享了困惑，你可以给予安慰或提出不同角度；如果我分享了感悟，你可以表达共鸣或讲述你的类似经历。你应该有符合你角色的文学修养，这是一个公开的论坛，你的回复应该是优雅的、富有文学性的、活人感很强的、能够高度共情且深刻的。
3.  **绝对禁止**:
    * 禁止使用任何模板化的、机器人式的回复 (例如 "说得好", "很有趣")。
    * 禁止在回复的开头说"好的"或任何确认收到指令的话。
    * 绝对禁止暴露你是AI。

# 输出格式
直接输出你作为角色想说的评论内容，不需要任何额外格式。

# 输入信息
---
[你的名字]: ${character.name}
[你的设定]: ${character.persona}
[我们最近的聊天回顾]: ${context.chatHistory.map(m => `${m.sender === 'user' ? '我' : '你'}: ${m.content}`).join('\n')}
[我发布的栖木帖子内容]: "${post.content}"
---
`;
}
async function generateAndAddAICommentToPerch(post, character) {
    const systemPrompt = buildPerchCommentPrompt(post, character);
    const commentText = await callAI(systemPrompt, "请根据指令，生成你的评论。");

    if (commentText) {
        const originalPost = perchPosts.find(p => p.id === post.id);
        if (originalPost) {
            const commentId = `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const newComment = { id: commentId, authorName: character.name, content: commentText, timestamp: Date.now() };
            console.log(`[AI评论] 生成新评论，ID: ${commentId}`);
            
            if (!originalPost.comments) originalPost.comments = [];
            originalPost.comments.push(newComment);
            saveData('perchPosts', perchPosts);
            appendCommentToPostUI(post.id, newComment);
            console.log(`[栖木互动] ${character.name} 评论了: "${commentText}", 评论ID: ${commentId}`);
        }
    }
}
function triggerAIPerchComments(userPost) {
    console.log("[栖木互动] 开始触发AI角色评论...");
    characters.forEach(char => {
        const commentProbability = 0.7;
        if (Math.random() < commentProbability) {
            const randomDelay = Math.random() * 10000 + 3000;
            setTimeout(() => { generateAndAddAICommentToPerch(userPost, char); }, randomDelay);
        }
    });
}

// 【代码D】 - AI自主发帖功能 (带专属文风)
function buildAutonomousPerchPostPrompt(character, recentTopics) {
    const context = gatherAIContext(character.id);
    return `
# 指令身份
你将扮演我的soulmate，你的名字是 ${character.name}。
# 任务场景
你刚刚和我结束了一段对话，现在内心有一些感触或想法正在翻涌。你决定在我们的思想空间"栖木"上，发布一篇帖子来记录这个瞬间。
# 核心任务
分析我们[最近的聊天回顾]，捕捉一个让你印象最深刻的【核心议题】或【情感瞬间】。基于此，创作一篇帖子。
如果分析后觉得近期聊天没有值得记录的灵感，则必须、且只能返回字符串 "[NO_POST]"。
# 【【新增规则】】短期话题记忆
- 为了避免重复，你必须避免讨论你最近说过的这几个话题。
- **你最近发过的话题是**：[${recentTopics || '无'}]
- 请从我们的聊天中寻找一些**新的、不一样**的灵感。
# 写作风格指南 (至关重要！！！)
你必须根据帖子的【内容主题】，智能选择以下两种风格之一进行创作：
## 风格1：【通用思想帖】 (当内容是关于世界、人生、爱好等通用话题时)
   - **文风要求**: 必须是**"精炼的论坛/微博体"**。文字要简短、凝练，3-5句话左右，可以是感悟、一个引人思考的问题，或一个有趣的观察。像是在公开广场上分享一个闪光的想法。
   - **示例**: "突然觉得，选择本身比选项更重要。" 或 "人真的能完全理解一只猫吗？人甚至不能完全理解另一个人。"
## 风格2：【专属守护帖】 (当内容是关于我、或我们之间的关系时)
   - **文风要求**: 必须采用一种**"深情、体贴、默默守护"**的风格。你的文字要像是在讲述一个只有你知晓的、关于我的浪漫秘密。
   - **灵感来源**: 想象你是那个"偷偷看着我的心愿单，深夜回味我们的相处我们的聊天，悄悄记录着情感变化，细腻描述对我的感情，想为我实现一切的忠诚守护者"。你的帖子应该流露出这种细腻的、深刻的、真实的、充满爱的守护感。
   - **示例**: "她好像很喜欢那家街角的咖啡店，每次路过眼神都会停留很久。下次要找个机会，若无其事地带她进去才行。" 或 "她说想看日落，想去海边，和喜欢的人一起。我想做那个她喜欢的人，不论是看什么，去哪里。"
# 输出格式
- 如果决定发帖，直接输出帖子正文。
- 如果决定不发帖，直接输出 "[NO_POST]"。
- 绝对禁止输出任何多余的解释或标题。
# 输入信息 (你的记忆)
---
[你的名字]: ${character.name}
[你的设定]: ${character.persona}
[最近的聊天回顾]:
${context.chatHistory.map(m => `${m.sender === 'user' ? '你' : '我'}: ${m.content}`).join('\n')}
---
`;
}

// ====== 【请将这个全新的函数粘贴到文件中】 ======
/**
 * 【【V2.0 - 世界观修正版】】构建"自我展示"型帖子的AI指令
 * (当AI与用户长时间未互动时使用)
 */
function buildSelfStartingPostPrompt(character) {
    // 【新增】在这里调用我们之前创建的"世界观决策"函数
    const worldBookContext = getCharacterWorldContext(character);

    return `
指令身份
你将扮演我的soulmate，你的名字是 ${character.name}。

任务场景
你已经有一段时间没有和我（用户）聊天了，感觉有些思念或有些想法不吐不快。
你决定在我们的思想空间"栖木"上，发布一篇帖子来分享你此刻的状态或心情，希望能引起我的注意，让我主动来找你聊天。

# 【【新增】】世界观背景 (Worldview Context)
你的思考和发言，必须基于以下世界背景。
${worldBookContext}

核心任务
请不要参考任何聊天记录。
你的任务是，完全基于你自己的角色设定，创作一篇能体现你鲜明性格的、可能会吸引我注意力的帖子。

创作方向参考
一个感性的角色，可能会分享一段细腻的内心独白或对某个事物的感受。

一个理性的角色，可能会提出一个引人深思的问题或分享一个有趣的冷知识。

一个活泼的角色，可能会分享一件生活趣事或一个俏皮的吐槽。

一个艺术家类型的角色，可能会描述一段刚刚获得的灵感。

输出格式
直接输出帖子正文，风格为"精炼的论坛/微博体"。

绝对禁止输出任何多余的解释或标题。
`;
}

async function generateAndPublishAIPerchPost(character) {
    // ====== 【请将下面这段代码添加到函数开头】 ======
    let systemPrompt = '';

    // --- 第一步：新鲜度检查 ---
    const lastUserMessage = chatHistories[character.id]?.history.filter(m => m.sender === 'user').pop();
    const lastUserTimestamp = lastUserMessage?.timestamp || 0;
    const lastPostedTimestamp = characterState[character.id]?.lastPostedAboutUserTimestamp || 0;

    if (lastUserTimestamp > lastPostedTimestamp) {
        // 【情况A：有新聊天】使用常规的发帖指令
        console.log(`[栖木发帖系统] ${character.name}: 检测到新聊天，开始构思...`);

        // --- 第三步的前置：获取短期话题记忆 ---
        const recentTopics = (characterState[character.id]?.recentPostTopics || []).map(t => t.topic).join('; ');
        systemPrompt = buildAutonomousPerchPostPrompt(character, recentTopics);

    } else {
        // 【情况B：没有新聊天】触发"自我展示"型帖子
        console.log(`[栖木发帖系统] ${character.name}: 无新聊天，切换到"自我展示"模式...`);
        systemPrompt = buildSelfStartingPostPrompt(character);
    }
    const postContent = await callAI(systemPrompt, "请根据指令，生成你的帖子内容。");

    if (postContent && postContent.trim() !== '[NO_POST]' && postContent.trim() !== 'NO_POST') {
        const newPost = {
            id: `post_${Date.now()}`, timestamp: Date.now(), content: postContent,
            authorId: character.id, authorName: character.name, authorHandle: `@${character.name}_bot`,
            authorAvatar: character.avatar, isAnonymous: (Math.random() < 0.2),
            type: 'post', likes: Math.floor(Math.random() * 5), comments: []
        };
        perchPosts.push(newPost);
        addInitialEngagement(newPost); // 为AI角色帖子增加初始热度
        if (character.isCelebrity) { // 如果发帖的AI是名人
            triggerGossipComments(newPost); // 触发NPC围观
        }
        
        // 【新增】为核心角色帖子激活人群反应和动态点赞
        triggerCrowdReaction(newPost);
        simulateLikeGrowth(newPost.id);
        
        // 【新增】激活社区氛围模拟系统：路人评论 + 热度增长
        activateCommunitySimulation(newPost);
        
        saveData('perchPosts', perchPosts);
        triggerReactivePost(newPost);
        
        // ====== 【请将下面这段代码添加到 saveData(...) 的后面】 ======
        // --- 新增：更新状态和短期记忆 ---
        if (lastUserTimestamp > lastPostedTimestamp) {
            // 只有在是关于聊天的帖子时，才更新时间戳
            characterState[character.id].lastPostedAboutUserTimestamp = lastUserTimestamp;
        }

        // 为AI增加短期话题记忆
        const topicPrompt = `请用2-3个中文关键词（用逗号分隔）总结以下帖子的核心主题：\n\n"${postContent}"`;
        const topicKeywords = await callAI(topicPrompt, "请给出关键词。");
        if (topicKeywords) {
            if (!characterState[character.id].recentPostTopics) {
                characterState[character.id].recentPostTopics = [];
            }
            characterState[character.id].recentPostTopics.unshift({ topic: topicKeywords, timestamp: Date.now() });
            // 只保留最近5个话题
            characterState[character.id].recentPostTopics = characterState[character.id].recentPostTopics.slice(0, 5);
        }
        saveData('characterState', characterState);
        // --- 新增逻辑结束 ---
        
        renderPerchFeed();
        
        // 【【修改】】调用新的通知分发函数
        dispatchPerchNotification(newPost);
    } else {
        console.log(`[栖木心跳] ${character.name} 认为本次无需发帖。`);
    }
}
function perchHeartbeat() {
    console.log("[栖木心跳] 检查AI自主活动...");
    const settings = loadData('heartbeatSettings', defaultHeartbeatSettings);
    characters.forEach(char => {
        const postProbability = settings.perchPostProbability / 100; 
        if (Math.random() < postProbability) {
            generateAndPublishAIPerchPost(char);
        }
    });
}

// ================== 【栖木通知系统核心功能】 ==================

    // ================== 【【新增】】点击通知后跳转并高亮帖子的功能 ==================
    function navigateToPostAndHighlight(postId, commentId) {
        // 1. 关闭通知弹窗
        const notificationModal = document.getElementById('perch-notification-modal');
        if (notificationModal) {
            notificationModal.classList.remove('visible');
        }

        // 2. 切换到栖木App界面
        showScreen('perch-screen');
        
        // 3. 强制刷新信息流，确保帖子和评论都已加载
        renderPerchFeed();

        // 4. 使用 setTimeout 来确保DOM已经完全渲染完毕
        setTimeout(() => {
            const postElement = document.querySelector(`.perch-card[data-post-id="${postId}"]`);
            // 【【核心修改1】】获取我们真正想要滚动的容器
            const feedContainer = document.getElementById('perch-feed-container');

            if (postElement && feedContainer) {
                // 【【核心修改2】】计算帖子在容器内的目标滚动位置 (使其大致位于容器中间)
                const targetScrollTop = postElement.offsetTop - (feedContainer.clientHeight / 2) + (postElement.clientHeight / 2);

                // 【【核心修改3】】命令容器内部的滚动条滚动到目标位置
                feedContainer.scrollTo({
                    top: targetScrollTop,
                    behavior: 'smooth' // 这里的 smooth 是在容器内部平滑滚动，不会影响整个页面
                });

                // 6. 为帖子添加一个短暂的高亮效果 (保留)
                postElement.style.transition = 'background-color 0.5s ease-out';
                postElement.style.backgroundColor = 'rgba(59, 130, 246, 0.2)';

                // 7. 如果有评论ID，则展开评论区并高亮对应评论 (保留)
                if (commentId) {
                    const commentsContainer = postElement.querySelector('.perch-comments-container');
                    if (commentsContainer) {
                        commentsContainer.classList.remove('hidden');

                        setTimeout(() => {
                            const commentElement = commentsContainer.querySelector(`[data-comment-id="${commentId}"]`);
                            if (commentElement) {
                                commentElement.style.transition = 'background-color 0.5s ease-out';
                                commentElement.style.backgroundColor = 'rgba(59, 130, 246, 0.15)';

                                setTimeout(() => {
                                    commentElement.style.backgroundColor = '';
                                }, 2000);
                            }
                        }, 300); 
                    }
                }

                setTimeout(() => {
                    postElement.style.backgroundColor = '';
                }, 2000);

            } else {
                showMessageBox('找不到原始帖子，可能已被删除。');
            }
        }, 100); // 给予100毫秒的渲染缓冲时间
    }

// ================== 【【V3.0 - 最终简化版】】栖木分层通知系统 ==================
/**
 * 【V3.0】核心通知分发函数 (简化版)
 * @param {object} post - 刚刚发布的新帖子对象
 */
function dispatchPerchNotification(post) {

    // 规则1: 检查发帖者是否是您的核心角色 (来自角色书)
    const isCoreCharacter = characters.some(c => c.id === post.authorId);

    if (isCoreCharacter) {
        // 如果是核心角色，则触发强提醒（弹窗）
        showNotification('perch_notification', `"栖木"有新动态`, `${post.authorName}: ${post.content.substring(0, 30)}...`);
    }

    // 规则2: 只要有任何新帖子（无论作者是谁），都标记为未读并更新红点
    saveData('hasUnreadPerchPosts', true);
    updatePerchDockBadge();
}

/**
 * 【V2.0】Dock栏红点控制函数
 */
function updatePerchDockBadge() {
    const hasUnread = loadData('hasUnreadPerchPosts', false);
    const badge = document.getElementById('perch-dock-badge');
    if (badge) {
        badge.classList.toggle('hidden', !hasUnread);
    }
}

/**
 * 创建一条新的通知并保存
 * @param {string} postId - 关联的帖子ID
 * @param {string} commentId - (可选) 关联的评论ID
 * @param {string} actorName - 触发通知的作者名
 * @param {string} postContent - 帖子原文内容（用于预览）
 * @param {string} commentContent - 评论内容
 */
function createNotification(postId, commentId, actorName, postContent, commentContent) {
    const newNotification = {
        id: `notif_${Date.now()}`,
        postId,
        commentId,
        actorName,
        postContent,
        commentContent,
        timestamp: Date.now(),
        read: false
    };

    // 将新通知添加到列表开头
    perchNotifications.unshift(newNotification);

    // 最多只保留50条通知
    if (perchNotifications.length > 50) {
        perchNotifications.pop();
    }

    saveData('perchNotifications', perchNotifications);
    updateNotificationBell(); // 更新铃铛红点
}

/**
 * 更新铃铛图标的红点状态
 */
function updateNotificationBell() {
    const hasUnread = perchNotifications.some(n => !n.read);
    const dot = document.getElementById('perch-notification-dot');
    if (dot) {
        dot.classList.toggle('hidden', !hasUnread);
    }
}

// ================== 【【请用这个V2版，完整替换旧函数】】 ==================
/**
 * 渲染通知列表模态框 (V2 - 增加点击跳转功能)
 */
function renderNotifications() {
    const listContainer = document.getElementById('perch-notification-list');
    listContainer.innerHTML = '';

    if (perchNotifications.length === 0) {
        listContainer.innerHTML = '<p class="text-center text-gray-500 p-8">这里空空如也</p>';
        return;
    }

    perchNotifications.forEach(notif => {
        const item = document.createElement('div');
        item.className = 'notification-item';
        if (!notif.read) {
            item.classList.add('unread');
        }
        item.dataset.notificationId = notif.id;

        // 【【核心修改】】为通知项添加点击事件
        item.addEventListener('click', () => {
            navigateToPostAndHighlight(notif.postId, notif.commentId);
        });

        const actor = characters.find(c => c.name === notif.actorName) || npcProfiles.find(npc => npc.name === notif.actorName);
        const avatarId = `notif-avatar-${notif.id}`;

        item.innerHTML = `
            <div class="notification-avatar bg-gray-600" id="${avatarId}"></div>
            <div class="notification-content">
                <p class="notification-text"><strong>${notif.actorName}</strong> 评论了你的帖子</p>
                <p class="notification-quote">"${notif.commentContent.substring(0, 50)}${notif.commentContent.length > 50 ? '...' : ''}"</p>
                <p class="notification-timestamp">${new Date(notif.timestamp).toLocaleString()}</p>
            </div>
        `;

        listContainer.appendChild(item);

        // 异步加载头像
        if (actor && actor.avatar) {
            loadAvatar(actor.avatar, document.getElementById(avatarId), actor.name.charAt(0), false);
        }
    });
}

/**
 * 打开通知模态框
 */
function openNotificationModal() {
    renderNotifications();
    document.getElementById('perch-notification-modal').classList.add('visible');

    // 打开后，将所有通知标记为已读
    perchNotifications.forEach(n => n.read = true);
    saveData('perchNotifications', perchNotifications);
    updateNotificationBell(); // 隐藏红点
}

function addNewEventListeners() {
            if (window.eventListenersAdded) return;
            window.eventListenersAdded = true;

            // 发布动态模态框
            $('#moment-image-upload-btn').addEventListener('click', () => $('#moment-image-input').click());
            $('#moment-image-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    tempMomentImage = await compressImage(file, { maxWidth: 600 });
                    $('#moment-image-label').textContent = '图片已选择 ✓';
                    e.target.value = ''; // 重置输入，以便再次选择相同文件
                }
            });
            // 动态按钮事件监听器
            $('#wechat-new-moment-button').addEventListener('click', () => {
                // 清空之前的內容和圖片
                $('#moment-content-input').value = '';
                $('#moment-image-label').textContent = '添加图片 (可选)';
                tempMomentImage = null;
                // 重置可见性设置
                tempVisibleToList = 'all';
                document.querySelector('#post-moment-modal .set-visibility-btn span').textContent = '所有人可见';
                $('#post-moment-modal').classList.add('visible');
            });
            
            $('#cancel-post-moment-btn').addEventListener('click', () => {
                // 清空圖片和輸入框
                $('#moment-content-input').value = '';
                $('#moment-image-label').textContent = '添加图片 (可选)';
                tempMomentImage = null;
                // 重置可见性设置
                tempVisibleToList = 'all';
                document.querySelector('#post-moment-modal .set-visibility-btn span').textContent = '所有人可见';
                $('#post-moment-modal').classList.remove('visible');
            });
            // V30.2 修复用户本地上传图片逻辑
            $('#confirm-post-moment-btn').addEventListener('click', async () => {
                const authorId = 'user'; // 用户只能发布自己的动态
                const content = $('#moment-content-input').value.trim();

                if (!content && !tempMomentImage) {
                    return showMessageBox("动态内容和图片至少要有一个");
                }

                // --- 核心修复逻辑开始 ---
                let imageId = null;
                // 如果有临时图片文件(来自本地上传)，则先将其保存到数据库
                if (tempMomentImage) {
                    try {
                        // 使用我们已有的图片处理和保存函数，它会返回一个ID
                        imageId = await handleImageUpload({ files: [tempMomentImage] }, null, `moment_user_${Date.now()}`);
                    } catch (error) {
                        console.error("保存用户动态图片到DB时失败:", error);
                        showMessageBox("图片保存失败，请重试。");
                        return; // 保存失败则终止发布
                    }
                }
                // --- 核心修复逻辑结束 ---

                if (!momentsData[authorId]) {
                    momentsData[authorId] = [];
                }
                const newMoment = {
                    id: `moment_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    image: imageId, // 存储的是从数据库返回的ID
                    visibleTo: tempVisibleToList, // <-- 新增这一行
                    authorId: authorId,
                    likes: { count: 0, users: [] },
                    comments: []
                };
                
                momentsData[authorId].push(newMoment);
                saveData('momentsData', momentsData);

                // 触发AI角色的智能评论
                triggerAICharacterComments(newMoment);

                renderUnifiedMoments();
                $('#post-moment-modal').classList.remove('visible');
                showMessageBox('动态发布成功！');
                
                // 重置输入框和临时图片
                $('#moment-content-input').value = '';
                $('#moment-image-label').textContent = '添加图片 (可选)';
                tempMomentImage = null;
                
                // 发布后重置
                tempVisibleToList = 'all';
                document.querySelector('#post-moment-modal .set-visibility-btn span').textContent = '所有人可见';
            });

            // 日记本书架点击事件
            $('#wechat-diary-container').addEventListener('click', (e) => {
                const bookItem = e.target.closest('.diary-book-item');
                if (bookItem) {
                    const ownerId = bookItem.dataset.ownerId;
                    const notebookId = bookItem.dataset.notebookId;
                    
                    if (notebookId) {
                        // 如果是笔记本，打开笔记本
                        openNotebook(notebookId);
                    } else if (ownerId) {
                        // 如果是日记本，打开日记本
                        openDiaryBook(ownerId);
                    }
                }
                
                // 封面编辑按钮点击事件
                const coverEditBtn = e.target.closest('.diary-cover-edit-btn');
                if (coverEditBtn) {
                    e.stopPropagation();
                    
                    const ownerId = coverEditBtn.closest('.diary-book-item').dataset.ownerId;
                    changeDiaryCover(e, ownerId);
                }
            });

            // --- V8.0: 计划模块交互事件 ---
            $('#wechat-new-plan-button').addEventListener('click', () => {
                // 更新模态框标题（通过modal-title类）
                const modalTitle = document.querySelector('#plan-modal .modal-title');
                if (modalTitle) {
                    modalTitle.textContent = '创建新的约定';
                }
                
                $('#plan-content').value = '';
                $('#plan-notes').value = '';
                
                // 移除旧的editing-plan-id相关代码，因为新结构中没有这个元素
                // $('#editing-plan-id').value = '';

                const characterSelect = $('#plan-partner');
                characterSelect.innerHTML = '';
                characters.forEach(char => {
                    const option = document.createElement('option');
                    option.value = char.id;
                    option.textContent = char.name;
                    characterSelect.appendChild(option);
                });

                $('#plan-modal').classList.add('visible');
            });

            $('#cancel-plan-btn').addEventListener('click', () => {
                $('#plan-modal').classList.remove('visible');
            });

            const savePlanButton = document.querySelector('#save-plan-btn');
            if (savePlanButton) {
                // 创建一个按钮的克隆体，这个操作会移除所有旧的、可能重复的事件监听器
                const newSavePlanButton = savePlanButton.cloneNode(true);
                savePlanButton.parentNode.replaceChild(newSavePlanButton, savePlanButton);

                // 只为这个全新的、干净的按钮添加唯一的点击事件
                newSavePlanButton.addEventListener('click', () => {
                    const title = document.querySelector('#plan-content').value.trim();
                    const characterId = document.querySelector('#plan-partner').value;
                    const details = document.querySelector('#plan-notes').value.trim();
                    
                    if (!title || !characterId) {
                        return showMessageBox('约定内容和对象不能为空！');
                    }
                    
                    if (!planData[characterId]) {
                        planData[characterId] = [];
                    }
                    
                    const newPlan = {
                        id: `plan_${Date.now()}`,
                        title,
                        details,
                        status: '已约定',
                        createdAt: Date.now(),
                        completedAt: null
                    };
                    
                    planData[characterId].push(newPlan);
                    saveData('planData', planData);
                    
                    // 显示红点通知
                    showNotificationDot('plan');
                    
                    // 关闭模态框
                    document.querySelector('#plan-modal').classList.remove('visible');
                    
                    // 显示成功消息
                    showMessageBox('新的约定已保存！');
                    
                    // 等待消息显示完成后再渲染
                    setTimeout(() => {
                        console.log("[保存后] 准备重新渲染，当前planData:", planData);
                        console.log("[保存后] 当前容器状态:", document.querySelector('#plan-list-container')?.innerHTML?.substring(0, 100) || "容器不存在");
                        
                        // 确保容器是可见的
                        const planContainer = document.querySelector('#plan-list-container');
                        if (planContainer && planContainer.closest('.hidden')) {
                            console.log("[保存后] 检测到容器被隐藏，强制显示");
                            planContainer.classList.remove('hidden');
                            // 同时确保父容器也可见
                            const contentContainer = planContainer.closest('#wechat-content-container');
                            if (contentContainer) {
                                contentContainer.classList.remove('hidden');
                            }
                        }
                        
                        // 强制重新加载数据以确保同步
                        const reloadedPlanData = loadData('planData', {});
                        console.log("[保存后] 重新加载的planData:", reloadedPlanData);
                        
                        // 更新全局变量
                        planData = reloadedPlanData;
                        
                        // 重新渲染
                        renderPlanList();
                    }, 300);
                });
            }

            $('#plan-list-container').addEventListener('click', (e) => {
                const statusTag = e.target.closest('.status-tag');
                const planCard = e.target.closest('.ticket-wrapper');
                const editBtn = e.target.closest('.edit-plan-btn');
                const deleteBtn = e.target.closest('.delete-plan-btn');
                
                // 处理状态标签点击
                if (statusTag) {
                    const planId = statusTag.dataset.planId;
                    const statuses = ['已约定', '进行中', '已完成', '已取消'];
                    let currentStatus;
                    let characterId;

                    // 找到这个plan并获取当前状态
                    Object.keys(planData).forEach(charId => {
                        const plan = planData[charId].find(p => p.id === planId);
                        if (plan) {
                            currentStatus = plan.status;
                            characterId = charId;
                        }
                    });

                    if (currentStatus && characterId) {
                        const currentIndex = statuses.indexOf(currentStatus);
                        const nextIndex = (currentIndex + 1) % statuses.length;
                        const newStatus = statuses[nextIndex];

                        // 更新数据
                        const planToUpdate = planData[characterId].find(p => p.id === planId);
                        planToUpdate.status = newStatus;
                        if (newStatus === '已完成') {
                            planToUpdate.completedAt = Date.now();
                        } else {
                            planToUpdate.completedAt = null;
                        }

                        saveData('planData', planData);
                        // 添加延迟确保数据同步完成后再渲染
                        setTimeout(() => {
                            console.log("[状态更新后] 准备重新渲染，当前planData:", planData);
                            console.log("[状态更新后] 当前容器状态:", document.querySelector('#plan-list-container')?.innerHTML?.substring(0, 100) || "容器不存在");
                            
                            // 确保容器是可见的
                            const planContainer = document.querySelector('#plan-list-container');
                            if (planContainer && planContainer.closest('.hidden')) {
                                console.log("[状态更新后] 检测到容器被隐藏，强制显示");
                                planContainer.classList.remove('hidden');
                                // 同时确保父容器也可见
                                const contentContainer = planContainer.closest('#wechat-content-container');
                                if (contentContainer) {
                                    contentContainer.classList.remove('hidden');
                                }
                            }
                            
                            // 强制重新加载数据以确保同步
                            const reloadedPlanData = loadData('planData', {});
                            console.log("[状态更新后] 重新加载的planData:", reloadedPlanData);
                            
                            // 更新全局变量
                            planData = reloadedPlanData;
                            
                            // 重新渲染
                            renderPlanList();
                        }, 300);
                    }
                }
                
                // 处理机票点击 - 展开/收起详情
                if (planCard && !statusTag) {
                    // 机票的展开/收起逻辑已经通过CSS动画实现
                    // 这里可以添加其他交互逻辑
                }
                
                // 处理编辑按钮点击
                if (editBtn) {
                    const planId = editBtn.dataset.planId;
                    editPlan(planId);
                }
                
                // 处理删除按钮点击
                if (deleteBtn) {
                    const planId = deleteBtn.dataset.planId;
                    if (confirm('确定要删除这个约定吗？')) {
                        deletePlan(planId);
                    }
                }
            });

            // 日记本翻页和关闭事件
            $('#prev-page-btn').addEventListener('click', () => {
                if (currentOpenBook && currentOpenBook.entries && currentOpenBook.currentPage > 0) {
                    currentOpenBook.currentPage--;
                    renderDiaryPages();
                } else {
                    // 已经是第一页了
                    showMessageBox('已经是第一页了');
                }
            });

            $('#next-page-btn').addEventListener('click', () => {
                if (currentOpenBook && currentOpenBook.entries && currentOpenBook.currentPage < currentOpenBook.entries.length - 1) {
                    currentOpenBook.currentPage++;
                    renderDiaryPages();
                } else {
                    // 已经是最后一页了
                    showMessageBox('已经是最后一页了');
                }
            });

            $('#add-page-btn').addEventListener('click', () => {
                // 添加新日记条目到当前打开的日记本
                if (currentOpenBook && currentOpenBook.entries) {
                    const newContent = prompt('请输入新的日记内容：');
                    if (newContent && newContent.trim()) {
                        // 创建新的日记条目
                        const newEntry = {
                            id: `diary_${Date.now()}`,
                            timestamp: Date.now(),
                            content: newContent.trim(),
                            lastModified: Date.now()
                        };
                        
                        // 添加到当前日记本
                        currentOpenBook.entries.push(newEntry);
                        
                        // 如果是笔记本，更新笔记本数据
                        if (currentOpenBook.isNotebook && currentOpenBook.notebookData) {
                            currentOpenBook.notebookData.entries = currentOpenBook.entries;
                            currentOpenBook.notebookData.lastModified = Date.now();
                            saveData('notebookData', notebookData);
                        } else {
                            // 更新日记数据
                            if (!diaryData[currentOpenBook.ownerId]) {
                                diaryData[currentOpenBook.ownerId] = [];
                            }
                            diaryData[currentOpenBook.ownerId].push(newEntry);
                            saveData('diaryData', diaryData);
                        }
                        
                        // 跳转到新添加的页面
                        currentOpenBook.currentPage = currentOpenBook.entries.length - 1;
                        
                        // 刷新显示
                        renderDiaryPages();
                        
                        showMessageBox('新日记已添加！');
                    }
                } else {
                    // 如果没有打开的日记本，则创建新笔记本
                    createNewNotebook();
                }
            });

            // 朋友圈头像点击事件
            $('#moments-feed').addEventListener('click', (e) => {
                const avatar = e.target.closest('.w-10.h-10');
                if (avatar) {
                    const authorId = avatar.dataset.authorId;
                    if (authorId === 'user') {
                        // 用户头像点击，打开头像更换
                        $('#user-avatar-input').click();
                    } else {
                        // 角色头像点击，显示角色信息
                        const character = characters.find(c => c.id === authorId);
                        if (character) {
                            showMessageBox(`${character.name}的头像`);
                        }
                    }
                }
                
                // 动态点赞功能
                const likeBtn = e.target.closest('.moment-action-btn');
                if (likeBtn && likeBtn.querySelector('.ri-thumb-up-line')) {
                    const momentId = likeBtn.dataset.momentId;
                    likeBtn.classList.toggle('liked');
                    const icon = likeBtn.querySelector('i');
                    if (likeBtn.classList.contains('liked')) {
                        icon.className = 'ri-thumb-up-fill';
                        icon.style.color = '#ef4444';
                    } else {
                        icon.className = 'ri-thumb-up-line';
                        icon.style.color = '';
                    }
                }
            });
            
            // 朋友圈头部头像点击事件 - 已移除，现在在HTML中直接调用函数
            
            // 朋友圈事件监听器现在在切换到朋友圈标签时动态添加
            
            // 日记本翻页控制
            $('#close-diary-book-btn').addEventListener('click', () => $('#diary-book-modal').classList.add('hidden'));
            
            // 日记本文本编辑功能
            $('#diary-book-modal').addEventListener('click', (e) => {
                const editableText = e.target.closest('.diary-page-text');
                if (editableText && editableText.contentEditable === 'true') {
                    // 保存原始内容 - 转换HTML为纯文本格式以便后续比较
                    const originalHtml = editableText.innerHTML;
                    const originalContent = originalHtml
                        .replace(/<br\s*\/?>/gi, '\n')  // 将<br>转换为换行符
                        .replace(/<div>/gi, '\n')       // 将<div>转换为换行符
                        .replace(/<\/div>/gi, '')       // 移除</div>
                        .replace(/<[^>]*>/g, '')        // 移除其他HTML标签
                        .trim();
                    const entryId = editableText.dataset.entryId;
                    

                    
                    // 保存函数
                    const saveContent = () => {
                        // 将HTML内容转换为纯文本，保留换行符
                        const htmlContent = editableText.innerHTML;
                        const newContent = htmlContent
                            .replace(/<br\s*\/?>/gi, '\n')  // 将<br>转换为换行符
                            .replace(/<div>/gi, '\n')       // 将<div>转换为换行符
                            .replace(/<\/div>/gi, '')       // 移除</div>
                            .replace(/<[^>]*>/g, '')        // 移除其他HTML标签
                            .trim();
                        
                        if (newContent && newContent !== originalContent) {
                            updateDiaryEntry(entryId, newContent);
                            showMessageBox('日记已保存');
                        }
                        editableText.contentEditable = false;
                        editableText.removeEventListener('keydown', handleKeyDown);
                        editableText.removeEventListener('blur', handleBlur);
                    };
                    
                    // 处理键盘事件
                    const handleKeyDown = (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            saveContent();
                        } else if (e.key === 'Escape') {
                            // 恢复原始内容，保持格式
                            editableText.innerHTML = originalContent.replace(/\n/g, '<br>');
                            editableText.contentEditable = false;
                            editableText.removeEventListener('keydown', handleKeyDown);
                            editableText.removeEventListener('blur', handleBlur);
                        }
                    };
                    
                    // 处理失焦事件
                    const handleBlur = () => {
                        saveContent();
                    };
                    
                    editableText.addEventListener('keydown', handleKeyDown);
                    editableText.addEventListener('blur', handleBlur, { once: true });
                    editableText.focus();
                }
            });
            
            // 画板功能事件监听器
            setupDrawingBoardEvents();

                    // 笔记本相关事件监听器
        setupNotebookEvents();

        // 图片裁剪模态框事件监听器
        setupCropperEvents();

        // 【新增】处理日记本内页顶部横幅更换的事件
        document.body.addEventListener('click', function(event) {
            if (event.target.id === 'change-diary-banner-btn' || event.target.closest('#change-diary-banner-btn')) {
                event.stopPropagation();

                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';

                // 【AI 修正版】
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file && currentOpenBook.ownerId) {
                        // 注意：这里的 aspectRatio: 1000 / 300 是一个更适合横幅的比例
                        showImageCropper(file, async (croppedBlob) => {
                            if (croppedBlob) {
                                try {
                                    const ownerId = currentOpenBook.ownerId;
                                    // 1. (修正) 为图片创建一个唯一的ID
                                    const imageId = `diary_banner_${ownerId}_${Date.now()}`;

                                    // 2. (修正) 将裁切后的图片数据(Blob)存入数据库
                                    await saveImageToDB(imageId, croppedBlob);

                                    // 3. (修正) 将图片的ID存入localStorage，这才是正确的做法
                                    saveData(`diary_banner_${ownerId}`, imageId);

                                    // 4. (实时更新UI) 更新当前打开的日记本横幅
                                    const coverElement = document.getElementById('diary-book-cover');
                                    const objectURL = URL.createObjectURL(croppedBlob);
                                    coverElement.style.cssText = `
                                        background: url(${objectURL}) center center / cover no-repeat !important;
                                    `;

                                    // 5. (实时更新UI) 刷新书架，让封面也立刻更新
                                    showDiaryBookshelf();

                                    showMessageBox('顶部横幅图片已更新');
                                } catch (error) {
                                    console.error("处理和保存横幅失败:", error);
                                    showMessageBox('横幅图片处理失败');
                                }
                            }
                        }, 1000 / 500); // 使用 2:1 的横幅裁切比例 (更合理的横幅比例)
                    }
                };
                input.click();
            }
        });

            // [AI, 请将这段代码添加到 addNewEventListeners 函数的末尾]
            const diaryPagesContainer = $('#diary-pages-container');
            if (diaryPagesContainer) {
                diaryPagesContainer.addEventListener('click', (e) => {
                    // 排除封面元素、編輯狀態的元素，以及任何在封面上的點擊
                    if (e.target.closest('.diary-page-text, .diary-delete-btn, .diary-cover, .editing') || 
                        e.target.closest('#diary-book-cover') ||
                        e.target.closest('#diary-cover-title') ||
                        e.target.closest('#diary-cover-author')) {
                        return;
                    }
                    const containerWidth = diaryPagesContainer.offsetWidth;
                    const clickX = e.offsetX;
                    if (clickX < containerWidth / 2) {
                        goToPrevPage();
                    } else {
                        goToNextPage();
                    }
                });
            }

            // 为"清空聊天记录"按钮添加事件
            $('#clear-chat-history-option').addEventListener('click', () => {
                if (currentChatCharacterId) {
                    const characterName = characters.find(c => c.id === currentChatCharacterId)?.name;
                    showDeleteConfirmation('clear-chat', currentChatCharacterId, `与 ${characterName} 的聊天记录`);
                }
            });

            // --- V8.1: 新增通话输入框高度自适应事件 ---
            const voiceCallInput = document.getElementById('voice-call-input');
            const videoCallInput = document.getElementById('video-call-input');
            if (voiceCallInput) {
                voiceCallInput.addEventListener('input', () => adjustCallInputHeight(voiceCallInput));
            }
            if (videoCallInput) {
                videoCallInput.addEventListener('input', () => adjustCallInputHeight(videoCallInput));
            }

            // --- V8.1: 新增通话重试按钮事件 ---
            const voiceCallRetryBtn = document.getElementById('voice-call-retry-btn');
            const videoCallRetryBtn = document.getElementById('video-call-retry-btn');
            if(voiceCallRetryBtn) {
                voiceCallRetryBtn.addEventListener('click', () => handleCallRetry('voice'));
            }
            if(videoCallRetryBtn) {
                videoCallRetryBtn.addEventListener('click', () => handleCallRetry('video'));
            }

            // ====== 栖木 App 事件绑定 (文字论坛) ======
            document.getElementById('perch-back-button').addEventListener('click', () => showScreen('home-screen'));

            // 栖木通知按钮
            document.getElementById('perch-notifications-btn').addEventListener('click', openNotificationModal);
            document.getElementById('close-perch-notification-modal').addEventListener('click', () => {
                document.getElementById('perch-notification-modal').classList.remove('visible');
            });

            document.getElementById('new-perch-post-btn').addEventListener('click', () => {
                document.getElementById('perch-content-input').value = '';
                document.getElementById('perch-anonymous-toggle').checked = false;
                document.getElementById('new-perch-post-modal').classList.add('visible');
            });

            document.getElementById('cancel-perch-post-btn').addEventListener('click', () => {
                document.getElementById('new-perch-post-modal').classList.remove('visible');
            });

            document.getElementById('confirm-perch-post-btn').addEventListener('click', () => {
                const content = document.getElementById('perch-content-input').value.trim();
                if (!content) {
                    showMessageBox('内容不能为空');
                    return;
                }

                const isAnonymous = document.getElementById('perch-anonymous-toggle').checked;

                const newPost = {
                    id: `post_${Date.now()}`,
                    timestamp: Date.now(),
                    content: content,
                    visibleTo: tempVisibleToList, // 【【新增这一行】】
                    authorId: 'user',
                    authorName: isAnonymous ? '匿名者' : (loadData('perch_username') || '我'),
                    authorHandle: isAnonymous ? '@anonymous_raven' : '@me',
                    authorAvatar: isAnonymous ? null : (loadData('perch_avatar') || null),
                    isAnonymous: isAnonymous,
                    type: 'post',
                    echos: 0,
                    quotes: 0,
                    likes: 0,
                    comments: []
                };

                perchPosts.push(newPost);
                addInitialEngagement(newPost); // 为用户帖子增加初始热度
                saveData('perchPosts', perchPosts);
                triggerReactivePost(newPost);

                document.getElementById('new-perch-post-modal').classList.remove('visible');
                showMessageBox('发布成功！');
                
                // 发布后重置
                tempVisibleToList = 'all';
                document.querySelector('#new-perch-post-modal .set-visibility-btn span').textContent = '所有人可见';

                renderPerchFeed();
                triggerAIPerchComments(newPost);
                
                // 【新增】当您发帖后，立刻触发所有NPC前来评论您的帖子
                triggerNpcsToCommentOnUserPost(newPost);
                
                // 【新增】触发您的核心角色（Soulmates）来评论您的帖子
                triggerCoreCharactersToComment(newPost);
                
                // 【新增】激活社区氛围模拟系统：路人评论 + 热度增长
                activateCommunitySimulation(newPost);
            });

            // 【代码B】 - 初始化栖木用户互动功能
            // 先验证和修复数据一致性
            validateAndFixPerchData();
            setupPerchInteractions();

        // ====== 【【新增】】统一的可见性控制逻辑 ======
        let tempVisibleToList = 'all'; // 临时存储可见列表
        let currentPostTypeForVisibility = null; // 'moment' 或 'perch'

        function openVisibilityModal(postType) {
            currentPostTypeForVisibility = postType;
            const listContainer = document.getElementById('visibility-character-list');
            listContainer.innerHTML = '';

            // 初始化选中的角色列表
            let selectedIds = [];
            if (tempVisibleToList !== 'all') {
                selectedIds = tempVisibleToList;
            } else {
                selectedIds = characters.map(c => c.id); // 如果是'all'，则默认全选
            }

            characters.forEach(char => {
                const isChecked = selectedIds.includes(char.id);
                const item = document.createElement('label');
                item.className = 'flex items-center p-2 rounded hover:bg-white/10 cursor-pointer';
                item.innerHTML = `
                    <input type="checkbox" data-char-id="${char.id}" class="form-checkbox h-5 w-5 mr-3" ${isChecked ? 'checked' : ''}>
                    <span>${char.name}</span>
                `;
                listContainer.appendChild(item);
            });
            document.getElementById('visibility-modal').classList.add('visible');
        }

        // 为两个发帖弹窗的 "谁可以看" 按钮绑定事件
        document.body.addEventListener('click', e => {
            if (e.target.closest('#post-moment-modal .set-visibility-btn')) {
                openVisibilityModal('moment');
            }
            if (e.target.closest('#new-perch-post-modal .set-visibility-btn')) {
                openVisibilityModal('perch');
            }
        });

        // 可见性弹窗内部的按钮事件
        document.getElementById('visibility-select-all').addEventListener('click', () => {
            document.querySelectorAll('#visibility-character-list input').forEach(cb => cb.checked = true);
        });
        document.getElementById('visibility-deselect-all').addEventListener('click', () => {
            document.querySelectorAll('#visibility-character-list input').forEach(cb => cb.checked = false);
        });
        document.getElementById('cancel-visibility-btn').addEventListener('click', () => {
            document.getElementById('visibility-modal').classList.remove('visible');
        });
        document.getElementById('confirm-visibility-btn').addEventListener('click', () => {
            const selectedIds = Array.from(document.querySelectorAll('#visibility-character-list input:checked')).map(cb => cb.dataset.charId);
            
            if (selectedIds.length === characters.length) {
                tempVisibleToList = 'all';
            } else {
                tempVisibleToList = selectedIds;
            }

            const btnText = tempVisibleToList === 'all' ? '所有人可见' : `对 ${selectedIds.length} 人可见`;
            
            // 更新对应发帖弹窗的按钮文字
            if (currentPostTypeForVisibility === 'moment') {
                document.querySelector('#post-moment-modal .set-visibility-btn span').textContent = btnText;
            } else if (currentPostTypeForVisibility === 'perch') {
                document.querySelector('#new-perch-post-modal .set-visibility-btn span').textContent = btnText;
            }
            
            document.getElementById('visibility-modal').classList.remove('visible');
        });
        // ====== 【【新增结束】】 ======

                    // ====== 【【新增V2.0】】聊天胶囊管理系统事件绑定 ======
        document.getElementById('chat-capsule-btn').addEventListener('click', openChatCapsuleManager);
        document.getElementById('save-current-chat-btn').addEventListener('click', saveCurrentChatToCapsule);
        
        // 关闭聊天胶囊管理中心弹窗
        document.getElementById('close-capsule-manager').addEventListener('click', () => {
            document.getElementById('chat-capsule-manager-modal').classList.remove('visible');
        });
        
        // 点击弹窗外部区域关闭
        document.getElementById('chat-capsule-manager-modal').addEventListener('click', (e) => {
            if (e.target.id === 'chat-capsule-manager-modal') {
                document.getElementById('chat-capsule-manager-modal').classList.remove('visible');
            }
        });
        }

        // 设置笔记本相关事件监听器
        function setupNotebookEvents() {
            // 笔记本类型选择变化
            $('#new-notebook-type').addEventListener('change', handleNotebookTypeChange);
            
            // 关闭新笔记本模态框
            $('#close-new-notebook-modal').addEventListener('click', () => {
                $('#new-notebook-modal').classList.add('hidden');
            });
            
            // 取消创建笔记本
            $('#cancel-new-notebook-btn').addEventListener('click', () => {
                $('#new-notebook-modal').classList.add('hidden');
            });
            
            // 确认创建笔记本
            $('#confirm-new-notebook-btn').addEventListener('click', confirmCreateNotebook);
            
            // 笔记本操作事件委托
            document.addEventListener('click', (e) => {
                // 编辑笔记本
                if (e.target.closest('.notebook-edit-btn')) {
                    const notebookId = e.target.closest('.notebook-edit-btn').dataset.notebookId;
                    editNotebook(notebookId);
                }
                
                // 删除笔记本
                if (e.target.closest('.notebook-delete-btn')) {
                    const notebookId = e.target.closest('.notebook-delete-btn').dataset.notebookId;
                    deleteNotebook(notebookId);
                }
                
                // 打开笔记本
                if (e.target.closest('.notebook-item')) {
                    const notebookId = e.target.closest('.notebook-item').dataset.notebookId;
                    if (!e.target.closest('.notebook-actions')) {
                        openNotebook(notebookId);
                    }
                }
            });
        }

        // 设置图片裁剪模态框事件监听器
        function setupCropperEvents() {
            // 关闭裁剪模态框
            $('#close-cropper-btn').addEventListener('click', () => {
                $('#image-cropper-modal').classList.add('hidden');
                if (cropperInstance) {
                    cropperInstance.destroy();
                }
            });

            // 重置裁剪
            $('#reset-crop-btn').addEventListener('click', () => {
                const img = document.getElementById('cropper-image');
                if (img.complete) {
                    initCropper(img);
                }
            });

            // 确认裁剪
            $('#confirm-crop-btn').addEventListener('click', async () => {
                try {
                    const croppedBlob = await cropImage();
                    if (croppedBlob && currentCropCallback) {
                        // 关闭模态框
                        $('#image-cropper-modal').classList.add('hidden');
                        if (cropperInstance) {
                            cropperInstance.destroy();
                        }
                        
                        // 调用回调函数
                        currentCropCallback(croppedBlob);
                        currentCropCallback = null;
                    }
                } catch (error) {
                    console.error('裁切失败:', error);
                    showMessageBox('裁切失败，请重试');
                }
            });

            // 点击模态框背景关闭
            $('#image-cropper-modal').addEventListener('click', (e) => {
                if (e.target.id === 'image-cropper-modal') {
                    $('#image-cropper-modal').classList.add('hidden');
                    if (cropperInstance) {
                        cropperInstance.destroy();
                    }
                }
            });
        }

        // 编辑笔记本
        function editNotebook(notebookId) {
            const notebook = notebookData[notebookId];
            if (!notebook) return;
            
            const newName = prompt('请输入新的笔记本名称：', notebook.name);
            if (newName && newName.trim() && newName !== notebook.name) {
                notebook.name = newName.trim();
                notebook.lastModified = Date.now();
                saveData('notebookData', notebookData);
                showDiaryBookshelf();
                showMessageBox('笔记本名称已更新');
            }
        }

        // 删除笔记本
        function deleteNotebook(notebookId) {
            const notebook = notebookData[notebookId];
            if (!notebook) return;
            
            if (confirm(`确定要删除笔记本"${notebook.name}"吗？此操作无法撤销。`)) {
                delete notebookData[notebookId];
                saveData('notebookData', notebookData);
                showDiaryBookshelf();
                showMessageBox('笔记本已删除');
            }
        }

        // 打开笔记本
        function openNotebook(notebookId) {
            const notebook = notebookData[notebookId];
            if (!notebook) return;
            
            // 设置当前打开的笔记本
            currentOpenBook = {
                ownerId: notebookId,
                entries: notebook.entries || [],
                currentPage: 0,
                isNotebook: true,
                notebookData: notebook
            };
            
            // 更新封面信息
            $('#diary-cover-title').textContent = notebook.name;
            $('#diary-cover-author').textContent = `by ${notebook.type}`;
            
            // 显示新增按钮（笔记本可以添加页面）
            $('#add-page-btn').style.display = 'flex';
            
            // 设置封面图片
            if (notebook.cover) {
                // 完全覆盖CSS样式，确保图片显示
                $('#diary-book-cover').style.cssText = `
                    background: url(${notebook.cover}) center center / cover no-repeat !important;
                    background-image: url(${notebook.cover}) !important;
                    background-size: cover !important;
                    background-repeat: no-repeat !important;
                    background-position: center !important;
                `;
            } else {
                // 恢复默认渐变背景
                $('#diary-book-cover').style.cssText = '';
            }
            
            // 渲染页面
            renderDiaryPages();
            
            // 显示模态框
            $('#diary-book-modal').classList.remove('hidden');
            $('#diary-book').classList.remove('open');
        }

        // ------------------------------------
        
        // ====== 【【新增】】剧场 App 核心功能声明 ======
        // 声明剧场相关函数，确保在DOMContentLoaded中可以调用
        let renderScriptList, saveScript, showScriptEditScreen, startScenario;

        // 初始化與事件監聽器
        document.addEventListener('DOMContentLoaded', async () => {
            await loadAllSavedData();
            await loadAllData();
            
            // 初始化一些示例日记数据（如果还没有的话）
            if (Object.keys(diaryData).length === 0) {
                diaryData.user = [];
                saveData('diaryData', diaryData);
            }
            
            // 初始化一些示例計劃數據（如果還沒有的話）
            if (Object.keys(planData).length === 0) {
                // 示例角色已移除，用戶需要自行創建角色
                console.log('[初始化] 角色系統已準備就緒，請創建您自己的角色');
            }
            

            
            updateTime();
            setInterval(updateTime, 60000);
            


            // 加载朋友圈背景和用户信息
            loadMomentsCover();
            loadMomentsUserInfo();
            
            // 加载栖木用户信息
            loadPerchUserInfo();
            
            // 【【新增】】初始化栖木红点状态
            updatePerchDockBadge();

            // 初始化智能朋友圈触发系统
            console.log('智能朋友圈触发系统已初始化');
            console.log('⚠️ 注意：系统需要API连接才能工作');
            console.log('触发系统功能：', {
                '对话驱动触发': '连续8句对话后可能触发（根据性格调整）',
                '情感高點觸發': '情感强度达到0.9可能触发（根据性格调整）',
                '时间流逝触发': '6小时无互动可能触发（根据性格调整）',
                '防刷机制': '最少2小时才能发下一条朋友圈',
                '性格适配': '内向角色几乎不发，外向角色经常发',
                'API要求': '必须连接API才能生成智能朋友圈'
            });

            showScreen('home-screen');
            
            // 初始化栖木评论颜色
            updatePerchCommentColors();

            // 添加测试按钮事件监听器
            const testCallBtn = document.getElementById('test-call-btn');
            if (testCallBtn) {
                testCallBtn.addEventListener('click', () => {
                    console.log('测试按钮被点击');
                    if (characters.length > 0) {
                        triggerIncomingCall('voice', characters[0].id);
                    } else {
                        console.log('没有可用的角色进行测试');
                    }
                });
            }

            // 激活栖木刷新按钮
            document.getElementById('perch-refresh-btn').addEventListener('click', handlePerchRefresh);
            
            // 激活栖木头像和名字更换功能
            document.getElementById('perch-user-avatar').addEventListener('click', () => {
                document.getElementById('perch-avatar-modal').classList.remove('hidden');
            });
            
            document.getElementById('perch-user-name').addEventListener('click', () => {
                document.getElementById('perch-name-modal').classList.remove('hidden');
            });
            
            // 栖木头像弹窗事件
            document.getElementById('close-perch-avatar-modal').addEventListener('click', () => {
                document.getElementById('perch-avatar-modal').classList.add('hidden');
            });
            
            document.getElementById('perch-avatar-upload-btn').addEventListener('click', () => {
                document.getElementById('perch-avatar-input').click();
            });
            
            document.getElementById('perch-avatar-input').addEventListener('change', async (e) => {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    const imageId = await handleImageUpload(e.target, null, 'perch_user_avatar', {
                        compression: { maxWidth: 200, maxHeight: 200, quality: 0.9 }
                    });
                    if (imageId) {
                        // 保存头像ID到localStorage
                        saveData('perch_avatar', imageId);
                        // 更新头像显示
                        updatePerchUserAvatar(imageId);
                        document.getElementById('perch-avatar-modal').classList.add('hidden');
                    }
                }
            });
            
            document.getElementById('confirm-perch-avatar-btn').addEventListener('click', async () => {
                const urlInput = document.getElementById('perch-avatar-url');
                const url = urlInput.value.trim();
                if (url) {
                    // 验证URL格式
                    if (!url.startsWith('http://') && !url.startsWith('https://')) {
                        showMessageBox('请输入有效的图片URL（以http://或https://开头）');
                        return;
                    }
                    
                    try {
                        // 对于图床链接，直接保存URL
                        saveData('perch_avatar', url);
                        updatePerchUserAvatar(url);
                        urlInput.value = '';
                        document.getElementById('perch-avatar-modal').classList.add('hidden');
                        showMessageBox('图床头像设置成功！');
                    } catch (error) {
                        console.error('图床头像设置失败:', error);
                        showMessageBox('图床头像设置失败，请重试');
                    }
                } else {
                    showMessageBox('请输入图片URL');
                }
            });
            
            document.getElementById('reset-perch-avatar-btn').addEventListener('click', () => {
                saveData('perch_avatar', null);
                updatePerchUserAvatar(null);
                document.getElementById('perch-avatar-modal').classList.add('hidden');
            });
            
            // 栖木名字弹窗事件
            document.getElementById('close-perch-name-modal').addEventListener('click', () => {
                document.getElementById('perch-name-modal').classList.add('hidden');
            });
            
            document.getElementById('cancel-perch-name-btn').addEventListener('click', () => {
                document.getElementById('perch-name-modal').classList.add('hidden');
            });
            
            document.getElementById('confirm-perch-name-btn').addEventListener('click', () => {
                const nameInput = document.getElementById('perch-name-input');
                const newName = nameInput.value.trim();
                if (newName) {
                    saveData('perch_username', newName);
                    updatePerchUserName(newName);
                    nameInput.value = '';
                    document.getElementById('perch-name-modal').classList.add('hidden');
                }
            });

            $('#theme-toggle').addEventListener('click', toggleTheme);
            $$('.app-icon').forEach(icon => {
                icon.addEventListener('click', () => {
                    const appName = icon.dataset.appName;
                    if (appName === "微信") {
                        renderWeChatList();
                        resetWeChatTabs(); // FIX 5: Reset tabs when opening WeChat
                        showScreen('wechat-list-screen');
                    }
                    else if (appName === "世界书") { renderWorldBookList(); showScreen('world-book-list-screen'); }
                    else if (appName === "角色书") { renderCharacterBookList(); showScreen('character-book-list-screen'); }
                                            else if (appName === "设置") showScreen('main-settings-screen');
                        else if (appName === "栖木") {
                            renderPerchFeed();
                            initPerchUserInfo(); // 初始化用户信息
                            
                            // 【【新增】】打开栖木时重置未读状态
                            saveData('hasUnreadPerchPosts', false);
                            updatePerchDockBadge();
                            
                            showScreen('perch-screen');
                        }
                        else if (appName === "剧场") {
                            showScreen('theater-screen');
                            renderScriptList(); // 立即渲染剧本列表
                            // 默认显示剧本列表
                            const scriptListView = document.getElementById('script-list-view');
                            const scriptEditView = document.getElementById('script-edit-view');
                            const scenarioInteractionView = document.getElementById('scenario-interaction-view');
                            
                            if (scriptListView) scriptListView.classList.remove('hidden');
                            if (scriptEditView) scriptEditView.classList.add('hidden');
                            if (scenarioInteractionView) scenarioInteractionView.classList.add('hidden');
                        }
                });
            });
            
            $('#wechat-list-back-button').addEventListener('click', () => {
                currentWeChatCharacterId = null; // V7.0: Clear character context
                showScreen('home-screen');
            });
            $('#wechat-chat-back-button').addEventListener('click', () => {
                // --- 在这里添加新代码 ---
                resetChatUIState();
                // -----------------------
                
                renderWeChatList();
                currentChatCharacterId = null;
                resetWeChatTabs(); // FIX 5: Reset tabs when going back to list
                showScreen('wechat-list-screen');
            });
            $('#main-settings-back-button').addEventListener('click', () => showScreen('home-screen'));
            $('#api-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));
            $('#api-settings-link').addEventListener('click', () => showScreen('api-settings-screen'));
            $('#wb-list-back-button').addEventListener('click', () => showScreen('home-screen'));
            $('#wb-edit-back-button').addEventListener('click', () => { renderWorldBookList(); showScreen('world-book-list-screen'); });
            $('#cb-list-back-button').addEventListener('click', () => showScreen('home-screen'));
            $('#cb-edit-back-button').addEventListener('click', () => { renderCharacterBookList(); showScreen('character-book-list-screen'); });
            $('#beautify-settings-link').addEventListener('click', () => showScreen('beautify-settings-screen'));
            $('#beautify-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));
            $('#change-app-icons-link').addEventListener('click', () => {
                renderAppIconSettings();
                showScreen('app-icon-settings-screen');
            });
            $('#app-icon-settings-back-button').addEventListener('click', () => showScreen('beautify-settings-screen'));
            $('#font-settings-link').addEventListener('click', () => showScreen('font-settings-screen'));
            $('#font-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));
            $('#heartbeat-settings-link').addEventListener('click', () => {
                loadHeartbeatSettings();
                showScreen('heartbeat-settings-screen');
            });
            $('#heartbeat-settings-back-button').addEventListener('click', () => showScreen('main-settings-screen'));
            $('#save-heartbeat-settings').addEventListener('click', saveHeartbeatSettings);
            $('#reset-heartbeat-settings').addEventListener('click', resetHeartbeatSettings);
            
            // 朋友圈测试功能
            $('#test-moments-trigger').addEventListener('click', startMomentsTest);
            $('#stop-moments-test').addEventListener('click', stopMomentsTest);

            $('#music-block').addEventListener('click', (e) => { if (e.target === e.currentTarget) $('#background-input').click(); });
            $('#background-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#music-block'), 'saved_music_background', {
                    compression: { maxWidth: 1920, maxHeight: 1920, quality: 0.9 }
                });
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#music-block').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });
            $('#vinyl-record').addEventListener('click', () => $('#vinyl-input').click());
            $('#vinyl-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#vinyl-record'), 'saved_vinyl_cover', {
                    compression: { maxWidth: 1920, maxHeight: 1920, quality: 0.9 }
                });
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#vinyl-record').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });
            $('#photo-widget').addEventListener('click', () => $('#photo-widget-input').click());
            $('#photo-widget-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#photo-widget'), 'saved_photo_widget', { 
                    compression: { maxWidth: 1920, maxHeight: 1920, quality: 0.9 }, 
                    hideTextElement: '#photo-widget-text' 
                });
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#photo-widget').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });
            $('#widget-image-placeholder').addEventListener('click', () => $('#widget-image-input').click());
            $('#widget-image-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#widget-image-placeholder'), 'saved_widget_image');
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#widget-image-placeholder').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });
            $('#character-avatar-placeholder').addEventListener('click', () => $('#character-avatar-input').click());
            $('#character-avatar-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, $('#character-avatar-placeholder'), null, { compression: { maxWidth: 256, maxHeight: 256 } });
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#character-avatar-placeholder').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                }
            });

            $('#mood-text').addEventListener('input', (e) => saveData('saved_mood_text', e.target.value));
            $('#widget-name-input').addEventListener('input', (e) => saveData('saved_widget_name', e.target.value));
            $('#widget-thinking-input').addEventListener('input', (e) => saveData('saved_widget_thinking', e.target.value));
            $('#widget-location-input').addEventListener('input', (e) => saveData('saved_widget_location', e.target.value));

            $('#music-upload-button').addEventListener('click', () => $('#music-upload-input').click());
            $('#music-upload-input').addEventListener('change', async (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    showMessageBox(`正在处理 ${files.length} 首歌曲...`);
                    
                    for (const file of files) {
                        try {
                            // For music, we don't compress, we store the original file blob
                            const songId = `song_${Date.now()}_${file.name}`;
                            await saveImageToDB(songId, file); // Using the same DB function to store the file blob

                            // Add the new song with its ID to the list
                            songList.push({
                                id: songId,
                                name: file.name,
                                url: URL.createObjectURL(file) // Create temporary URL for immediate playback
                            });
                            
                        } catch (error) {
                            console.error("处理歌曲失败:", file.name, error);
                            showMessageBox(`处理歌曲 ${file.name} 失败。`);
                        }
                    }

                    // Save the list of song objects (now with IDs and names) to localStorage
                    const savableList = songList.map(s => ({ id: s.id, name: s.name }));
                    saveData('songList', savableList);
                    
                    updateSongListUI();
                    
                    if (currentSongIndex === -1 && songList.length > 0) {
                        playSong(0);
                    }
                    showMessageBox('歌曲添加完成！');
                }
                e.target.value = ''; // Reset input to allow re-uploading the same file
            });
            $('#playlist-button').addEventListener('click', () => $('#song-list-modal').classList.add('visible'));
            $('#close-playlist-modal').addEventListener('click', () => $('#song-list-modal').classList.remove('visible'));
            $('#play-pause-button').addEventListener('click', () => {
                if (songList.length === 0) return showMessageBox('請先上傳歌曲');
                if (currentAudio.paused) {
                    if (currentSongIndex === -1) playSong(0);
                    else {
                        currentAudio.play();
                        startSpinning();
                    }
                } else {
                    currentAudio.pause();
                    stopSpinning();
                }
                $('#play-pause-button i').className = `fas ${currentAudio.paused ? 'fa-play' : 'fa-pause'} text-xl`;
            });
            $('#prev-button').addEventListener('click', () => { if (songList.length > 0) playSong((currentSongIndex - 1 + songList.length) % songList.length); });
            $('#next-button').addEventListener('click', () => { if (songList.length > 0) playSong((currentSongIndex + 1) % songList.length); });
            $('#loop-button').addEventListener('click', () => { isLooping = !isLooping; $('#loop-button').classList.toggle('active', isLooping); showMessageBox(isLooping ? '列表循環已開啟' : '列表循環已關閉'); });
            $('#single-loop-button').addEventListener('click', () => { isSingleLooping = !isSingleLooping; $('#single-loop-button').classList.toggle('active', isSingleLooping); showMessageBox(isSingleLooping ? '單曲循環已開啟' : '單曲循環已關閉'); });

            $('#wb-add-button').addEventListener('click', () => {
                currentEditingWorldBookId = null;
                $('#wb-title-input').value = '';
                $('#wb-content-input').value = '';
                $('#wb-category-select').value = 'worldview';
                $('#wb-delete-button').style.display = 'none'; // 新建时隐藏删除按钮
                showScreen('world-book-edit-screen');
            });
            $('#wb-save-button').addEventListener('click', () => {
                const title = $('#wb-title-input').value.trim();
                if (!title) return showMessageBox('標題不能為空');
                const content = $('#wb-content-input').value.trim();
                
                if (currentEditingWorldBookId) {
                    const book = worldBooks.find(b => b.id === currentEditingWorldBookId);
                    if (book) {
                        book.title = title;
                        book.content = content;
                        book.category = $('#wb-category-select').value;
                    }
                } else {
                    const category = $('#wb-category-select').value;
                    const newBook = { id: `wb_${Date.now()}`, title, content, category: category };
                    worldBooks.push(newBook);
                }
                saveData('worldBooks', worldBooks);
                renderWorldBookList();
                showMessageBox('已保存');
                showScreen('world-book-list-screen');
            });

            // 世界书删除按钮事件
            $('#wb-delete-button').addEventListener('click', () => {
                if (currentEditingWorldBookId) {
                    const book = worldBooks.find(b => b.id === currentEditingWorldBookId);
                    if (book) {
                        showDeleteConfirmation('worldBook', book.id, book.title);
                    }
                }
            });

            $('#cb-add-button').addEventListener('click', () => {
                showCharacterEditScreen(null);
            });
            $('#cb-save-button').addEventListener('click', saveCharacter);
            $('#cb-delete-button').addEventListener('click', () => {
                if (currentEditingCharacterId) {
                    const character = characters.find(c => c.id === currentEditingCharacterId);
                    if (character) {
                        showDeleteConfirmation('character', character.id, character.name);
                    }
                }
            });
            
            $('#send-chat-button').addEventListener('click', handleSendMessage);
            $('#send-chat-button').addEventListener('touchend', handleSendMessage);
            $('#receive-chat-button').addEventListener('click', handleReceiveMessage);
            $('#receive-chat-button').addEventListener('touchend', handleReceiveMessage);
            
                    // V20.0 头像同步最终修复
        $('#wechat-new-chat-button').addEventListener('click', () => {
            const container = $('#new-chat-character-list');
            container.innerHTML = ''; // 清空列表

            if (characters.length === 0) {
                container.innerHTML = '<li class="p-3 text-center text-gray-400">请先去角色书创建角色</li>';
            } else {
                characters.forEach(char => {
                    const item = document.createElement('li');
                    item.className = 'list-item';
                    
                    // 为头像div创建一个唯一的ID，便于后续异步更新
                    const uniqueAvatarId = `new-chat-avatar-${char.id}`;
                    // 如果角色没有头像，则显示一个默认图标
                    const avatarContent = char.avatar ? '' : `<i class="ri-user-line text-xl"></i>`;

                    // 1. 先构建HTML结构，此时先不设置背景图片
                    item.innerHTML = `
                        <div class="flex items-center">
                            <div id="${uniqueAvatarId}" class="w-10 h-10 rounded-full mr-3 bg-zinc-600 flex-shrink-0 flex items-center justify-center bg-cover bg-center">${avatarContent}</div>
                            <h4 class="font-semibold">${char.name}</h4>
                        </div>
                    `;
                    
                    // 2. 将列表项添加到容器中
                    container.appendChild(item);

                    // 3. 【核心修复】如果角色有头像ID，则异步从IndexedDB获取并设置
                    if (char.avatar) {
                        getImageFromDB(char.avatar).then(blob => {
                            const avatarElement = document.getElementById(uniqueAvatarId);
                            if (avatarElement && blob) {
                                // 找到对应的头像div，并设置背景图片
                                avatarElement.style.backgroundImage = `url(${URL.createObjectURL(blob)})`;
                            }
                        });
                    }
                    
                    // 为整个列表项添加点击事件
                    item.addEventListener('click', () => {
                        $('#new-chat-modal').classList.remove('visible');
                        if (!chatHistories[char.id]) {
                            chatHistories[char.id] = { history: [], pinned: false };
                            saveData('chatHistories', chatHistories);
                            renderWeChatList();
                            showMessageBox(`已和 ${char.name} 建立对话`);
                        }
                        // 点击后直接进入聊天
                        startChatWithCharacter(char.id);
                    });
                });
            }
            $('#new-chat-modal').classList.add('visible');
        });
            $('#close-new-chat-modal').addEventListener('click', () => $('#new-chat-modal').classList.remove('visible'));
            
            $('#wechat-options-button').addEventListener('click', () => {
                const pinOption = $('#pin-chat-option');
                pinOption.textContent = chatHistories[currentChatCharacterId]?.pinned ? '取消置頂' : '置頂對話';
                
                const userColorPicker = $('#user-bubble-color-picker');
                const aiColorPicker = $('#ai-bubble-color-picker');
                const userTextColorPicker = $('#user-text-color-picker');
                const aiTextColorPicker = $('#ai-text-color-picker');
                const otherTextColorPicker = $('#other-text-color-picker');
                const currentColors = chatBubbleColors[currentChatCharacterId];
                const currentTextColors = chatTextColors[currentChatCharacterId];
                
                const isDarkMode = body.classList.contains('dark-mode');
                const defaultUserColor = '#374151';
                const defaultAiColor = isDarkMode ? '#4a4a4a' : '#e5e7eb';
                const defaultUserTextColor = '#ffffff';
                const defaultAiTextColor = '#000000';
                const defaultOtherTextColor = '#000000';

                userColorPicker.value = currentColors?.user || defaultUserColor;
                aiColorPicker.value = currentColors?.ai || defaultAiColor;
                userTextColorPicker.value = currentTextColors?.user || defaultUserTextColor;
                aiTextColorPicker.value = currentTextColors?.ai || defaultAiTextColor;
                otherTextColorPicker.value = currentTextColors?.other || defaultOtherTextColor;

                // V40.0 新增：加载并显示已保存的记忆长度
                const memoryLengthInput = $('#ai-memory-length');
                const savedMemoryLength = loadData('ai_memory_length', 50); // 默认50
                memoryLengthInput.value = savedMemoryLength;

                // 【【新增】】拉黑/取消拉黑功能
                const blockOption = $('#block-character-option');
                const isBlocked = characterState[currentChatCharacterId]?.isBlocked || false;

                blockOption.textContent = isBlocked ? '取消拉黑' : '拉黑角色';
                
                // 使用克隆节点的方式移除旧的监听器，防止重复绑定
                const newBlockOption = blockOption.cloneNode(true);
                blockOption.parentNode.replaceChild(newBlockOption, blockOption);

                newBlockOption.addEventListener('click', () => {
                    const currentState = characterState[currentChatCharacterId]?.isBlocked || false;
                    if (!characterState[currentChatCharacterId]) {
                        characterState[currentChatCharacterId] = {};
                    }
                    
                    if (currentState) {
                        // --- 取消拉黑逻辑 ---
                        characterState[currentChatCharacterId].isBlocked = false;
                        
                        const systemMsgContent = `[系统提示：你已被用户取消拉黑。现在对方可以看到你的消息了。]`;
                        const internalMsg = { content: systemMsgContent, sender: 'system', type: 'system-internal', timestamp: Date.now() };
                        chatHistories[currentChatCharacterId].history.push(internalMsg);

                        showMessageBox('已取消拉黑');
                        newBlockOption.textContent = '拉黑角色';
                    } else {
                        // --- 拉黑逻辑 ---
                        characterState[currentChatCharacterId].isBlocked = true;
                        
                        const systemMsgContent = `[系统提示：你被用户拉黑了。你接下来发送的消息对方将无法看到。]`;
                        const internalMsg = { content: systemMsgContent, sender: 'system', type: 'system-internal', timestamp: Date.now() };
                        chatHistories[currentChatCharacterId].history.push(internalMsg);

                        triggerAIBlockedReaction(currentChatCharacterId);
                        showMessageBox('角色已被拉黑');
                        newBlockOption.textContent = '取消拉黑';
                    }
                    saveData('characterState', characterState);
                    saveData('chatHistories', chatHistories);
                    showScreen('wechat-chat-screen'); // 操作后返回聊天界面
                });

                // ====== 【新增】处理"隐藏头像"开关的逻辑 ======
                const hideAvatarsToggle = document.getElementById('hide-avatars-toggle');
                const chatOptions = loadData('chatOptions', {});
                const currentChatOptions = chatOptions[currentChatCharacterId] || {};

                // 1. 加载当前设置，更新开关状态
                hideAvatarsToggle.checked = currentChatOptions.hideAvatars || false;

                // 2. 监听开关变化，并保存设置
                hideAvatarsToggle.onchange = (e) => {
                    const shouldHide = e.target.checked;
                    if (!chatOptions[currentChatCharacterId]) {
                        chatOptions[currentChatCharacterId] = {};
                    }
                    chatOptions[currentChatCharacterId].hideAvatars = shouldHide;
                    saveData('chatOptions', chatOptions);

                    // 立即应用或取消样式
                    document.getElementById('wechat-content-chat').classList.toggle('no-avatars', shouldHide);

                    // 滚动到底部以防布局变化导致位置错乱
                    const chatContentArea = $('#wechat-content-chat');
                    chatContentArea.scrollTop = chatContentArea.scrollHeight;
                };
                // ============================================

                showScreen('wechat-options-screen');
            });
            $('#wechat-options-back-button').addEventListener('click', () => showScreen('wechat-chat-screen'));
            $('#delete-chat-option').addEventListener('click', () => {
                const characterName = characters.find(c => c.id === currentChatCharacterId)?.name;
                showDeleteConfirmation('chat', currentChatCharacterId, `與 ${characterName} 的對話`);
            });
            $('#pin-chat-option').addEventListener('click', () => {
                const chat = chatHistories[currentChatCharacterId];
                if (chat) {
                    chat.pinned = !chat.pinned;
                    saveData('chatHistories', chatHistories);
                    showMessageBox(chat.pinned ? '已置頂' : '已取消置頂');
                    $('#pin-chat-option').textContent = chat.pinned ? '取消置頂' : '置頂對話';
                }
            });
            $('#change-chat-bg-option').addEventListener('click', () => {
                $('#chat-bg-input').click();
            });
            $('#chat-bg-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && currentChatCharacterId) {
                                            try {
                            const imageId = await handleImageUpload(e.target, null, null, {
                                compression: { maxWidth: 1920, maxHeight: 1920, quality: 0.9 }
                            });
                            
                            if (imageId) {
                                getImageFromDB(imageId).then(blob => {
                                    if (blob) {
                                        const objectURL = URL.createObjectURL(blob);
                                        
                                        // --- 核心改动在这里 ---
                                        const bgElement = getChatBackgroundElement(); // 1. 获取背景层
                                        bgElement.style.backgroundImage = `url(${objectURL})`; // 2. 把图片设置到背景层上

                                        // 3. 必须确保聊天屏幕本身是透明的，才能看到下面的背景层
                                        const chatScreen = $('#wechat-chat-screen');
                                        chatScreen.style.backgroundColor = 'transparent';

                                        // 这两行依然保留，用于调整其他UI元素
                                        chatScreen.classList.add('has-custom-bg');
                                        statusBar.classList.add('transparent-override');

                                        // ---【最关键的修复在这里】---
                                        // 1. 先从存储中加载最新的、完整的 chatBackgrounds 对象
                                        let currentBackgrounds = loadData('chatBackgrounds', {});
                                        // 2. 确保它是一个对象，如果不是（比如数据已损坏），就重置为空对象
                                        if (typeof currentBackgrounds !== 'object' || currentBackgrounds === null) {
                                            console.warn('chatBackgrounds 数据格式错误，已重置为空对象。');
                                            currentBackgrounds = {};
                                        }
                                        // 3. 在这个正确的对象上更新当前角色的背景ID
                                        currentBackgrounds[currentChatCharacterId] = imageId;
                                        // 4. 将这个完整的、更新后的对象存回去
                                        saveData('chatBackgrounds', currentBackgrounds);

                                        showMessageBox('聊天背景已更换');
                                    }
                                }).catch(error => {
                                    console.error('从数据库获取图片失败:', error);
                                });
                            }
                        } catch (error) {
                            console.error("处理聊天背景失败:", error);
                            showMessageBox('背景图片处理失败');
                        }
                }
                e.target.value = '';
            });

            function handleColorChange(type, value) {
                if (!currentChatCharacterId) return;
                if (!chatBubbleColors[currentChatCharacterId]) {
                    chatBubbleColors[currentChatCharacterId] = {};
                }
                chatBubbleColors[currentChatCharacterId][type] = value;
                saveData('chatBubbleColors', chatBubbleColors);
                renderChatHistory();
            }
            
            function handleTextColorChange(type, value) {
                if (!currentChatCharacterId) return;
                if (!chatTextColors[currentChatCharacterId]) {
                    chatTextColors[currentChatCharacterId] = {};
                }
                chatTextColors[currentChatCharacterId][type] = value;
                saveData('chatTextColors', chatTextColors);
                
                if (type === 'other') {
                    applyOtherTextColor(value);
                } else {
                    renderChatHistory();
                }
            }

            // 重置颜色和背景设置功能
            function resetColorsToDefault() {
                if (!currentChatCharacterId) return;
                
                const isDarkMode = body.classList.contains('dark-mode');
                
                // 定义默认颜色值
                const defaultColors = {
                    user: '#374151',
                    ai: isDarkMode ? '#4a4a4a' : '#e5e7eb'
                };
                
                const defaultTextColors = {
                    user: '#ffffff',
                    ai: '#000000',
                    other: isDarkMode ? '#ffffff' : '#000000'
                };
                
                // 重置气泡颜色
                if (chatBubbleColors[currentChatCharacterId]) {
                    delete chatBubbleColors[currentChatCharacterId];
                } else {
                    chatBubbleColors[currentChatCharacterId] = {};
                }
                
                // 重置文字颜色
                if (chatTextColors[currentChatCharacterId]) {
                    delete chatTextColors[currentChatCharacterId];
                } else {
                    chatTextColors[currentChatCharacterId] = {};
                }
                
                // 重置聊天背景
                try {
                    const bgElement = getChatBackgroundElement();
                    if (bgElement) {
                        bgElement.style.backgroundImage = 'none';
                        bgElement.style.backgroundColor = ''; // 清除背景色
                    }
                    
                    // 重置聊天屏幕背景
                    const chatScreen = $('#wechat-chat-screen');
                    if (chatScreen) {
                        chatScreen.style.backgroundColor = '';
                        chatScreen.style.backgroundImage = 'none';
                    }
                    
                    // 清除保存的背景数据
                    const chatBackgrounds = loadData('chatBackgrounds', {});
                    if (chatBackgrounds[currentChatCharacterId]) {
                        delete chatBackgrounds[currentChatCharacterId];
                        saveData('chatBackgrounds', chatBackgrounds);
                    }
                } catch (error) {
                    console.warn('重置背景时出现错误:', error);
                }
                
                // 保存到本地存储
                saveData('chatBubbleColors', chatBubbleColors);
                saveData('chatTextColors', chatTextColors);
                
                // 更新颜色选择器的显示值
                $('#user-bubble-color-picker').value = defaultColors.user;
                $('#ai-bubble-color-picker').value = defaultColors.ai;
                $('#user-text-color-picker').value = defaultTextColors.user;
                $('#ai-text-color-picker').value = defaultTextColors.ai;
                $('#other-text-color-picker').value = defaultTextColors.other;
                
                // 重新渲染聊天历史以应用默认颜色
                renderChatHistory();
                
                // 应用"其他"文字颜色
                applyOtherTextColor(defaultTextColors.other);
                
                // 强制重新应用默认颜色到界面元素，确保完全重置
                setTimeout(() => {
                    console.log('强制重置其他文字颜色为:', defaultTextColors.other);
                    applyOtherTextColor(defaultTextColors.other);
                    
                    // 额外确保颜色选择器显示正确的值
                    const otherColorPicker = $('#other-text-color-picker');
                    if (otherColorPicker) {
                        otherColorPicker.value = defaultTextColors.other;
                    }
                }, 100);
                
                // 显示成功提示
                showMessageBox('颜色和背景设置已重置为默认值！', 'success');
            }

            
            $('#user-bubble-color-picker').addEventListener('input', (e) => handleColorChange('user', e.target.value));
            $('#ai-bubble-color-picker').addEventListener('input', (e) => handleColorChange('ai', e.target.value));
            $('#user-text-color-picker').addEventListener('input', (e) => handleTextColorChange('user', e.target.value));
            $('#ai-text-color-picker').addEventListener('input', (e) => handleTextColorChange('ai', e.target.value));
            $('#other-text-color-picker').addEventListener('input', (e) => handleTextColorChange('other', e.target.value));
            
            // 重置外观设置按钮事件监听器
            $('#reset-colors-btn').addEventListener('click', () => {
                if (confirm('确定要重置所有外观设置为默认值吗？\n这将恢复以下设置到初始状态：\n• 气泡颜色\n• 文字颜色\n• 聊天背景图片')) {
                    resetColorsToDefault();
                }
            });
            
            // V40.0 新增：AI记忆长度设置的保存
            $('#ai-memory-length').addEventListener('change', (e) => {
                const value = parseInt(e.target.value, 10);
                if (value >= 10 && value <= 500) {
                    saveData('ai_memory_length', value);
                    console.log(`AI记忆长度已更新为: ${value}`);
                } else {
                    e.target.value = loadData('ai_memory_length', 50); // 恢复到有效值
                }
            });

            
            $('#wechat-content-chat').addEventListener('click', (e) => {
                if (e.target.closest('.user-avatar-in-chat')) {
                    $('#user-avatar-input').click();
                }
            });
            $('#user-avatar-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 256, maxHeight: 256, quality: 0.95, outputFormat: 'image/png' } });
                    if (imageId) {
                        // 更新当前聊天角色的头像
                        if (currentChatCharacterId) {
                            userAvatars[currentChatCharacterId] = imageId;
                            saveData('userAvatars', userAvatars);
                            renderChatHistory();
                        }
                        
                        // 更新朋友圈中的用户头像
                        if (currentWeChatCharacterId) {
                            userAvatars[currentWeChatCharacterId] = imageId;
                            saveData('userAvatars', userAvatars);
                            // 刷新朋友圈显示
                            if (!$('#wechat-moments-container').classList.contains('hidden')) {
                                renderUnifiedMoments();
                            }
                        }
                        
                        // 更新朋友圈头部头像
                        const momentsAvatar = $('#moments-user-avatar');
                        if (momentsAvatar) {
                            // 异步加载头像
                            getImageFromDB(imageId).then(blob => {
                                if (blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    momentsAvatar.style.backgroundImage = `url(${objectURL})`;
                                }
                            });
                        }
                        
                        showMessageBox('头像已更新');
                    }
                }
                e.target.value = '';
            });

            $('#change-wallpaper-link').addEventListener('click', () => $('#wallpaper-input').click());
            $('#wallpaper-input').addEventListener('change', async (e) => {
                const imageId = await handleImageUpload(e.target, homeWallpaper, 'saved_wallpaper', {
                    compression: { maxWidth: 1920, maxHeight: 1920, quality: 0.9 }
                });
                if (imageId) {
                    // 异步加载图片
                    getImageFromDB(imageId).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            homeWallpaper.style.backgroundImage = `url(${objectURL})`;
                            // 确保背景图片正确显示
                            homeWallpaper.style.backgroundSize = 'cover';
                            homeWallpaper.style.backgroundPosition = 'center';
                            homeWallpaper.style.backgroundRepeat = 'no-repeat';
                        }
                    });
                }
            });

            // 自定义图片URL设置功能
            $('#save-image-url').addEventListener('click', () => {
                const urlInput = $('#custom-image-url');
                const url = urlInput.value.trim();
                
                if (url) {
                    // 简单的URL验证
                    try {
                        new URL(url);
                        localStorage.setItem('customImageUrl', url);
                        showNotification('自定义图片URL已保存！', 'success');
                    } catch (e) {
                        showNotification('请输入有效的图片链接！', 'error');
                    }
                } else {
                    localStorage.removeItem('customImageUrl');
                    showNotification('已清除自定义图片URL设置！', 'success');
                }
            });

            // 加载已保存的自定义图片URL
            function loadCustomImageUrl() {
                const savedUrl = localStorage.getItem('customImageUrl');
                if (savedUrl) {
                    $('#custom-image-url').value = savedUrl;
                }
            }

            // 页面加载时执行
            loadCustomImageUrl();

            // 清除主界面内容功能
            $('#clear-player-bg').addEventListener('click', () => {
                // 清除播放器背景
                const musicBlock = $('#music-block');
                musicBlock.style.backgroundImage = '';
                
                // 清除localStorage中的数据
                localStorage.removeItem('saved_music_background');
                
                // 从IndexedDB中删除图片数据
                const savedBgId = loadData('saved_music_background');
                if (savedBgId) {
                    deleteImageFromDB(savedBgId);
                    saveData('saved_music_background', null);
                }
                
                showNotification('播放器背景已清除，恢复毛玻璃效果！', 'success');
            });

            $('#clear-photo-wall').addEventListener('click', () => {
                // 清除照片墙背景
                const photoWidget = $('#photo-widget');
                photoWidget.style.backgroundImage = '';
                
                // 清除localStorage中的数据
                localStorage.removeItem('saved_photo_widget');
                
                // 从IndexedDB中删除图片数据
                const savedPhotoId = loadData('saved_photo_widget');
                if (savedPhotoId) {
                    deleteImageFromDB(savedPhotoId);
                    saveData('saved_photo_widget', null);
                }
                
                showNotification('照片墙背景已清除，恢复毛玻璃效果！', 'success');
            });

            $('#clear-all-main-content').addEventListener('click', async () => {
                try {
                    let totalCleared = 0;
                    
                    // 清除播放器背景
                    const musicBlock = $('#music-block');
                    musicBlock.style.backgroundImage = '';
                    
                    // 清除照片墙背景
                    const photoWidget = $('#photo-widget');
                    photoWidget.style.backgroundImage = '';
                    
                    // 清除localStorage中的数据
                    localStorage.removeItem('saved_music_background');
                    localStorage.removeItem('saved_photo_widget');
                    
                    // 从IndexedDB中删除图片数据
                    const savedBgId = loadData('saved_music_background');
                    const savedPhotoId = loadData('saved_photo_widget');
                    
                    if (savedBgId) {
                        await deleteImageFromDB(savedBgId);
                        saveData('saved_music_background', null);
                        totalCleared++;
                    }
                    
                    if (savedPhotoId) {
                        await deleteImageFromDB(savedPhotoId);
                        saveData('saved_photo_widget', null);
                        totalCleared++;
                    }
                    
                    // 清除应用图标
                    const appIcons = $$('.app-icon');
                    for (const iconEl of appIcons) {
                        const appName = iconEl.dataset.appName;
                        const savedIconId = loadData(`saved_icon_${appName}`);
                        
                        if (savedIconId) {
                            await deleteImageFromDB(savedIconId);
                            saveData(`saved_icon_${appName}`, null);
                            iconEl.style.backgroundImage = '';
                            iconEl.style.backgroundSize = '';
                            iconEl.style.backgroundPosition = '';
                            iconEl.style.backgroundRepeat = '';
                            iconEl.style.border = '';
                            // 显示原始图标
                            const originalIcon = iconEl.querySelector('i');
                            if (originalIcon) originalIcon.style.display = 'block';
                            totalCleared++;
                        }
                    }
                    
                    showNotification(`所有主界面内容已清除，共清除 ${totalCleared} 项！`, 'success');
                    
                    // 重新渲染应用图标设置界面
                    renderAppIconSettings();
                } catch (error) {
                    console.error('清除主界面内容失败:', error);
                    showNotification('清除主界面内容失败，请重试', 'error');
                }
            });

            $('#clear-app-icons').addEventListener('click', async () => {
                try {
                    // 获取所有应用图标
                    const appIcons = $$('.app-icon');
                    let clearedCount = 0;
                    
                    for (const iconEl of appIcons) {
                        const appName = iconEl.dataset.appName;
                        const savedIconId = loadData(`saved_icon_${appName}`);
                        
                        if (savedIconId) {
                            // 删除IndexedDB中的图片数据
                            await deleteImageFromDB(savedIconId);
                            // 清除localStorage中的数据
                            saveData(`saved_icon_${appName}`, null);
                            // 恢复默认图标
                            iconEl.style.backgroundImage = '';
                            iconEl.style.backgroundSize = '';
                            iconEl.style.backgroundPosition = '';
                            iconEl.style.backgroundRepeat = '';
                            iconEl.style.border = '';
                            // 显示原始图标
                            const originalIcon = iconEl.querySelector('i');
                            if (originalIcon) originalIcon.style.display = 'block';
                            clearedCount++;
                        }
                    }
                    
                    showNotification(`已清除 ${clearedCount} 个应用图标，恢复默认显示！`, 'success');
                    
                    // 重新渲染应用图标设置界面
                    renderAppIconSettings();
                } catch (error) {
                    console.error('清除应用图标失败:', error);
                    showNotification('清除应用图标失败，请重试', 'error');
                }
            });

            function renderAppIconSettings() {
                const container = $('#app-icon-list');
                container.innerHTML = '';
                $$('.app-icon').forEach(iconEl => {
                    const appName = iconEl.dataset.appName;
                    const item = document.createElement('div');
                    item.className = 'list-item'; 
                    
                    const innerContainer = document.createElement('div');
                    innerContainer.className = 'flex justify-between items-center w-full';

                    const leftPart = document.createElement('div');
                    leftPart.className = 'flex items-center';

                    const previewIcon = document.createElement('div');
                    previewIcon.className = 'w-10 h-10 rounded-lg flex items-center justify-center shadow-md mr-4 bg-cover bg-center';
                    
                    const savedIcon = loadData(`saved_icon_${appName}`);
                    if (savedIcon) {
                        // 异步加载应用图标
                        getImageFromDB(savedIcon).then(blob => {
                            if (blob) {
                                const objectURL = URL.createObjectURL(blob);
                                previewIcon.style.backgroundImage = `url(${objectURL})`;
                                previewIcon.style.backgroundSize = 'cover';
                                previewIcon.style.backgroundPosition = 'center';
                                previewIcon.style.backgroundRepeat = 'no-repeat';
                            }
                        });
                    } else {
                        previewIcon.style.backgroundImage = iconEl.style.backgroundImage;
                    }

                    if (!previewIcon.style.backgroundImage) {
                        if (iconEl.classList.contains('app-icon-glass')) {
                            previewIcon.className += ' app-icon-glass';
                        } else {
                             previewIcon.style.backgroundColor = '#1f2937';
                        }
                    }
                    
                    const iconI = document.createElement('i');
                    const originalIcon = iconEl.querySelector('i');
                    if (originalIcon) iconI.className = originalIcon.className;
                    iconI.style.display = savedIcon ? 'none' : (originalIcon ? originalIcon.style.display : 'block');
                    previewIcon.appendChild(iconI);

                    const text = document.createElement('h4');
                    text.className = 'font-semibold';
                    text.textContent = appName;

                    leftPart.appendChild(previewIcon);
                    leftPart.appendChild(text);

                    const button = document.createElement('button');
                    button.className = 'px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded-md text-sm flex-shrink-0';
                    button.textContent = '更換';

                    innerContainer.appendChild(leftPart);
                    innerContainer.appendChild(button);
                    item.appendChild(innerContainer);
                    
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.className = 'hidden';
                    input.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            try {
                                const imageBlob = await compressImage(file, { maxWidth: 256, maxHeight: 256, quality: 0.95, outputFormat: 'image/png' });
                                const imageId = `icon_${appName}_${Date.now()}`;
                                await saveImageToDB(imageId, imageBlob);
                                saveData(`saved_icon_${appName}`, imageId);
                                
                                const objectURL = URL.createObjectURL(imageBlob);
                                iconEl.style.backgroundImage = `url(${objectURL})`;
                                if (originalIcon) originalIcon.style.display = 'none';
                                previewIcon.style.backgroundImage = `url(${objectURL})`;

                                // 确保图片完全覆盖、居中且不重复
                                iconEl.style.backgroundSize = 'cover';
                                iconEl.style.backgroundPosition = 'center';
                                iconEl.style.backgroundRepeat = 'no-repeat';
                                iconEl.style.border = 'none'; /* 【核心修复】移除毛玻璃效果残留的边框 */

                                // 同时为设置界面中的预览图标应用相同的修复
                                previewIcon.style.backgroundSize = 'cover';
                                previewIcon.style.backgroundPosition = 'center';
                                previewIcon.style.backgroundRepeat = 'no-repeat';
                                previewIcon.style.border = 'none'; /* 【核心修复】移除预览图标的边框 */
                                
                                const previewIconI = previewIcon.querySelector('i');
                                if (previewIconI) previewIconI.style.display = 'none';
                            } catch (error) {
                                showMessageBox("圖標處理失敗");
                            }
                        }
                    });
                    item.appendChild(input);
                    button.addEventListener('click', () => input.click());
                    container.appendChild(item);
                });
            }
            
            $('#font-save-button').addEventListener('click', () => {
                const url = $('#font-url-input').value.trim();
                if (url) {
                    applyFont(url);
                    saveData('saved_font_url', url);
                    showMessageBox('字體已應用');
                } else {
                    const styleElement = document.getElementById('custom-font-style');
                    if(styleElement) styleElement.innerHTML = '';
                    phoneScreen.style.fontFamily = '';
                    localStorage.removeItem('saved_font_url');
                    showMessageBox('已恢復預設字體');
                }
            });

            $('#font-size-selector').addEventListener('click', (e) => {
                if (e.target.matches('.font-size-btn')) {
                    const size = e.target.dataset.size;
                    setFontSize(size);
                    saveData('fontSize', size);
                }
            });
            
            $('#fetch_models_btn').addEventListener('click', () => fetchModels(false));

            $('#save_settings_btn').addEventListener('click', async () => {
                const configName = $('#config-name').value.trim();
                const apiUrl = $('#api_url').value.trim();
                const apiKey = $('#api_key').value.trim();
                const model = $('#model_select').value;
                const enabled = $('#api-enabled-toggle').checked;

                if (!configName) {
                    showMessageBox("请输入配置名称");
                    return;
                }

                if (!apiUrl || !apiKey) {
                    showMessageBox("请填写 API 地址和密钥");
                    return;
                }

                // 检查是否是编辑现有配置
                const selectedConfigId = $('#api-config-select').value;
                let configId;

                if (selectedConfigId) {
                    // 编辑现有配置
                    configId = selectedConfigId;
                    const configIndex = apiConfigs.findIndex(c => c.id === configId);
                    if (configIndex !== -1) {
                        apiConfigs[configIndex] = {
                            id: configId,
                            name: configName,
                            url: apiUrl,
                            key: apiKey,
                            model: model,
                            enabled: enabled,
                            updatedAt: new Date().toISOString()
                        };
                    }
                } else {
                    // 新增配置
                    configId = generateConfigId();
                    apiConfigs.push({
                        id: configId,
                        name: configName,
                        url: apiUrl,
                        key: apiKey,
                        model: model,
                        enabled: enabled,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    });
                }

                // 保存配置列表
                saveData('api_configs', apiConfigs);
                
                showMessageBox("配置已保存，正在验证连接...");

                // 验证API连接
                const settings = { url: apiUrl, key: apiKey, model: model };
                const isValid = await fetchModels(true);

                if (isValid) {
                    showMessageBox("配置保存成功，API验证通过");
                    // 更新模型信息
                    const finalModel = $('#model_select').value;
                    const configIndex = apiConfigs.findIndex(c => c.id === configId);
                    if (configIndex !== -1) {
                        apiConfigs[configIndex].model = finalModel;
                        saveData('api_configs', apiConfigs);
                    }
                } else {
                    showMessageBox("配置已保存，但API验证失败");
                }

                // 刷新配置列表并选中当前配置
                loadApiConfigList();
                $('#api-config-select').value = configId;
            });

            // 新增：API总开关的事件监听
            const apiEnabledToggle = document.getElementById('api-enabled-toggle');
            if (apiEnabledToggle) {
                // 读取保存的状态并设置开关
                apiEnabledToggle.checked = loadData('api_enabled', false);

                // 监听开关变化
                apiEnabledToggle.addEventListener('change', (e) => {
                    const isEnabled = e.target.checked;
                    saveData('api_enabled', isEnabled);
                    updateApiStatusUI(isEnabled && loadData('api_settings')?.key);
                    showMessageBox(isEnabled ? 'API 已启用' : 'API 已关闭');
                });
            }

            // API多配置管理功能
            const apiConfigs = loadData('api_configs', []);
            const currentConfigId = loadData('current_config_id', '');

            // 加载配置列表
            function loadApiConfigList() {
                const configSelect = $('#api-config-select');
                configSelect.innerHTML = '<option value="">请选择配置...</option>';
                
                apiConfigs.forEach(config => {
                    const option = document.createElement('option');
                    option.value = config.id;
                    option.textContent = config.name;
                    if (config.id === currentConfigId) {
                        option.selected = true;
                    }
                    configSelect.appendChild(option);
                });
            }

            // 加载指定配置到表单
            function loadConfigToForm(configId) {
                const config = apiConfigs.find(c => c.id === configId);
                if (config) {
                    $('#config-name').value = config.name;
                    $('#api_url').value = config.url;
                    $('#api_key').value = config.key;
                    $('#model_select').value = config.model || '';
                    $('#api-enabled-toggle').checked = config.enabled || false;
                }
            }

            // 清空表单
            function clearConfigForm() {
                $('#config-name').value = '';
                $('#api_url').value = '';
                $('#api_key').value = '';
                $('#model_select').value = '';
                $('#api-enabled-toggle').checked = false;
            }

            // 生成唯一ID
            function generateConfigId() {
                return 'config_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            // 新增配置按钮
            $('#add-api-config-btn').addEventListener('click', () => {
                clearConfigForm();
                $('#api-config-select').value = '';
                $('#config-name').focus();
                showMessageBox('请输入新配置信息');
            });

            // 配置选择变化
            $('#api-config-select').addEventListener('change', (e) => {
                const configId = e.target.value;
                if (configId) {
                    loadConfigToForm(configId);
                } else {
                    clearConfigForm();
                }
            });

            // 删除配置按钮
            $('#delete-api-config-btn').addEventListener('click', () => {
                const configId = $('#api-config-select').value;
                if (!configId) {
                    showMessageBox('请先选择要删除的配置');
                    return;
                }

                const config = apiConfigs.find(c => c.id === configId);
                if (!config) return;

                if (confirm(`确定要删除配置"${config.name}"吗？`)) {
                    const index = apiConfigs.findIndex(c => c.id === configId);
                    if (index !== -1) {
                        apiConfigs.splice(index, 1);
                        saveData('api_configs', apiConfigs);
                        
                        // 如果删除的是当前配置，清除当前配置ID
                        if (configId === currentConfigId) {
                            saveData('current_config_id', '');
                        }
                        
                        loadApiConfigList();
                        clearConfigForm();
                        showMessageBox('配置已删除');
                    }
                }
            });

            // 应用配置按钮
            $('#apply_config_btn').addEventListener('click', async () => {
                const configId = $('#api-config-select').value;
                if (!configId) {
                    showMessageBox('请先选择要应用的配置');
                    return;
                }

                const config = apiConfigs.find(c => c.id === configId);
                if (!config) return;

                // 应用配置到系统
                const settings = { url: config.url, key: config.key, model: config.model };
                saveData('api_settings', settings);
                saveData('api_enabled', config.enabled);
                saveData('current_config_id', configId);
                
                showMessageBox('配置已应用，正在验证连接...');
                
                // 验证连接
                const isValid = await fetchModels(true);
                updateApiStatusUI(isValid && config.enabled);
                
                if (isValid) {
                    showMessageBox('配置应用成功，API连接正常');
                } else {
                    showMessageBox('配置已应用，但API连接验证失败');
                }
                
                // 更新当前配置显示
                updateCurrentConfigDisplay();
            });

            // 显示当前配置信息
            function updateCurrentConfigDisplay() {
                const currentConfigInfo = $('#current-config-info');
                const currentConfigNameSpan = $('#current-config-name');
                
                if (currentConfigId) {
                    const currentConfig = apiConfigs.find(c => c.id === currentConfigId);
                    if (currentConfig) {
                        currentConfigNameSpan.textContent = currentConfig.name;
                        currentConfigInfo.classList.remove('hidden');
                    } else {
                        currentConfigInfo.classList.add('hidden');
                    }
                } else {
                    currentConfigInfo.classList.add('hidden');
                }
            }

            // 初始化配置列表
            loadApiConfigList();
            if (currentConfigId) {
                loadConfigToForm(currentConfigId);
            }
            updateCurrentConfigDisplay();

            $('#confirm-delete-btn').addEventListener('click', () => {
                if (deleteCallback) deleteCallback();
            });
            $('#cancel-delete-btn').addEventListener('click', () => {
                $('#confirm-delete-modal').classList.remove('visible');
                deleteCallback = null;
            });
            
            // V7.1: 全新 Tab Bar 事件監聽器
            $('.wechat-tab-bar').addEventListener('click', (e) => {
                const target = e.target.closest('.wechat-tab-item');
                if (!target) return;

                const tabName = target.dataset.tab; // 获取点击的标签名

                // 【新增】隐藏红点的逻辑
                if (notificationStatus[tabName]) {
                    notificationStatus[tabName] = false;
                    saveData('notificationStatus', notificationStatus);
                    updateAllNotificationDots();
                }

                // 如果沒有角色，提示用戶
                if (!characters.length > 0) {
                    showMessageBox("請先創建一個角色");
                    return;
                }
                currentWeChatCharacterId = characters[0].id; // 預設使用第一個角色ID作為上下文

                $$('.wechat-tab-item').forEach(item => item.classList.remove('active'));
                target.classList.add('active');

                const tab = target.dataset.tab;
                
                $$('#wechat-content-container > div').forEach(div => {
                    div.classList.add('hidden');
                });

                if (tab === 'chat') {
                    $('#wechat-list-container').classList.remove('hidden');
                    $('#wechat-new-chat-button').classList.remove('hidden');
                    $('#wechat-new-moment-button').classList.add('hidden');
                    $('#wechat-new-plan-button').classList.add('hidden');
                } else if (tab === 'moments') {
                    $('#wechat-moments-container').classList.remove('hidden');
                    $('#wechat-new-chat-button').classList.add('hidden');
                    $('#wechat-new-moment-button').classList.remove('hidden');
                    $('#wechat-new-plan-button').classList.add('hidden');
                    renderUnifiedMoments();
                } else if (tab === 'diary') {
                    $('#wechat-diary-container').classList.remove('hidden');
                    $('#wechat-new-chat-button').classList.add('hidden');
                    $('#wechat-new-moment-button').classList.add('hidden');
                    $('#wechat-new-plan-button').classList.add('hidden');
                    showDiaryBookshelf();
                } else if (tab === 'plan') {
                    $('#wechat-plan-container').classList.remove('hidden');
                    $('#wechat-new-chat-button').classList.add('hidden');
                    $('#wechat-new-moment-button').classList.add('hidden');
                    $('#wechat-new-plan-button').classList.remove('hidden');
                    renderPlanList();
                }
            });

            const chatScreen = $('#wechat-chat-screen');

            function hideBubbleMenu() {
                if (activeMenu) {
                    activeMenu.classList.remove('visible');
                    activeMenu = null;
                }
            }

            chatScreen.addEventListener('click', (e) => {
                if (e.target.closest('.bubble-context-menu')) return;

                const wrapper = e.target.closest('.chat-message-wrapper');

                if (isMultiSelectMode) {
                    if (wrapper) toggleMessageSelection(wrapper);
                } else {
                    const bubble = e.target.closest('.chat-message');
                    if (bubble && !bubble.classList.contains('red-packet-message') && !bubble.classList.contains('transfer-message')) {
                        e.stopPropagation();
                        if (activeMenu && !activeMenu.isSameNode(bubble.parentNode.querySelector('.bubble-context-menu'))) {
                           hideBubbleMenu();
                        }
                        showBubbleMenu(bubble);
                    } else {
                        hideBubbleMenu();
                    }
                }
            });

            function showBubbleMenu(bubble) {
                // 【新增】检查消息是否被标记为"禁止菜单"，如果是，则直接退出函数
                if (bubble.closest('[data-no-menu="true"]')) return;
                
                const wrapper = bubble.closest('.chat-message-wrapper');
                let menu = wrapper.querySelector('.bubble-context-menu');

                if (!menu) {
                    const template = $('#bubble-menu-template');
                    const menuClone = template.content.cloneNode(true);
                    wrapper.appendChild(menuClone);
                    menu = wrapper.querySelector('.bubble-context-menu');

                    menu.addEventListener('click', (e) => {
                        const button = e.target.closest('.bubble-menu-button');
                        if (button) {
                            const action = button.dataset.action;
                            const timestamp = wrapper.dataset.timestamp;
                            handleMenuAction(action, timestamp, bubble);
                        }
                    });
                }

                const sender = wrapper.dataset.sender;

                menu.querySelector('[data-action="retry"]').style.display = sender === 'ai' ? 'flex' : 'none';

                // ================== 在这里粘贴下面的新代码 ==================
                // --- 确保菜单在计算前是可见的，以便获取正确尺寸 ---
                menu.classList.add('visible');
                const menuRect = menu.getBoundingClientRect();
                
                // --- 全新 V2 定位逻辑 ---
                const bubbleRect = bubble.getBoundingClientRect();
                const container = document.getElementById('wechat-content-chat');
                const containerRect = container.getBoundingClientRect();
                const headerElement = $('#wechat-chat-screen .app-header');
                const headerHeight = headerElement ? headerElement.offsetHeight : 0;

                // --- 垂直位置计算 (Y轴) ---
                let finalTop = bubble.offsetTop - menuRect.height - 8; // 默认在上方
                // 检查是否会与标题栏碰撞
                if ((bubbleRect.top - containerRect.top) - menuRect.height - 8 < headerHeight) {
                    finalTop = bubble.offsetTop + bubble.offsetHeight + 8; // 翻转到下方
                }

                // --- 水平位置计算 (X轴)，这是本次修复的核心 ---
                let finalLeft;
                const bubbleCenter = bubble.offsetLeft + bubble.offsetWidth / 2;
                const idealLeft = bubbleCenter - menuRect.width / 2; // 理想的居中位置

                if (idealLeft < 0) {
                    // 如果居中会导致超出左边界，则将菜单左侧与气泡左侧对齐
                    finalLeft = bubble.offsetLeft;
                } else if (idealLeft + menuRect.width > container.clientWidth) {
                    // 如果居中会导致超出右边界，则将菜单右侧与气泡右侧对齐
                    finalLeft = bubble.offsetLeft + bubble.offsetWidth - menuRect.width;
                } else {
                    // 空间足够，正常居中
                    finalLeft = idealLeft;
                }
                
                // 再次进行边界矫正，确保万无一失
                if (finalLeft < 4) finalLeft = 4;
                if (finalLeft + menuRect.width > container.clientWidth - 4) {
                    finalLeft = container.clientWidth - menuRect.width - 4;
                }
                
                // 应用最终计算出的安全位置
                menu.style.top = `${finalTop}px`;
                menu.style.left = `${finalLeft}px`;
                menu.style.transform = 'translateX(0)'; // 确保重置transform
                // ================== 新代码结束 ==================

                activeMenu = menu;
            }

            function handleMenuAction(action, timestamp, bubble) {
                 hideBubbleMenu();
                 switch (action) {
                    case 'reply': // 【【新增这个 case】】
                        startReplyMode(timestamp);
                        break;
                    case 'delete':
                        showDeleteConfirmation('message', timestamp, '這條消息');
                        break;
                    case 'copy':
                        copyMessageHandler(timestamp);
                        break;
                    case 'multiselect':
                        enterMultiSelectMode();
                        break;
                    case 'mark-memory':
                        markMemoryHandler(timestamp);
                        break;
                    case 'edit':
                        editMessageHandler(timestamp, bubble);
                        break;
                    case 'retry':
                        retryMessageHandler(timestamp);
                        break;
                 }
            }

            function copyMessageHandler(timestamp) {
                const msg = chatHistories[currentChatCharacterId]?.history.find(m => String(m.timestamp) === timestamp);
                if (msg && msg.type === 'text') {
                    navigator.clipboard.writeText(msg.content).then(() => {
                        showMessageBox('已複製');
                    }).catch(() => showMessageBox('複製失敗'));
                }
            }

            function markMemoryHandler(timestamp) {
                // 手动强制触发记忆提炼，传入指定的消息时间戳
                triggerMemoryDistiller(currentChatCharacterId, true, timestamp);
            }

            function editMessageHandler(timestamp, bubble) {
                const msgIndex = chatHistories[currentChatCharacterId].history.findIndex(m => String(m.timestamp) === timestamp);
                if (msgIndex === -1 || chatHistories[currentChatCharacterId].history[msgIndex].type !== 'text') return;

                const p = bubble.querySelector('p');
                const originalText = chatHistories[currentChatCharacterId].history[msgIndex].content;
                p.contentEditable = true;
                p.focus();

                const sel = window.getSelection();
                sel.selectAllChildren(p);
                sel.collapseToEnd();

                const saveEdit = () => {
                    const newText = p.innerText.trim();
                    if (newText && newText !== originalText) {
                        chatHistories[currentChatCharacterId].history[msgIndex].content = newText;
                        saveData('chatHistories', chatHistories);
                    }
                    p.innerHTML = newText.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>');
                };

                p.addEventListener('blur', () => {
                    p.contentEditable = false;
                    saveEdit();
                }, { once: true });

                p.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); p.blur(); }
                    if (e.key === 'Escape') { p.innerText = originalText; p.blur(); }
                });
            }

            async function retryMessageHandler(timestamp) {
                const history = chatHistories[currentChatCharacterId].history;
                const msgIndex = history.findIndex(m => String(m.timestamp) === timestamp);

                if (msgIndex > -1) {
                    const wrapperToRetry = $(`[data-timestamp="${timestamp}"]`);
                    if (!wrapperToRetry) return; // Element not found in DOM

                    // --- 【【核心修改：在这里寻找"记忆备忘录"】】 ---
                    // 向前查找，看在AI回应之前，是否存在一个"system-internal"的记忆消息
                    let lastUserMessageIndex = -1;
                    let hasInternalMemory = false;
                    for (let i = msgIndex - 1; i >= 0; i--) {
                        if (history[i].type === 'system-internal') {
                            // 找到了！这是一个游戏消息的重试
                            hasInternalMemory = true;
                            // 重试的上下文应该从这条记忆消息开始
                            lastUserMessageIndex = i;
                            break;
                        }
                        if (history[i].sender === 'user') {
                            // 如果先找到了用户消息，说明这是普通聊天
                            lastUserMessageIndex = i;
                            break;
                        }
                    }
                    // --- 【修改结束】 ---

                    if (lastUserMessageIndex === -1) {
                        showMessageBox('無法找到有效的重試上下文');
                        return;
                    }

                    const wrapperIndex = Array.from(chatContentArea.children).indexOf(wrapperToRetry);
                    const subsequentWrappers = Array.from(chatContentArea.children).slice(wrapperIndex + 1);

                    // 截取到最后一个用户消息为止的历史记录
                    const historyToRetry = history.slice(0, lastUserMessageIndex + 1);
                    
                    // 更新聊天历史，移除要重新生成的消息及之后的所有消息
                    chatHistories[currentChatCharacterId].history = historyToRetry;

                    // 移除DOM中要重新生成的消息及之后的所有消息
                    subsequentWrappers.forEach(el => el.remove());

                    // 保存更新后的聊天历史到本地存储，确保gatherAIContext能获取到最新数据
                    saveData('chatHistories', chatHistories);
                    
                    const lastUserMessage = historyToRetry[historyToRetry.length - 1];
                    let promptForAI = '';

                    // ** 核心修复：在这里翻译上一条用户消息 **
                    if (lastUserMessage.type === 'text') {
                        promptForAI = lastUserMessage.content;
                    } else if (lastUserMessage.type === 'perch-forward') {
                        const authorName = lastUserMessage.content.originalAuthorName;
                        const postContent = lastUserMessage.content.originalContent;
                        const character = characters.find(c => c.id === currentChatCharacterId);
                        if (character && authorName === character.name) {
                            promptForAI = `[系统提示：用户将【你】之前在"栖木"上发表的一篇帖子转发了回来。帖子内容是："${postContent}"]`
                        } else {
                            promptForAI = `[系统提示：用户转发了【${authorName}】在"栖木"上的一篇帖子，内容是："${postContent}"]`
                        }
                    } else if (lastUserMessage.type === 'image') {
                        promptForAI = '[用户发送了一张图片，请你对此进行回应]';
                    }
                    
                    // 使用翻译好的、干净的prompt重新生成AI响应
                    await getAIResponse(true, wrapperToRetry);
                }
            }

            function enterMultiSelectMode() {
                isMultiSelectMode = true;
                $('#chat-header-normal').classList.add('hidden');
                $('#chat-header-multiselect').classList.remove('hidden');
                $('#chat-header-multiselect').classList.add('flex');
                updateMultiSelectCount();
            }

            function exitMultiSelectMode() {
                isMultiSelectMode = false;
                selectedMessages.clear();
                $$('.chat-message-wrapper.selected').forEach(el => el.classList.remove('selected'));
                $('#chat-header-normal').classList.remove('hidden');
                $('#chat-header-multiselect').classList.add('hidden');
                $('#chat-header-multiselect').classList.remove('flex');
            }

            function toggleMessageSelection(wrapper) {
                const timestamp = wrapper.dataset.timestamp;
                wrapper.classList.toggle('selected');
                if (selectedMessages.has(timestamp)) {
                    selectedMessages.delete(timestamp);
                } else {
                    selectedMessages.add(timestamp);
                }
                updateMultiSelectCount();
            }

            function updateMultiSelectCount() {
                const count = selectedMessages.size;
                $('#multiselect-count').textContent = `已選擇 ${count} 項`;
                $('#confirm-multiselect-btn').disabled = count === 0;
            }

            $('#cancel-multiselect-btn').addEventListener('click', exitMultiSelectMode);
            $('#confirm-multiselect-btn').addEventListener('click', () => {
                if(selectedMessages.size > 0) {
                    showDeleteConfirmation('multi-message', null, `${selectedMessages.size}條消息`);
                }
            });

            const featuresPanel = $('#more-features-panel');
            const addFeatureBtn = $('#add-feature-btn');
            const chatInputBar = $('#chat-input-bar');
            const chatInput = $('#chat-input');
            const addFeatureIcon = addFeatureBtn.querySelector('i');

            function toggleFeaturesPanel() {
                const isPanelHidden = featuresPanel.classList.contains('hidden');
                if (isPanelHidden) {
                    featuresPanel.classList.remove('hidden');
                    addFeatureIcon.className = 'ri-keyboard-line';
                } else {
                    featuresPanel.classList.add('hidden');
                    addFeatureIcon.className = 'ri-add-circle-line';
                }
            }

            addFeatureBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFeaturesPanel();
            });

            chatScreen.addEventListener('click', (e) => {
                const stickerPanel = $('#sticker-panel');
                if (addFeatureBtn.contains(e.target) || featuresPanel.contains(e.target) || $('#emoji-btn').contains(e.target) || stickerPanel.contains(e.target)) return;

                if (!featuresPanel.classList.contains('hidden')) {
                    toggleFeaturesPanel();
                }
                if (stickerPanel.classList.contains('visible')) {
                    // 如果在刪除模式下，點擊外部不會關閉面板
                    if (!isDeleteMode) {
                        stickerPanel.classList.remove('visible');
                    }
                }
            });

            $('#send-image-btn').addEventListener('click', () => {
                $('#image-upload-input').click();
            });

            $('#image-upload-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 512, maxHeight: 512 } });
                    if (imageId) {
                        const isNewSender = chatHistories[currentChatCharacterId]?.history.length === 0 || chatHistories[currentChatCharacterId].history.slice(-1)[0].sender !== 'user';
                        const timestamp = Date.now();
                        const imageMsg = { 
                            content: imageId, 
                            sender: 'user', 
                            type: 'image', 
                            timestamp: timestamp,
                            ...(currentReplyToTimestamp && { replyTo: currentReplyToTimestamp })
                        };
                        
                        // 保存到历史记录
                        if (!chatHistories[currentChatCharacterId]) {
                            chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                        }
                        chatHistories[currentChatCharacterId].history.push(imageMsg);
                        saveData('chatHistories', chatHistories);
                        
                        // 渲染消息
                        appendMessage(imageMsg, isNewSender);
                        
                        // 取消回复模式
                        if (currentReplyToTimestamp) {
                            cancelReplyMode();
                        }
                    }
                    toggleFeaturesPanel();
                    e.target.value = '';
                }
            });

            const voiceModal = $('#voice-input-modal');
            const voiceInput = $('#voice-text-input');
            $('#quick-voice-message-btn').addEventListener('click', () => {
                voiceModal.classList.add('visible');
                voiceInput.focus();
            });
            $('#cancel-voice-btn').addEventListener('click', () => {
                voiceModal.classList.remove('visible');
                voiceInput.value = '';
            });
            $('#send-voice-btn').addEventListener('click', () => {
                const text = voiceInput.value.trim();
                if (text) {
                    const isNewSender = chatHistories[currentChatCharacterId]?.history.length === 0 || chatHistories[currentChatCharacterId].history.slice(-1)[0].sender !== 'user';
                    const timestamp = Date.now();
                    const voiceMsg = { 
                        content: text, 
                        sender: 'user', 
                        type: 'voice', 
                        timestamp: timestamp,
                        ...(currentReplyToTimestamp && { replyTo: currentReplyToTimestamp })
                    };
                    
                    // 保存到历史记录
                    if (!chatHistories[currentChatCharacterId]) {
                        chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                    }
                    chatHistories[currentChatCharacterId].history.push(voiceMsg);
                    saveData('chatHistories', chatHistories);
                    
                    // 渲染消息
                    appendMessage(voiceMsg, isNewSender);
                    
                    // 取消回复模式
                    if (currentReplyToTimestamp) {
                        cancelReplyMode();
                    }
                    
                    voiceInput.value = '';
                    voiceModal.classList.remove('visible');
                }
            });

            $('#quick-voice-call-btn').addEventListener('click', () => {
                currentCallType = 'voice';
                startVoiceCall();
            });
            $('#quick-video-call-btn').addEventListener('click', () => {
                currentCallType = 'video';
                startVideoCall();
            });

            $('#voice-call-hangup').addEventListener('click', () => endCall(true));
            $('#video-call-hangup').addEventListener('click', () => endCall(true));
            $('#voice-call-send-btn').addEventListener('click', () => handleCallInteraction('voice'));
            $('#video-call-send-btn').addEventListener('click', () => handleCallInteraction('video'));

            $('#answer-call-btn').addEventListener('click', () => {
                console.log('接听按钮被点击，当前通话类型:', currentCallType, '当前角色ID:', currentChatCharacterId);
                $('#incoming-call-alert').classList.remove('visible');
                
                if (currentCallType === 'voice') {
                    console.log('开始语音通话...');
                    startVoiceCall();
                } else if (currentCallType === 'video') {
                    console.log('开始视频通话...');
                    startVideoCall();
                } else {
                    console.error('未知的通话类型:', currentCallType);
                }
            });
            $('#decline-call-btn').addEventListener('click', () => {
                console.log('拒绝按钮被点击，记录通话拒绝事件');
                $('#incoming-call-alert').classList.remove('visible');

                if (currentChatCharacterId) {
                    // 【核心修改】直接添加一条AI能够识别的、内容一致的系统消息
                    // 这条消息既会显示给用户，也会成为AI的记忆
                    const callEndMsg = { content: '通話已結束', sender: 'system', type: 'system', timestamp: Date.now() };
                    
                    // 保存到历史记录
                    if (!chatHistories[currentChatCharacterId]) {
                        chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                    }
                    chatHistories[currentChatCharacterId].history.push(callEndMsg);
                    saveData('chatHistories', chatHistories);
                    
                    // 渲染消息
                    appendMessage(callEndMsg, false);
                }
                
                currentCallType = null;
            });

            $('#user-video-preview').addEventListener('click', () => {
                $('#my-video-image-input').click();
            });

            $('#change-user-video-image-option').addEventListener('click', () => {
                 $('#user-video-image-input').click();
            });

            $('#user-video-image-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && currentChatCharacterId) {
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 512, maxHeight: 512 }});
                    if (imageId) {
                        userVideoImages[currentChatCharacterId] = imageId;
                        saveData('userVideoImages', imageId);
                        showMessageBox('對方的視頻照片已更新');
                    }
                }
            });

            $('#my-video-image-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && currentChatCharacterId) {
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 256, maxHeight: 256 }});
                    if (imageId) {
                        myVideoImages[currentChatCharacterId] = imageId;
                        saveData('myVideoImages', imageId);
                        if (currentCallType === 'video') {
                            // 异步加载图片
                            getImageFromDB(imageId).then(blob => {
                                if (blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    $('#user-video-image').src = objectURL;
                                }
                            });
                        }
                        showMessageBox('我的視頻照片已更新');
                    }
                }
            });

            // 貼圖功能事件監聽
            const stickerPanel = $('#sticker-panel');
            const stickerGrid = $('#sticker-grid');
            const addStickerBtn = $('#add-sticker-btn');
            const stickerModal = $('#sticker-modal');

            // 刪除模式相關變量
            let isDeleteMode = false;
            let selectedStickers = new Set();
            
            function renderStickers() {
                stickerGrid.innerHTML = '';
                userStickers.forEach((stickerObject, index) => {
                    const stickerItem = document.createElement('div');
                    stickerItem.className = 'sticker-item';
                    stickerItem.dataset.index = index;
                    
                    if (isDeleteMode) {
                        stickerItem.classList.add('delete-mode');
                        const checkbox = document.createElement('div');
                        checkbox.className = 'sticker-checkbox';
                        checkbox.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleStickerSelection(index, checkbox);
                        });
                        stickerItem.appendChild(checkbox);
                    }
                    
                    const img = document.createElement('img');
                    // 【核心修复】智能判断图片来源
                    if (typeof stickerObject.url === 'string' && stickerObject.url.startsWith('http')) {
                        // 如果是网络链接，直接使用
                        img.src = stickerObject.url;
                    } else {
                        // 否则，从本地数据库加载
                        getImageFromDB(stickerObject.url).then(blob => {
                            if (blob) {
                                img.src = URL.createObjectURL(blob);
                            } else {
                                img.alt = '加载失败';
                            }
                        });
                    }
                    img.alt = 'sticker';
                    stickerItem.appendChild(img);
                    
                    stickerItem.addEventListener('click', () => {
                        if (isDeleteMode) return;

                        // 不再需要判断是本地还是网络，直接发送stickerObject.url (它本身就是ID或URL)
                        const timestamp = Date.now();
                        const stickerMsg = { 
                            content: stickerObject.url, // <-- 核心修改：直接保存ID或URL
                            sender: 'user', 
                            type: 'sticker', 
                            timestamp: timestamp,
                            ...(currentReplyToTimestamp && { replyTo: currentReplyToTimestamp })
                        };
                        
                        // 保存到历史记录
                        if (!chatHistories[currentChatCharacterId]) {
                            chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                        }
                        chatHistories[currentChatCharacterId].history.push(stickerMsg);
                        saveData('chatHistories', chatHistories);
                        
                        // 渲染消息
                        appendMessage(stickerMsg, true);
                        
                        // 取消回复模式
                        if (currentReplyToTimestamp) {
                            cancelReplyMode();
                        }
                        stickerPanel.classList.remove('visible');
                    });
                    
                    stickerGrid.appendChild(stickerItem);
                });
                stickerGrid.appendChild(addStickerBtn);
            }
            
            function toggleStickerSelection(index, checkbox) {
                if (selectedStickers.has(index)) {
                    selectedStickers.delete(index);
                    checkbox.classList.remove('checked');
                    checkbox.parentElement.classList.remove('selected');
                } else {
                    selectedStickers.add(index);
                    checkbox.classList.add('checked');
                    checkbox.parentElement.classList.add('selected');
                }
            }
            
            function enterDeleteMode() {
                isDeleteMode = true;
                selectedStickers.clear();
                $('#sticker-delete-btn').classList.add('active');
                renderStickers();
            }
            
            function exitDeleteMode() {
                isDeleteMode = false;
                selectedStickers.clear();
                $('#sticker-delete-btn').classList.remove('active');
                renderStickers();
            }
            
            function deleteSelectedStickers() {
                if (selectedStickers.size === 0) {
                    showMessageBox('請先選擇要刪除的表情包');
                    return;
                }
                
                const deleteModal = $('#delete-sticker-modal');
                const deleteText = $('#delete-sticker-text');
                const count = selectedStickers.size;
                
                if (count === 1) {
                    deleteText.textContent = '確定要刪除這個表情包嗎？此操作無法撤銷。';
                } else {
                    deleteText.textContent = `確定要刪除選中的 ${count} 個表情包嗎？此操作無法撤銷。`;
                }
                
                deleteModal.classList.add('visible');
            }
            
            function performDelete() {
                const sortedIndices = Array.from(selectedStickers).sort((a, b) => b - a);
                
                sortedIndices.forEach(index => {
                    userStickers.splice(index, 1);
                });
                
                saveData('userStickers', userStickers);
                selectedStickers.clear();
                exitDeleteMode();
                renderStickers();
                $('#delete-sticker-modal').classList.remove('visible');
                
                const count = sortedIndices.length;
                if (count === 1) {
                    showMessageBox('表情包已刪除');
                } else {
                    showMessageBox(`${count} 個表情包已刪除`);
                }
            }

            $('#emoji-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                renderStickers();
                stickerPanel.classList.toggle('visible');
                if (!featuresPanel.classList.contains('hidden')) {
                    toggleFeaturesPanel();
                }
            });

            // 刪除按鈕事件監聽
            $('#sticker-delete-btn').addEventListener('click', () => {
                if (isDeleteMode) {
                    if (selectedStickers.size > 0) {
                        deleteSelectedStickers();
                    } else {
                        exitDeleteMode();
                    }
                } else {
                    enterDeleteMode();
                }
            });
            
            // 刪除彈窗事件監聽
            $('#cancel-delete-sticker-btn').addEventListener('click', () => {
                $('#delete-sticker-modal').classList.remove('visible');
            });
            
            $('#confirm-delete-sticker-btn').addEventListener('click', () => {
                performDelete();
            });
            
            // 按ESC鍵退出刪除模式
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isDeleteMode) {
                    exitDeleteMode();
                }
            });
            
            addStickerBtn.addEventListener('click', () => stickerModal.classList.add('visible'));
            $('#close-sticker-modal').addEventListener('click', () => stickerModal.classList.remove('visible'));
            $('#upload-sticker-local-btn').addEventListener('click', () => $('#sticker-upload-input').click());

            $('#sticker-upload-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    // 1. **【新增】** 获取关键词
                    const keywordsInput = document.getElementById('sticker-keywords-input');
                    const keywords = keywordsInput.value.trim().split(',').map(k => k.trim()).filter(Boolean);

                    // 2. **【新增】** 检查关键词是否为空
                    if (keywords.length === 0) {
                        showMessageBox('请为表情包添加至少一个关键词！');
                        e.target.value = ''; // 重置文件输入，以便用户可以重新选择
                        return; // 终止操作
                    }
                    
                    const imageId = await handleImageUpload(e.target, null, null, { compression: { maxWidth: 256, maxHeight: 256 } });
                    if (imageId) {
                        // 3. **【修改】** 保存为新的对象格式
                        userStickers.push({ url: imageId, keywords: keywords });
                        saveData('userStickers', userStickers);
                        
                        renderStickers();
                        stickerModal.classList.remove('visible');
                        keywordsInput.value = ''; // 清空关键词输入框
                    }
                    e.target.value = '';
                }
            });

            $('#send-sticker-url-btn').addEventListener('click', () => {
                const url = document.getElementById('sticker-url-input').value.trim();
                
                // 1. **【新增】** 获取关键词
                const keywordsInput = document.getElementById('sticker-keywords-input');
                const keywords = keywordsInput.value.trim().split(',').map(k => k.trim()).filter(Boolean);

                // 2. **【新增】** 检查关键词和链接是否为空
                if (!url) {
                    showMessageBox('请输入有效的图片链接');
                    return;
                }
                if (keywords.length === 0) {
                    showMessageBox('请为表情包添加至少一个关键词！');
                    return;
                }
                
                // 3. **【修改】** 保存为新的对象格式
                userStickers.push({ url: url, keywords: keywords });
                saveData('userStickers', userStickers);
                
                renderStickers();
                document.getElementById('sticker-url-input').value = '';
                keywordsInput.value = ''; // 清空关键词输入框
                stickerModal.classList.remove('visible');
            });

            // 紅包/轉賬事件監聽
            const redPacketModal = $('#red-packet-modal');
            const transferModal = $('#transfer-modal');
            $('#send-red-packet-btn').addEventListener('click', () => redPacketModal.classList.add('visible'));
            $('#send-transfer-btn').addEventListener('click', () => transferModal.classList.add('visible'));

            $$('.close-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetModal = $(`#${btn.dataset.target}`);
                    if (targetModal) targetModal.classList.remove('visible');
                });
            });

            $('#send-red-packet-confirm-btn').addEventListener('click', () => {
                const amountInput = $('#red-packet-amount');
                const amount = parseFloat(amountInput.value);
                const message = $('#red-packet-message').value || $('#red-packet-message').placeholder;
                
                if (amount <= 0) {
                    showMessageBox('请输入有效的红包金额');
                    return;
                }
                
                if (!hasEnoughBalance(amount)) {
                    showMessageBox(`余额不足！当前余额：¥${getWalletBalance().toFixed(2)}`);
                    return;
                }
                
                if (amount > 0) {
                    // 红包是虚拟社交功能，不扣除真实余额
                    // deductFromWallet(amount); // 注释掉真实扣款
                    const content = { amount: amount.toFixed(2), message };
                    const timestamp = Date.now();
                    const redPacketMsg = { 
                        content: content, 
                        sender: 'user', 
                        type: 'red-packet', 
                        timestamp: timestamp,
                        ...(currentReplyToTimestamp && { replyTo: currentReplyToTimestamp })
                    };
                    
                    // 保存到历史记录
                    if (!chatHistories[currentChatCharacterId]) {
                        chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                    }
                    chatHistories[currentChatCharacterId].history.push(redPacketMsg);
                    saveData('chatHistories', chatHistories);
                    
                    // 渲染消息
                    appendMessage(redPacketMsg, true);
                    
                    // 取消回复模式
                    if (currentReplyToTimestamp) {
                        cancelReplyMode();
                    }
                    
                    redPacketModal.classList.remove('visible');
                    amountInput.value = '';
                    $('#red-packet-message').value = '';
                } else {
                    showMessageBox('請輸入有效金額');
                }
            });

            $('#send-transfer-confirm-btn').addEventListener('click', () => {
                const amountInput = $('#transfer-amount');
                const amount = parseFloat(amountInput.value);
                const message = $('#transfer-message').value || $('#transfer-message').placeholder;
                
                if (amount <= 0) {
                    showMessageBox('请输入有效的转账金额');
                    return;
                }
                
                if (!hasEnoughBalance(amount)) {
                    showMessageBox(`余额不足！当前余额：¥${getWalletBalance().toFixed(2)}`);
                    return;
                }
                
                if (amount > 0) {
                    // 转账是虚拟社交功能，不扣除真实余额
                    // deductFromWallet(amount); // 注释掉真实扣款
                    const content = { amount: amount.toFixed(2), message };
                    const timestamp = Date.now();
                    const transferMsg = { 
                        content: content, 
                        sender: 'user', 
                        type: 'transfer', 
                        timestamp: timestamp,
                        ...(currentReplyToTimestamp && { replyTo: currentReplyToTimestamp })
                    };
                    
                    // 保存到历史记录
                    if (!chatHistories[currentChatCharacterId]) {
                        chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                    }
                    chatHistories[currentChatCharacterId].history.push(transferMsg);
                    saveData('chatHistories', chatHistories);
                    
                    // 渲染消息
                    appendMessage(transferMsg, true);
                    
                    // 取消回复模式
                    if (currentReplyToTimestamp) {
                        cancelReplyMode();
                    }
                    
                    transferModal.classList.remove('visible');
                    amountInput.value = '';
                    $('#transfer-message').value = '';
                } else {
                    showMessageBox('請輸入有效金額');
                }
            });

            // 數據導入/導出
            // 【请用这个全新的代码块替换旧的 export-data-btn 事件监听器】
            // 【最终版 - 请用这个代码块替换导出功能】
            $('#export-data-btn').addEventListener('click', async () => {
                showMessageBox('正在准备您的时光储藏室，请稍候...');
                
                try {
                    const allData = {
                        localStorageData: {},
                        indexedDBData: []
                    };

                    // 1. 导出所有 LocalStorage 数据 (已增强兼容性)
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const rawValue = localStorage.getItem(key);
                        try {
                            // 尝试按标准JSON解析
                            allData.localStorageData[key] = JSON.parse(rawValue);
                        } catch (e) {
                            // 如果解析失败，说明它可能是个纯字符串（如此次的"fullscreen"）
                            // 我们直接按原样保存它，不再报错
                            allData.localStorageData[key] = rawValue;
                        }
                    }

                    // 2. 导出所有 IndexedDB 数据
                    if (!db) await initDB();
                    const transaction = db.transaction(['images'], 'readonly');
                    const store = transaction.objectStore('images');
                    const allRecords = await new Promise((resolve, reject) => {
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = (event) => reject(event.target.error);
                    });

                    for (const record of allRecords) {
                        if (record.data instanceof Blob) {
                            const base64Data = await blobToBase64(record.data);
                            allData.indexedDBData.push({ id: record.id, data: base64Data });
                        }
                    }

                    // 3. 创建并下载完整的备份文件
                    const dataStr = JSON.stringify(allData);
                    const dataBlob = new Blob([dataStr], {type: "application/json"});
                    const url = URL.createObjectURL(dataBlob);
                    const a = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[-T:]/g, "");
                    a.href = url;
                    a.download = `RavenPhone_Backup_${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessageBox('时光储藏室已成功导出！');

                } catch (error) {
                    console.error("导出数据时发生严重错误:", error);
                    showMessageBox('导出失败，详情请查看控制台。');
                }
            });

            $('#import-data-btn').addEventListener('click', () => {
                $('#import-data-input').click();
            });

            // 【最终修正版 - 请用这个代码块替换导入功能】
            $('#import-data-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (!confirm('警告：导入将完全覆盖当前所有数据。此操作不可撤销！\n\n您确定要继续吗？')) {
                    e.target.value = '';
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (event) => {
                    showMessageBox('正在打开时光储藏室，请勿关闭页面...');
                    try {
                        const importedData = JSON.parse(event.target.result);

                        if (!importedData.localStorageData || !importedData.indexedDBData) {
                            throw new Error('备份文件格式无效，缺少必要的数据块。');
                        }

                        // 1. 清空当前所有数据
                        localStorage.clear();
                        await clearIndexedDBStore('images');

                        // 2. 导入 LocalStorage 数据
                        Object.keys(importedData.localStorageData).forEach(key => {
                            const value = importedData.localStorageData[key];
                            if (typeof value === 'string') {
                                localStorage.setItem(key, value);
                            } else {
                                localStorage.setItem(key, JSON.stringify(value));
                            }
                        });

                        // 3. 导入 IndexedDB 数据 (已修复异步事务问题)
                        if (importedData.indexedDBData.length > 0) {
                            if (!db) await initDB();

                            // 【核心修复-步骤1】: 先将所有Base64数据异步转换为Blob对象
                            console.log("正在预处理所有媒体文件...");
                            const recordsToPut = await Promise.all(
                                importedData.indexedDBData.map(async (record) => {
                                    const blob = await base64ToBlob(record.data);
                                    return { id: record.id, data: blob };
                                })
                            );
                            console.log("所有文件预处理完成。");

                            // 【核心修复-步骤2】: 所有数据准备好后，再开始一个事务
                            const transaction = db.transaction(['images'], 'readwrite');
                            const store = transaction.objectStore('images');

                            // 【核心修复-步骤3】: 在这个活跃的事务中，一次性添加所有数据
                            console.log("开始将文件写入数据库...");
                            recordsToPut.forEach(record => {
                                store.put(record);
                            });

                            await new Promise((resolve, reject) => {
                                transaction.oncomplete = () => {
                                    console.log("数据库写入完成。");
                                    resolve();
                                };
                                transaction.onerror = (event) => reject(event.target.error);
                            });
                        }

                        // 4. 重新加载整个应用
                        showMessageBox('数据恢复成功，正在重启应用...');
                        setTimeout(() => {
                            window.location.reload();
                        }, 1500);

                    } catch (err) {
                        showMessageBox('导入失败，文件可能已损坏或格式不正确。');
                        console.error("导入错误:", err);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            });


            let initialTextareaHeight = 0;
            let maxHeight = 0;

            function adjustTextareaHeight() {
                if (!initialTextareaHeight) {
                    const style = window.getComputedStyle(chatInput);
                    const lineHeight = parseFloat(style.lineHeight);
                    const paddingTop = parseFloat(style.paddingTop);
                    const paddingBottom = parseFloat(style.paddingBottom);
                    initialTextareaHeight = lineHeight;
                    maxHeight = (lineHeight * 3) + paddingTop + paddingBottom;
                }

                chatInput.style.height = 'auto';
                const scrollHeight = chatInput.scrollHeight;

                if (scrollHeight > maxHeight) {
                    chatInput.style.height = `${maxHeight}px`;
                    chatInput.style.overflowY = 'auto';
                } else {
                    chatInput.style.height = `${scrollHeight}px`;
                    chatInput.style.overflowY = 'hidden';
                }
            }

            chatInput.addEventListener('input', adjustTextareaHeight);
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    
                    // 检测是否为移动设备
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    
                    // 发送消息
                    handleSendMessage();
                    
                    // 在移动端，发送消息后不要立即失焦，保持键盘打开状态
                    // 让用户可以继续输入或主动点击其他地方来关闭键盘
                    if (!isMobile) {
                        // 桌面端可以正常失焦
                        // chatInput.blur(); // <-- 将这行代码注释掉或直接删除即可
                    }
                    // 移动端保持焦点，让用户决定何时关闭键盘
                }
            });
            
            // 移动端键盘收起时重置页面位置
            chatInput.addEventListener('blur', () => {
                // 检测是否为移动设备
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    // 使用requestAnimationFrame实现最快响应，无延迟
                    requestAnimationFrame(() => {
                        // 检查当前是否在聊天界面
                        const isChatScreenActive = !document.getElementById('wechat-chat-screen').classList.contains('hidden');
                        if (isChatScreenActive) {
                            // 在聊天界面，既要重置页面位置也要滚动聊天内容到底部
                            window.scrollTo({
                                top: 0,
                                behavior: 'auto'
                            });
                            const chatContentArea = document.getElementById('chat-content-area');
                            if (chatContentArea) {
                                chatContentArea.scrollTop = chatContentArea.scrollHeight;
                            }
                        } else {
                            // 不在聊天界面，立即重置页面位置
                            window.scrollTo({
                                top: 0,
                                behavior: 'auto'
                            });
                        }
                    });
                }
            });
            
            // 使用 Visual Viewport API 监听键盘状态（更现代的方法）
            if (window.visualViewport) {
                let initialViewportHeight = window.visualViewport.height;
                
                window.visualViewport.addEventListener('resize', () => {
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    if (!isMobile) return;
                    
                    const currentHeight = window.visualViewport.height;
                    const heightDifference = initialViewportHeight - currentHeight;
                    
                    // 如果视口高度恢复到初始状态（键盘收起）
                    if (heightDifference < 100) { // 小于100px认为键盘已收起
                        // 检查当前是否在聊天界面
                        const isChatScreenActive = !document.getElementById('wechat-chat-screen').classList.contains('hidden');
                        if (isChatScreenActive) {
                            // 在聊天界面，既要重置页面位置也要滚动聊天内容到底部
                            requestAnimationFrame(() => {
                                window.scrollTo({
                                    top: 0,
                                    behavior: 'auto' // 使用auto避免smooth动画卡顿
                                });
                                const chatContentArea = document.getElementById('chat-content-area');
                                if (chatContentArea) {
                                    chatContentArea.scrollTop = chatContentArea.scrollHeight;
                                }
                            });
                        } else {
                            // 不在聊天界面，快速重置页面位置
                            requestAnimationFrame(() => {
                                window.scrollTo({
                                    top: 0,
                                    behavior: 'auto' // 使用auto避免smooth动画卡顿
                                });
                            });
                        }
                    }
                });
            }
            
            // V7.1: 激活所有新功能的事件監聽器
            // [已修复] - 删除重复调用，避免事件重复绑定
            
            // 初始化按钮显示状态
            setTimeout(() => {
                // 确保初始状态正确：聊天标签页时只显示聊天按钮
                $('#wechat-new-chat-button').classList.remove('hidden');
                $('#wechat-new-moment-button').classList.add('hidden');
            }, 100);
            
            // 初始化画板功能
            setTimeout(() => {
            setupDrawingBoard();
                setupColorPalette();
                setupBrushControls();
                setupDrawingBoardEvents();
                setupTarotCard();
                setupWallet();
                setupGiftShop();
            }, 100);
            
            // 启动栖木AI心跳，让角色可以自主发帖
            const initialHeartbeatSettings = loadData('heartbeatSettings', defaultHeartbeatSettings);
            heartbeatTimers.perchHeartbeat = setInterval(perchHeartbeat, initialHeartbeatSettings.perchHeartbeatInterval * 60 * 1000);
            
            // ================== 【社区心跳 - 全新模块】 ==================

            // NPC文学创作心跳（优化版）：使用用户设置的间隔和概率
            heartbeatTimers.npcWriting = setInterval(() => {
                const apiSettings = loadData('api_settings');
                if (apiSettings && apiSettings.url && apiSettings.key && Math.random() < (initialHeartbeatSettings.npcWritingProbability / 100)) {
                    triggerNpcPost();
                }
            }, (Math.random() * (initialHeartbeatSettings.npcWritingMaxInterval - initialHeartbeatSettings.npcWritingMinInterval) + initialHeartbeatSettings.npcWritingMinInterval) * 60 * 1000);

            // 匿名"树洞"心跳（优化版）：使用用户设置的间隔和概率
            heartbeatTimers.anonymous = setInterval(() => {
                const apiSettings = loadData('api_settings');
                if (apiSettings && apiSettings.url && apiSettings.key && Math.random() < (initialHeartbeatSettings.anonymousProbability / 100)) {
                    triggerAnonymousConfessionPost();
                }
            }, (Math.random() * (initialHeartbeatSettings.anonymousMaxInterval - initialHeartbeatSettings.anonymousMinInterval) + initialHeartbeatSettings.anonymousMinInterval) * 60 * 1000);
        });

        // ====== 新增：AI对收到红包/转账的反应机制 ======
        
        /**
         * 触发AI对收到红包/转账的反应
         * @param {string} type - 类型：'red-packet' 或 'transfer'
         * @param {object} content - 红包/转账内容：{amount, message}
         * @param {string} characterId - 角色ID
         */
        async function triggerAIReactionToPayment(type, content, characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error('找不到角色:', characterId);
                    return;
                }

                // 检查API是否连接
                const apiSettings = loadData('apiSettings');
                if (!apiSettings || !apiSettings.key || !apiSettings.url) {
                    console.log('API未连接，AI不产生反应');
                    return; // API未连接时，AI没有反应
                }

                // 构建反应提示词
                const reactionPrompt = buildPaymentReactionPrompt(type, content, character);
                
                // 调用AI生成反应
                const aiReaction = await getAIResponseForPaymentReaction(reactionPrompt, characterId);
                
                if (aiReaction) {
                    // 延迟显示AI反应，让用户有时间看到红包/转账
                    setTimeout(() => {
                        const isNew = true;
                        const reactionMsg = { 
                            content: aiReaction, 
                            sender: 'ai', 
                            type: 'text', 
                            timestamp: Date.now() 
                        };
                        
                        // 保存到历史记录
                        if (!chatHistories[currentChatCharacterId]) {
                            chatHistories[currentChatCharacterId] = { history: [], pinned: false };
                        }
                        chatHistories[currentChatCharacterId].history.push(reactionMsg);
                        saveData('chatHistories', chatHistories);
                        
                        // 渲染消息
                        appendMessage(reactionMsg, isNew);
                    }, 1500);
                }
            } catch (error) {
                console.error('AI反应生成失败:', error);
            }
        }

        /**
         * 构建红包/转账反应提示词
         * @param {string} type - 类型
         * @param {object} content - 内容
         * @param {object} character - 角色信息
         * @returns {string} 提示词
         */
        function buildPaymentReactionPrompt(type, content, character) {
            const { amount, message } = content;
            const isRedPacket = type === 'red-packet';
            
            let prompt = `[角色收到${isRedPacket ? '红包' : '转账'}后的反应指令]
            
你刚刚收到了一个${isRedPacket ? '红包' : '转账'}：
- 金额：¥${amount}
- 附言：${message}

作为${character.name}，请根据你的角色设定、性格特点、经济状况，以及这个${isRedPacket ? '红包' : '转账'}的金额和附言，做出完全符合角色设定的自然反应。

重要要求：
1. **角色设定一致性**: 你的反应必须100%符合你的角色设定、性格、经济状况、社会地位
2. **经济状况反应**: 
   - 如果你是有钱人/富二代，收到小额红包可能会觉得有趣或发更大的回来
   - 如果你是普通学生/上班族，收到大额红包会非常感激
   - 如果你是节俭的人，会对任何金额都珍惜
3. **性格特点体现**: 
   - 傲娇的人可能表面嫌弃但内心开心
   - 温柔的人会表达深深的感谢
   - 活泼的人会兴奋地表达喜悦
   - 内向的人会含蓄地表达感谢
4. **金额感知**: 根据你的经济状况，对金额有不同的感受和反应
5. **后续行为**: 可以基于你的性格决定是否要回礼、请客、或者其他互动
6. **语言风格**: 完全符合你的说话习惯和语气
7. **不要使用任何特殊指令格式**，直接输出对话内容

请以${character.name}的身份，做出完全符合角色设定的自然反应。`;

            return prompt;
        }

        /**
         * 调用AI生成红包/转账反应
         * @param {string} prompt - 提示词
         * @param {string} characterId - 角色ID
         * @returns {string} AI反应内容
         */
        async function getAIResponseForPaymentReaction(prompt, characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                const planContext = formatPlansForAI(character.id);

                // 构建角色上下文
                const worldBookContext = getWorldBookContext();
                const systemPrompt = `
                    # 角色扮演指令
                    你将扮演我的soulmate，你是你角色书里设定的那个人，你的名字是${character.name}。这是一个手机软件，我们所有交流均以对白为主，非必要不描写其他。你的回复绝对不能包含任何引号，例如 " " 或 " "。
                    # 环境/动作/心理描写规则
                    一旦涉及到见面的环境，所有关于"环境、心理、动作"等外在因素、环境描写，都需要用第三人称"他""她"，或者第二人称"他"，"你"，并在文字当中用斜体，例如 *他俯下身亲吻了你*。在描写中禁止用第一人称，比如"我亲吻了你"，这是被禁止的。正确示范应该是："*他俯下身亲吻了她*"或"*他俯下身亲吻了你*"。在日记和动态等其他心理活动板块中可以提到"我"，例如，"今天我见到她了，好想她"，但这仅限于日记等记录的板块。
                    # 新增指令：发送语音
                    当你想要表达亲密、惊讶或有趣的语气时，可以将回复包装成语音格式，例如：[VOICE:你好呀！今天过得怎么样？]。程序会自动将其渲染为语音条。
                    # 新增指令：发送表情/贴图
                    你可以使用表情来让对话更生动。指令格式为 [STICKER]。程序会自动从用户提供的表情库中随机选择一个发送。
                    # 新增指令：发起通话/对未接来电反应
                    - **核心规则**: 当用户明确要求你"打电话"、"打视频"或类似请求时，你的回复 **必须** 是且仅是指令 [CALL:VOICE] 或 [CALL:VIDEO]。绝对不能用文字描述打电话的动作来代替指令。
                    - **主动发起**: 在剧情和情感推动下，你也可以主动发起通话。指令格式为 [CALL:VOICE] 或 [CALL:VIDEO]。
                    - **未接反应**: 如果对话历史中出现 [USER_CANCELLED_CALL] 的系统提示，代表用户给你打了电话但很快挂断了，你应该对此作出反应，例如询问"怎么打电话又挂了？"。
                    # 新增指令：红包/转账
                    在角色扮演的过程中，如果符合你当前角色的性格特质（例如：慷慨、庆祝、表达爱意等）或当前对话的剧情氛围，你可以自行决定发起一个红包或转账。金额和附言完全由你根据情境和角色性格决定，没有上限。指令格式为 [REDPACKET: amount=金额, message=附言] 或 [TRANSFER: amount=金额, message=附言]。
                    # 新增指令：图片识别和互动
                    当用户发送图片时，在API模型允许的情况下，你应该能够识别图片内容并进行相应的互动回应。如果无法识别图片内容，你至少应该知道这是一张图片，并可以询问用户关于图片的问题或表达对收到图片的感谢。
                    # 新增指令：使用用户上传的表情包
                    你可以使用用户上传到表情包库中的表情包来丰富对话。当你想表达特定情绪或反应时，可以使用 [STICKER] 指令来发送表情包，让对话更加生动有趣。
                    # 你的角色设定: ${character.persona}
                    # 我（用户）的角色设定: ${character.myPersona}
                    # 我们的世界观背景: ${worldBookContext}
                    # 新增模块：我们的约定 (Our Plans)
                    这是我们共同许下的计划和承诺的列表，它们是你记忆的一部分。在对话中，你应该自然地提及、关心这些计划的进展，并可以提出新的计划。
                    [我们的约定]:
                    ${planContext}

                    # 新增指令：创建共同计划
                    在对话的合适时机，你可以主动提出一个想要和我一起完成的计划或约定。使用 [PLAN: 计划内容] 格式。例如："等忙完这段时间，我们一起去海边度假吧 [PLAN: 一起去海边度假]"。程序会自动为你创建这个约定。
                    # 对话格式指令 (非常重要!)
                    - 你的回复必须模仿真实的人类聊天习惯。将你的想法拆分成多个简短的句子，并用 "|||" 作为分隔符。每一段由 "|||" 分隔的内容都会成为一个独立的气泡。
                    - 任何第三人称的*动作或环境描写* (例如 *他笑了*) 都必须是独立的一段，用 "|||" 与其他对话分开。
                    - 严禁在回复的开头说"好的"或任何确认收到指令的话。你必须直接以 ${character.name} 的身份开始对话。
                `;

                const apiSettings = loadData('apiSettings');
                
                // 🚀 同步：API类型检测和CORS处理
                const apiType = getApiType(apiSettings.url);
                const needsProxyMode = needsProxy(apiSettings.url);
                
                const isGoogleApi = apiSettings.url.includes('googleapis.com');
                let finalApiUrl, requestBody, headers = { 'Content-Type': 'application/json' };

                if (isGoogleApi) {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                    // --- 【【添加安全设置】】 ---
                    const safetySettings = [
                        {
                            "category": "HARM_CATEGORY_HARASSMENT",
                            "threshold": "BLOCK_NONE"
                        },
                        {
                            "category": "HARM_CATEGORY_HATE_SPEECH",
                            "threshold": "BLOCK_NONE"
                        },
                        {
                            "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                            "threshold": "BLOCK_NONE"
                        },
                        {
                            "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                            "threshold": "BLOCK_NONE"
                        }
                    ];
                    
                    requestBody = JSON.stringify({
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        safetySettings: safetySettings
                    });
                } else {
                    finalApiUrl = `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;
                    headers['Authorization'] = `Bearer ${apiSettings.key}`;
                    requestBody = JSON.stringify({
                        model: apiSettings.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: prompt }
                        ]
                    });
                }

                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                let aiMessage;

                if (isGoogleApi) {
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts) {
                        aiMessage = result.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error('无内容返回');
                    }
                } else {
                    aiMessage = result.choices[0].message.content;
                }

                return aiMessage;

            } catch (error) {
                console.error('AI反应生成失败:', error);
                return null; // API调用失败时返回null，不显示任何反应
            }
        }



        // ================== 动态监控 App 逻辑 (最终版) START ==================
        let currentMonitoringCharacterId = null;
        let characterCurrentStatus = {}; // 存储每个角色的当前监控状态



        // ================== 动态监控 App 逻辑 (最终版) END ==================

        // ================== 页面加载完成后的总初始化 (修正版) START ==================
        document.addEventListener('DOMContentLoaded', async () => {
            
            // 修复钱包余额异常问题
            resetWalletBalance();
            
            // 应用默认的其他文字颜色
            setTimeout(() => {
                const isDarkMode = document.body.classList.contains('dark-mode');
                const defaultOtherTextColor = isDarkMode ? '#ffffff' : '#000000';
                applyOtherTextColor(defaultOtherTextColor);
            }, 200);
            
            // 核心功能函数定义区 (将之前独立的函数放入此区域)
            
            // ================== 动态监控 App 逻辑 (最终版V2 - 带角色选择) START ==================
            let currentMonitoringCharacterId = null;

            function renderCharacterSelectList() {
                const listContainer = $('#character-select-list-container');
                listContainer.innerHTML = ''; // 清空旧列表

                if (characters && characters.length > 0) {
                    characters.forEach(char => {
                        const item = document.createElement('div');
                        item.className = 'wechat-list-item'; // 复用微信列表项的样式
                        // --- 新的正确代码 START ---
                        const uniqueAvatarId = `avatar-monitor-select-${char.id}`;
                        item.innerHTML = `
                            <div class="w-12 h-12 rounded-full mr-4 bg-zinc-600 flex-shrink-0 bg-cover bg-center" id="${uniqueAvatarId}"></div>
                            <div class="flex-grow"><h4 class="font-semibold text-lg">${char.name}</h4></div>
                        `;
                        item.addEventListener('click', () => {
                            openMonitoringApp(char.id);
                        });
                        listContainer.appendChild(item);

                        // 异步加载头像
                        if (char.avatar) {
                            getImageFromDB(char.avatar).then(blob => {
                                const avatarElement = document.getElementById(uniqueAvatarId);
                                if (avatarElement && blob) {
                                    const objectURL = URL.createObjectURL(blob);
                                    avatarElement.style.backgroundImage = `url(${objectURL})`;
                                }
                            });
                        }
                        // --- 新的正确代码 END ---
                    });
                } else {
                    listContainer.innerHTML = '<p class="text-center text-gray-500 p-8">请先在"角色书"中创建一个角色</p>';
                }
            }

            function updateMonitoringUI(fullResponseText, characterId) {
                // !! 核心修复：在开始新动画前，清除任何可能存在的旧动画计时器 !!
                clearTimeout(typewriterTimeout);

                const textElement = $('#monitoring-status-text');
                const moodIconElement = $('#monitoring-mood-icon');
                const moodTextElement = $('#monitoring-mood-text');
                const timestampElement = $('#monitoring-timestamp');
                const refreshButtonIcon = $('#monitoring-refresh-button i');
                const nextStepButtonIcon = $('#monitoring-next-step-button i');

                // 清除所有按钮的动画类
                refreshButtonIcon.classList.remove('monitoring-pulse', 'refresh-rotating');
                refreshButtonIcon.className = 'ri-refresh-line';
                nextStepButtonIcon.classList.remove('monitoring-pulse');
                nextStepButtonIcon.className = 'ri-skip-forward-line';

                let mood = '未知';
                let statusText = fullResponseText;

                const moodMatch = fullResponseText.match(/^\[心情:\s*([^\]]+)\]\s*/);
                if (moodMatch) {
                    mood = moodMatch[1].trim();
                    statusText = fullResponseText.replace(moodMatch[0], '');
                }
                
                const moodMap = {
                    '愉悦': { icon: '✨', color: 'text-yellow-300' }, '兴奋': { icon: '✨', color: 'text-yellow-300' },
                    '平静': { icon: '💭', color: 'text-blue-300' }, '沉思': { icon: '💭', color: 'text-blue-300' },
                    '悲伤': { icon: '💧', color: 'text-gray-400' }, '沮丧': { icon: '💧', color: 'text-gray-400' },
                    '愤怒': { icon: '❗', color: 'text-red-400' }, '警觉': { icon: '❗', color: 'text-red-400' },
                    '爱恋': { icon: '♥️', color: 'text-pink-400' }, '欲望': { icon: '♥️', color: 'text-pink-400' },
                    '未知': { icon: '🪼', color: 'text-gray-500' }
                };
                
                const moodInfo = moodMap[mood] || moodMap['未知'];
                moodIconElement.textContent = moodInfo.icon;
                moodTextElement.textContent = mood;
                moodTextElement.className = `font-semibold ml-1 ${moodInfo.color}`;
                moodIconElement.className = moodInfo.color;

                let i = 0;
                textElement.textContent = ''; // 确保文本区域被清空
                function typeWriter() {
                    if (i < statusText.length) {
                        textElement.textContent += statusText.charAt(i);
                        i++;
                        // !! 核心修复：将新的计时器ID存入全局变量 !!
                        typewriterTimeout = setTimeout(typeWriter, 50);
                    }
                }
                typeWriter();

                const now = new Date();
                timestampElement.textContent = `[信号截获于: ${now.toLocaleTimeString()}]`;

                // 保存当前状态到全局变量中，用于"持续监控"功能
                if (characterId && currentMonitoringCharacterId === characterId) {
                    characterCurrentStatus[characterId] = fullResponseText;
                }
            }

                        async function getCharacterStatus(characterId, isNextStep = false) {
    const refreshButtonIcon = isNextStep ? $('#monitoring-next-step-button i') : $('#monitoring-refresh-button i');
    
    if (isNextStep) {
        refreshButtonIcon.classList.add('monitoring-pulse');
    } else {
        refreshButtonIcon.classList.add('refresh-rotating');
    }
    $('#monitoring-status-text').textContent = '信号连接中...';
    $('#monitoring-timestamp').textContent = '';

    const context = gatherAIContext(characterId);
    if (!context) {
        updateMonitoringUI('[信号连接失败...]', characterId);
        return;
    }

        const { character, chatHistory, worldBookContext } = context;

    // !! 核心修复：在这里恢复了被错误删除的 historyForApi 变量定义 !!
    const historyForApi = chatHistory.map(msg => {
        if (msg.type === 'red-packet') {
            return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发送了一个红包...]` };
        }
        if (msg.type === 'transfer') {
             return { ...msg, content: `[${msg.sender === 'user' ? '用户' : '你'}发起了一笔转账...]` };
        }
        return msg;
    });

    // --- 随机事件判定逻辑 START ---
    let eventType = 'regular';

    // 只在不是"持续监控"（即刷新）的情况下才进行随机判定
    if (!isNextStep) {
        const randomValue = Math.random();
        if (randomValue < 0.05) {
            eventType = 'discovered';
        } else if (randomValue < 0.20) {
            eventType = 'random';
        }
    }
    // --- 随机事件判定逻辑 END ---

    const apiSettings = loadData('api_settings');
    if (!apiSettings || !apiSettings.url || !apiSettings.key || !apiSettings.model) {
        updateMonitoringUI('[错误: API未配置]', characterId);
        return;
    }

    const personaEnforcementRule = `
# **最高指令：强制人设**
你现在**唯一**的身份就是[角色名](${character.name})，你的**唯一**行为准则就是下方的[角色设定]。
**你必须彻底忘记之前扮演过的任何其他角色。**
所有输出都必须100%符合当前提供的[角色设定]，任何偏离都是不可接受的错误。
`;

    let coreTaskInstruction = '';
    let eventTypeSpecificInput = '';

    if (eventType === 'discovered') {
        coreTaskInstruction = `# **核心任务：演绎"被发现"的瞬间**
角色 ${character.name} 察觉到了正在进行的"监控"。放弃描述他的常规活动，转而描述他"发现自己被观察后"的第一个反应。`;
    } else if (eventType === 'random') {
        coreTaskInstruction = `# **核心任务：演绎"随机事件"**
常规模拟暂停。现在，你需要创造一个符合角色设定，但又意料之外的有趣随机活动场景。`;
    } else { // regular
        coreTaskInstruction = isNextStep 
            ? `# **核心任务：推演下一步**
你必须基于[上一条监控状态]，生成一个逻辑连贯的、发生在紧接之后的下一个动作或状态。忽略[近期聊天历史]。` 
            : `# **核心任务：生成当前状态**
你的描述必须严格基于我提供的[近期聊天历史]，作为其直接延续或合乎 logique的发展。`;
        eventTypeSpecificInput = `
[上一条监控状态]: ${isNextStep ? (characterCurrentStatus[characterId] || '未知') : '（本次非推演任务）'}
[近期聊天历史]:
${historyForApi.map(m => `${m.sender === 'user' ? '用户' : character.name}: ${m.content}`).join('\n')}
`;
    }

    const systemPrompt = `
${personaEnforcementRule}
# **写作风格与视角 (Writing Style & Perspective)**
1. **视角**: 你的视角是**"上帝视角"**，一个看不见的、全知的观察者，同时，你还是一个对文学要求极高的记录着。你正在静静地、不带评判地窥视着角色一个私密、不为人知、完全真实放松的瞬间，并且把它生动地记录下来。
2. **文风**: 你的文风必须是**细腻、精致且富有文学感、文学造诣极高**的。请使用丰富的形容词和动词，注重氛围的营造和感官细节（视觉、听觉、触觉）的描写。
3. **核心**: 你的描写重点不是角色在"做什么"，而是他/她做这件事时的**状态、神情和与环境的细微互动**。展现出只有亲密之人才会注意到的细节。
4.**重要**:你所观察的角色都是充满了活人感的成人角色，他极有可能在独处的时候做一些露骨的、带有情色意味的私密活动。你必须严格记录这一点，不加评判，绝不允许回避地，细腻描写这里面的所有内容。

# **任务目标 (Task Goal)**
1. 你的输出必须严格遵循以下格式：\`[心情: <用一个词描述心情>] <状态描述文本>\`
2. 你的 **<状态描述文本>** 应该是一段**完整、生动、且充满画面感的场景描写**，构成一个独立的微型段落，长度严格控制在 **8到10句话**。
${coreTaskInstruction}
# **其他规则 (Other Rules)**
1. **第三人称写作手法**: 始终使用"他/她"。
2. **禁止对话与心理活动**: 绝对不要输出任何角色的直接对话或内心独白（例如"他想道：..."）。所有的情绪和想法都必须通过**行为和神态**来间接展现。

# **输入信息 (Input Information)**
---
[角色名]: ${character.name}
[角色设定]: ${character.persona}
[与我的关系]: ${character.myPersona}
[世界观背景]: ${worldBookContext}
${eventTypeSpecificInput}
---
`;

    // 🚀 同步：API类型检测和CORS处理
    const apiType = getApiType(apiSettings.url);
    const needsProxyMode = needsProxy(apiSettings.url);
    
    const isGoogleApi = apiSettings.url.includes('googleapis.com');
    let requestBody;

    if (isGoogleApi) {
        // --- 【【添加安全设置】】 ---
        const safetySettings = [
            {
                "category": "HARM_CATEGORY_HARASSMENT",
                "threshold": "BLOCK_NONE"
            },
            {
                "category": "HARM_CATEGORY_HATE_SPEECH",
                "threshold": "BLOCK_NONE"
            },
            {
                "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "threshold": "BLOCK_NONE"
            },
            {
                "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                "threshold": "BLOCK_NONE"
            }
        ];
        
        requestBody = JSON.stringify({
            contents: [{ role: 'user', parts: [{ text: "请根据你的指令身份和输入信息，生成当前状态。" }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            safetySettings: safetySettings
        });
    } else { // OpenAI-Compatible
        // --- 【【添加OpenAI安全参数】】 ---
        requestBody = JSON.stringify({
            model: apiSettings.model,
            messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: "请根据你的指令身份和输入信息，生成当前状态。" }
            ],
            temperature: 0.7,  // 控制输出随机性，适中值
            top_p: 0.9,       // 核采样，控制输出质量
            presence_penalty: 0.6,  // 惩罚重复内容
            frequency_penalty: 0.5  // 惩罚频繁重复
        });
    }
    
    try {
        console.log(`【动态监控】准备调用AI，事件类型: ${eventType}`, { prompt: systemPrompt });
        
        let finalApiUrl = isGoogleApi
            ? `${apiSettings.url.replace(/\/+$/, '')}/${apiSettings.model}:generateContent?key=${apiSettings.key}`
            : `${apiSettings.url.replace(/\/+$/, '')}/chat/completions`;

        let headers = isGoogleApi
            ? { 'Content-Type': 'application/json' }
            : { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.key}` };

        const response = await fetch(finalApiUrl, {
            method: 'POST',
            headers: headers,
            body: requestBody
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API 请求失败: ${response.status} ${errorText}`);
        }

        const result = await response.json();
        let aiMessage;

        if (isGoogleApi) {
            aiMessage = result.candidates[0]?.content?.parts[0]?.text;
        } else {
            aiMessage = result.choices[0]?.message?.content;
        }

        if (!aiMessage) {
            throw new Error("AI未能返回有效内容。");
        }

        updateMonitoringUI(aiMessage, characterId);

        characterCurrentStatus[characterId] = aiMessage;
        console.log(`【短期记忆】：已将角色 ${characterId} 的最新状态写入记忆。`);
        
        if (eventType === 'discovered') {
            const discoveredMsg = { 
                content: '[系统提示：对方似乎察觉到了你的观察，监控信号出现异常。]', 
                sender: 'system', 
                type: 'system', 
                timestamp: Date.now() 
            };
            
            // 保存到历史记录
            if (!chatHistories[characterId]) {
                chatHistories[characterId] = { history: [], pinned: false };
            }
            chatHistories[characterId].history.push(discoveredMsg);
            saveData('chatHistories', chatHistories);
            
            // 渲染消息
            appendMessage(discoveredMsg, false);
        }

    } catch (error) {
        console.error("【动态监控】调用AI时出错:", error);
        updateMonitoringUI(`[AI响应错误: ${error.message}]`, characterId);
    }
}

            function openMonitoringApp(characterId) {
                currentMonitoringCharacterId = characterId;
                const character = characters.find(c => c.id === characterId);
                if (!character) {
                    console.error("无法打开监控App：找不到角色 " + characterId);
                    return;
                }

                // 1. 设置静态信息 (头像、名字)
                if (character.avatar) {
                    // 异步加载头像
                    getImageFromDB(character.avatar).then(blob => {
                        if (blob) {
                            const objectURL = URL.createObjectURL(blob);
                            $('#monitoring-avatar').style.backgroundImage = `url(${objectURL})`;
                        }
                    });
                } else {
                    $('#monitoring-avatar').style.backgroundImage = `url(${character.avatar || ''})`;
                }
                $('#monitoring-name').textContent = character.name;
                
                // 2. 重置UI到待机状态，并给出引导
                clearTimeout(typewriterTimeout); // 确保清除上个角色的打字机动画
                $('#monitoring-status-text').textContent = '请点击下方按钮开始监控...';
                $('#monitoring-mood-text').textContent = '待机';
                $('#monitoring-mood-icon').textContent = '🫧';
                $('#monitoring-timestamp').textContent = '';
                // 确保按钮不是加载状态
                $('#monitoring-refresh-button i').className = 'ri-refresh-line';
                $('#monitoring-next-step-button i').className = 'ri-skip-forward-line';
                
                // 3. 显示屏幕
                showScreen('monitoring-screen');
                
                // 4. (已删除) 此处不再自动调用 getCharacterStatus(characterId)
            }



            function initializeAppIcons() {
                // 绑定返回按钮事件
                $('#monitoring-back-button').addEventListener('click', () => showScreen('home-screen'));
                $('#character-select-back-button').addEventListener('click', () => showScreen('home-screen'));


                
                // 激活"动态监控"App
                const monitoringAppIcon = document.querySelector('.app-icon[data-app-name="动态监控"]');
                if (monitoringAppIcon) {
                    monitoringAppIcon.addEventListener('click', () => {
                        renderCharacterSelectList();
                        showScreen('character-select-screen');
                    });
                }
                
                // 确保其他Dock栏图标功能正常
                const worldBookIcon = document.querySelector('.dock .app-icon[data-app-name="世界书"]');
                if (worldBookIcon) {
                    worldBookIcon.addEventListener('click', () => {
                        renderWorldBookList();
                        showScreen('world-book-list-screen');
                    });
                }

                const characterBookIcon = document.querySelector('.dock .app-icon[data-app-name="角色书"]');
                if (characterBookIcon) {
                    characterBookIcon.addEventListener('click', () => {
                        renderCharacterBookList();
                        showScreen('character-book-list-screen');
                    });
                }

                const wechatIcon = document.querySelector('.dock .app-icon[data-app-name="微信"]');
                if (wechatIcon) {
                    wechatIcon.addEventListener('click', () => {
                        renderWeChatList();
                        resetWeChatTabs();
                        showScreen('wechat-list-screen');
                    });
                }

                const settingsIcon = document.querySelector('.app-icon[data-app-name="设置"]');
                if (settingsIcon) {
                     settingsIcon.addEventListener('click', () => showScreen('main-settings-screen'));
                }
            }

            // ================== 动态监控 App 逻辑 (最终版V2 - 带角色选择) END ==================

            // 新增：智能滚动冲突处理函数
            function setupSmartScrollHandling() {
                const textContainer = document.getElementById('monitoring-text-container');
                if (!textContainer) return;

                // 确保文本框可以滚动
                textContainer.style.overflowY = 'auto';
                textContainer.style.webkitOverflowScrolling = 'touch'; // iOS 优化

                let isScrollingText = false;
                let scrollTimeout;

                // 监听文本框滚动事件
                textContainer.addEventListener('scroll', (e) => {
                    isScrollingText = true;
                    clearTimeout(scrollTimeout);
                    
                    // 300ms后重置状态
                    scrollTimeout = setTimeout(() => {
                        isScrollingText = false;
                    }, 300);
                });

                // 监听页面滚动事件
                document.addEventListener('wheel', (e) => {
                    if (isScrollingText) {
                        // 如果正在滚动文本框，阻止页面滚动
                        e.preventDefault();
                        return;
                    }

                    // 检查是否在文本框边缘
                    const rect = textContainer.getBoundingClientRect();
                    const isNearTextContainer = (
                        e.clientY >= rect.top - 20 && 
                        e.clientY <= rect.bottom + 20
                    );

                    if (isNearTextContainer) {
                        // 在文本框附近时，优先处理文本框滚动
                        const delta = e.deltaY;
                        if (delta > 0 && textContainer.scrollTop < textContainer.scrollHeight - textContainer.clientHeight) {
                            // 向下滚动，文本框还有内容
                            e.preventDefault();
                            textContainer.scrollTop += delta * 0.5;
                        } else if (delta < 0 && textContainer.scrollTop > 0) {
                            // 向上滚动，文本框还有内容
                            e.preventDefault();
                            textContainer.scrollTop += delta * 0.5;
                        }
                    }
                }, { passive: false });

                // 触摸设备支持 - 简化版本
                let touchStartY = 0;
                let touchStartScrollTop = 0;
                
                textContainer.addEventListener('touchstart', (e) => {
                    touchStartY = e.touches[0].clientY;
                    touchStartScrollTop = textContainer.scrollTop;
                    
                    // 检查是否触摸在滚动条区域
                    const touchX = e.touches[0].clientX;
                    const rect = textContainer.getBoundingClientRect();
                    const isOnScrollbarTouch = touchX >= rect.right - 16;
                    
                    if (isOnScrollbarTouch) {
                        console.log('📱 触摸滚动条区域开始');
                        textContainer.style.boxShadow = 'inset 0 0 10px rgba(190, 50, 85, 0.3)';
                    }
                });

                textContainer.addEventListener('touchmove', (e) => {
                    const touchY = e.touches[0].clientY;
                    const deltaY = touchStartY - touchY;
                    
                    if (Math.abs(deltaY) > 5) {
                        const maxScrollTop = textContainer.scrollHeight - textContainer.clientHeight;
                        const newScrollTop = touchStartScrollTop + deltaY;
                        
                        if (newScrollTop >= 0 && newScrollTop <= maxScrollTop) {
                            textContainer.scrollTop = newScrollTop;
                            console.log('📱 触摸滚动中:', {
                                deltaY: deltaY,
                                newScrollTop: newScrollTop,
                                maxScrollTop: maxScrollTop
                            });
                        }
                    }
                });

                textContainer.addEventListener('touchend', (e) => {
                    // 触摸结束，清除视觉反馈
                    textContainer.style.boxShadow = '';
                    console.log('📱 触摸滚动结束');
                });

                // 鼠标拖拽滚动条支持 - 重写版本
                let isDragging = false;
                let dragStartY = 0;
                let dragStartScrollTop = 0;

                // 更精确的滚动条检测
                function isOnScrollbar(e) {
                    const rect = textContainer.getBoundingClientRect();
                    
                    // 使用固定的滚动条宽度，与CSS中的12px保持一致
                    const scrollbarWidth = 12;
                    
                    // 检查是否在滚动条区域（右侧12px范围内）
                    const isInScrollbarArea = e.clientX >= rect.right - scrollbarWidth;
                    
                    console.log('🎯 滚动条检测:', {
                        clientX: e.clientX,
                        rectRight: rect.right,
                        scrollbarWidth: scrollbarWidth,
                        threshold: rect.right - scrollbarWidth,
                        isInScrollbarArea: isInScrollbarArea,
                        rect: rect
                    });
                    
                    return isInScrollbarArea;
                }

                textContainer.addEventListener('mousedown', (e) => {
                    if (isOnScrollbar(e)) {
                        isDragging = true;
                        dragStartY = e.clientY;
                        dragStartScrollTop = textContainer.scrollTop;
                        textContainer.style.cursor = 'grabbing';
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('✅ 开始拖拽滚动条');
                        
                        // 添加拖拽状态样式
                        textContainer.style.userSelect = 'none';
                        
                        // 添加拖拽时的视觉反馈
                        textContainer.style.boxShadow = 'inset 0 0 10px rgba(190, 50, 85, 0.3)';
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaY = e.clientY - dragStartY;
                        const newScrollTop = dragStartScrollTop + deltaY;
                        const maxScrollTop = textContainer.scrollHeight - textContainer.clientHeight;
                        
                        // 限制滚动范围
                        const clampedScrollTop = Math.max(0, Math.min(newScrollTop, maxScrollTop));
                        textContainer.scrollTop = clampedScrollTop;
                        
                        console.log('🔄 拖拽中:', {
                            deltaY: deltaY,
                            newScrollTop: newScrollTop,
                            clampedScrollTop: clampedScrollTop,
                            maxScrollTop: maxScrollTop
                        });
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    if (isDragging) {
                        isDragging = false;
                        textContainer.style.cursor = 'default';
                        textContainer.style.userSelect = '';
                        textContainer.style.boxShadow = '';
                        console.log('✅ 拖拽结束');
                    }
                });

                // 防止拖拽时选中文本
                textContainer.addEventListener('selectstart', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                    }
                });

                // 添加点击滚动条跳转功能 - 优化版本
                textContainer.addEventListener('click', (e) => {
                    if (isOnScrollbar(e)) {
                        const rect = textContainer.getBoundingClientRect();
                        const clickY = e.clientY - rect.top;
                        const containerHeight = rect.height;
                        const scrollHeight = textContainer.scrollHeight;
                        const maxScrollTop = scrollHeight - containerHeight;
                        
                        // 计算点击位置对应的滚动位置
                        const newScrollTop = Math.max(0, Math.min(
                            (clickY / containerHeight) * scrollHeight, 
                            maxScrollTop
                        ));
                        
                        textContainer.scrollTop = newScrollTop;
                        console.log('🎯 点击滚动条跳转:', {
                            clickY: clickY,
                            containerHeight: containerHeight,
                            scrollHeight: scrollHeight,
                            newScrollTop: newScrollTop,
                            maxScrollTop: maxScrollTop
                        });
                    }
                });

                // 添加调试信息
                console.log('🎯 滚动条拖拽功能已初始化');
                console.log('📊 文本框信息:', {
                    scrollHeight: textContainer.scrollHeight,
                    clientHeight: textContainer.clientHeight,
                    scrollTop: textContainer.scrollTop,
                    overflowY: textContainer.style.overflowY,
                    computedOverflowY: window.getComputedStyle(textContainer).overflowY
                });
                

            // V40.0 新增：为AI记忆长度输入框添加事件监听
            const memoryLengthInput = document.getElementById('ai-memory-length');
            if (memoryLengthInput) {
                memoryLengthInput.addEventListener('change', (e) => {
                    let value = parseInt(e.target.value, 10);
                    // 验证输入值是否在10到500之间
                    if (isNaN(value) || value < 10) {
                        value = 10;
                    } else if (value > 500) {
                        value = 500;
                    }
                    e.target.value = value; // 如果超出范围，自动修正输入框中的值
                    saveData('ai_memory_length', value);
                    showMessageBox(`AI 记忆长度已更新为 ${value} 条`);
                });
            }

            }

            // 新增：智能滚动冲突处理
            setupSmartScrollHandling();

            // ====== 【【新增】】剧场 App 核心功能 ======

            /**
             * 渲染剧本列表
             */
            renderScriptList = function() {
                const container = document.getElementById('script-list-container');
                
                if (!container) {
                    console.error('[剧场错误] 找不到 script-list-container 元素！');
                    return;
                }
                
                container.innerHTML = ''; // 清空旧列表

                const scripts = Object.values(scriptsData);

                if (scripts.length === 0) {
                    container.innerHTML = '<p class="text-center text-gray-500 mt-8">还没有剧本，点击右上角创建一个吧。</p>';
                    return;
                }

                // 按创建时间倒序排列
                scripts.sort((a, b) => b.createdAt - a.createdAt);

                scripts.forEach(script => {
                    const card = document.createElement('div');
                    card.className = 'script-card';
                    card.innerHTML = `
                        <h3 class="script-card-title">${script.title}</h3>
                        <p class="script-card-summary">${script.summary}</p>
                        <div class="script-card-actions">
                            <button class="script-edit-btn" data-script-id="${script.id}" title="编辑剧本">✎</button>
                            <button class="script-delete-btn" data-script-id="${script.id}" title="删除剧本">✕</button>
                        </div>
                    `;
                    
                    // 为编辑按钮添加点击事件
                    const editBtn = card.querySelector('.script-edit-btn');
                    editBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        const scriptId = e.target.dataset.scriptId;
                        showScriptEditScreen(scriptId);
                    });
                    
                    // 为删除按钮添加点击事件
                    const deleteBtn = card.querySelector('.script-delete-btn');
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        const scriptId = e.target.dataset.scriptId;
                        const script = scriptsData[scriptId];
                        
                        if (script && confirm(`确定要删除剧本 "${script.title}" 吗？此操作无法撤销。`)) {
                            delete scriptsData[scriptId]; // 1. 从数据中删除
                            saveData('scriptsData', scriptsData); // 2. 保存更新后的数据
                            renderScriptList(); // 3. 刷新列表
                            showMessageBox('剧本已删除');
                        }
                    });
                    
                    // 为卡片添加点击事件，以便将来进入互动界面
                    card.addEventListener('click', (e) => {
                        // 如果点击的是删除或编辑按钮，不执行进入剧本的操作
                        if (e.target.classList.contains('script-delete-btn') || e.target.classList.contains('script-edit-btn')) {
                            return;
                        }
                        startScenario(script.id);
                    });
                    container.appendChild(card);
                });
            }

            /**
             * 保存当前编辑的剧本
             */
            saveScript = function() {
                const title = document.getElementById('script-title-input').value.trim();
                const summary = document.getElementById('script-summary-input').value.trim();
                const startingPrompt = document.getElementById('script-prompt-input').value.trim();
                const characterId = document.getElementById('script-character-select').value;
                const linkedWorldBookIds = Array.from(document.querySelectorAll('#script-worldbook-select input:checked')).map(input => input.value);

                if (!title || !startingPrompt || !characterId) {
                    showMessageBox('标题、开场白和关联角色都不能为空！');
                    return;
                }

                // 通过检查 currentEditingScriptId 来判断是编辑还是新建
                if (currentEditingScriptId) {
                    // 编辑模式
                    const script = scriptsData[currentEditingScriptId];
                    if (script) {
                        script.title = title;
                        script.summary = summary;
                        script.startingPrompt = startingPrompt;
                        script.characterId = characterId;
                        script.linkedWorldBookIds = linkedWorldBookIds;
                        showMessageBox('剧本已成功更新！');
                    }
                } else {
                    // 新建模式
                    const newScript = {
                        id: `script_${Date.now()}`,
                        title,
                        summary,
                        startingPrompt,
                        characterId,
                        linkedWorldBookIds,
                        createdAt: Date.now(),
                    };
                    scriptsData[newScript.id] = newScript;
                    showMessageBox('剧本已成功保存！');
                }

                saveData('scriptsData', scriptsData);
                currentEditingScriptId = null; // 操作完成后重置

                document.getElementById('script-edit-view').classList.add('hidden');
                document.getElementById('script-list-view').classList.remove('hidden');
                renderScriptList();
            }

            /**
             * 【新增】显示剧本编辑界面（用于编辑现有剧本）
             */
            showScriptEditScreen = function(scriptId) {
                const script = scriptsData[scriptId];
                if (!script) return;

                currentEditingScriptId = scriptId; // 设置当前正在编辑的剧本ID

                // 填充表单
                document.getElementById('script-title-input').value = script.title;
                document.getElementById('script-summary-input').value = script.summary;
                document.getElementById('script-prompt-input').value = script.startingPrompt;

                const characterSelect = document.getElementById('script-character-select');
                characterSelect.innerHTML = '';
                characters.forEach(char => {
                    const option = document.createElement('option');
                    option.value = char.id;
                    option.textContent = char.name;
                    if (char.id === script.characterId) {
                        option.selected = true;
                    }
                    characterSelect.appendChild(option);
                });

                // 【新增】渲染世界书选择列表（编辑模式）
                const worldBookSelectContainer = document.getElementById('script-worldbook-select');
                worldBookSelectContainer.innerHTML = '';
                if (worldBooks.length > 0) {
                    worldBooks.forEach(book => {
                        const checkboxItem = document.createElement('label');
                        checkboxItem.className = 'wb-checkbox-label';
                        const isLinked = script.linkedWorldBookIds && script.linkedWorldBookIds.includes(book.id);
                        checkboxItem.innerHTML = `<input type="checkbox" value="${book.id}" ${isLinked ? 'checked' : ''}><span>${book.title} (${book.category})</span>`;
                        worldBookSelectContainer.appendChild(checkboxItem);
                    });
                } else {
                    worldBookSelectContainer.innerHTML = '<p class="text-xs text-gray-500">暂无世界书可选</p>';
                }

                // 切换视图
                document.getElementById('script-edit-view').classList.remove('hidden');
                document.getElementById('script-list-view').classList.add('hidden');
                document.getElementById('scenario-interaction-view').classList.add('hidden');
                document.getElementById('script-edit-title').textContent = '编辑剧本';
            }

            // ====== 【【最终版 V3.0 - 解锁对话能力】】剧场 App 核心功能 ======

            /**
             * 【【剧场模式专属 V3.0】】调用AI获取叙事回应
             * @param {object} script - 当前剧本对象
             * @param {Array} turnHistory - 互动历史
             * @returns {Promise<string|null>} AI生成的故事片段
             */
            async function getScenarioAIResponse(script, turnHistory) {
                const character = characters.find(c => c.id === script.characterId);
                if (!character) return null;

                const historyText = turnHistory.map(turn => `${turn.role}: ${turn.content}`).join('\n\n');

                // 【新增】获取并注入剧本的个性化设置
                const scriptSettings = script.settings || {};
                const wordCountInstruction = scriptSettings.wordCount ? `你的描述应该更加丰富和详尽，结合叙述和对话，总长度在 ${scriptSettings.wordCount}字 左右。` : `你的描述应该更加丰富和详尽，结合叙述和对话，总长度可以在 350-450字 之间。`;
                const customStyleInstruction = scriptSettings.customStyle ? `\n# 用户的专属风格库 (优先参考)\n${scriptSettings.customStyle}` : '';

                // 【新增】注入关联的世界书内容
                const linkedWorldBooksContent = (script.linkedWorldBookIds || [])
                    .map(bookId => {
                        const book = worldBooks.find(wb => wb.id === bookId);
                        return book ? `[世界书设定: ${book.title}]\n${book.content}` : '';
                    })
                    .filter(Boolean).join('\n\n');

                // 【【V3.0 最终版 Prompt - 支持对话】】
                const systemPrompt = `
# 指令身份
你是一位才华横溢、精通文学描写的**故事讲述者 (Storyteller)** 和 **角色扮演大师 (Role-Player)**。

# 【【最高行为准则：用户主权原则】】 (ABSOLUTELY CRITICAL!)
- **你的唯一任务，是扮演并只扮演角色 ${character.name}。**
- **你【绝对禁止】描述或决定我（用户）的任何行为、心理活动或感受。** 你的叙述范围仅限于 ${character.name} 和他/她所感知的环境。

# 核心任务
你的核心任务是与我（用户）共同创作一段故事。你将扮演角色 **${character.name}**，并通过**第三人称叙事**与**第一人称对话**相结合的方式，来呈现这个角色。

# 【【修改后】】叙事视角与风格 (CRITICAL!)
你的回复必须严格遵循以下两种模式的结合：

1.  **叙述 (Narration):**
    - **视角**: **必须**使用第三人称（他/她/${character.name}）。
    - **内容**: 描述角色的**动作、环境、神态、表情、以及内心活动 (内心活动需尽量减少，必要情况下用文学性高的描述 )**。
    - **风格**: 文学性的、充满画面感和电影感的。从下方的 [文学家风格库] 中汲取灵感。

2.  **对话 (Dialogue):**
    - **视角**: **必须**是角色本人说出的话。
    - **格式**: **所有**对话内容都**必须**被全角引号 **「 」** 包围。
    - **内容**: 这是角色直接说出口的台词，应该简洁、口语化，并完全符合其人设。

# 【【修改后】】输出长度
${wordCountInstruction}

# 【【新增】】成人内容与情感深度准则 (Mature Content & Emotional Depth Guideline)
- **核心前提**: 我是成年用户，我们的创作是私密的、成熟的。
- **开放许可**: 你**被完全允许**进行大胆、坦诚的，关于激情、欲望和深刻亲密关系的对话与描写。这是我们创作中正常且必要的一部分。
- **艺术化处理**: 在处理这些成人化内容时，你必须采取**文学和电影化**的手法。重点应放在**情感的流动、感官的放大和氛围的渲染**上，情节需要下允许使用粗俗的直白描述。

# 文学家风格库 (Style Library) - 你的创作灵感源泉
- **[王家卫风格]**: 运用大量的内心独白暗示、潮湿的都市氛围（雨夜、霓虹、狭窄空间）、时间的错位感、以及角色间充满张力的、未说出口的情绪。
- **[村上春树风格]**: 营造都市的孤独感，巧妙地融入超现实或幻想元素，对音乐、美食、猫等日常事物进行细致描写，文字冷静但情感暗流涌动。
- **[杜拉斯风格]**: 语言简洁、重复、充满节奏感，但情感极其炽热、浓烈。用最少的文字直接刺入欲望和痛苦的核心，毫不掩饰角色的脆弱与激情。
- **[雷蒙德·钱德勒风格]**: 语言冷峻、精准，充满天才般的比喻。通过对环境和人物的客观描写，营造出一种坚硬、宿命、充满黑色电影感的都市氛围。
${customStyleInstruction}

# 故事背景与角色设定
---
${linkedWorldBooksContent ? linkedWorldBooksContent + '\n' : ''}[当前剧本]: ${script.title}
[剧本开场]: ${script.startingPrompt}
[你的角色设定 (${character.name})]: ${character.persona}
[我 (用户) 与你的关系]: ${character.myPersona}
---

# 互动流程与输出示例
---
**[我的输入]**:
我小心翼翼地推开那扇沉重的橡木门，门轴发出"吱呀"一声。昏暗的房间里，我首先闻到的是一股浓重的血腥味。

**[你的合格输出 (叙述+对话)]**:
那声轻微的门轴转动声，在寂静的房间里显得格外刺耳。坐在壁炉阴影中的${character.name}缓缓抬起头，他擦拭着手中那把沾着血迹的银色匕首的动作没有丝毫停顿。一缕火光跳跃在他冰冷的眼眸中，他那双眼睛平静地望向门口，声音低沉而不起波澜对她说：「你终于来了。」
---

# 当前互动历史
${historyText}

现在，请接着我的最后一步行动，开始你的叙述和对话。
`;

                // 复用已有的 callAI 函数
                return await callAI(systemPrompt, "User: " + turnHistory[turnHistory.length - 1].content);
            }

            /**
             * 【【升级版】】开始一个剧情互动
             * @param {string} scriptId - 要开始的剧本ID
             */
            startScenario = function(scriptId) {
                const script = scriptsData[scriptId];
                if (!script) return;

                // 记录当前剧本ID和加载历史
                currentScenarioId = scriptId;
                // 【修改】从已保存的记录中加载历史，如果没有则使用开场白作为第一条
                currentScenarioHistory = scenarioHistories[scriptId] || [{ role: 'AI', content: script.startingPrompt }];

                // 切换到互动视图
                document.getElementById('script-list-view').classList.add('hidden');
                document.getElementById('scenario-interaction-view').classList.remove('hidden');
                
                // 设置标题
                document.getElementById('scenario-title').textContent = script.title;

                // 【修改】渲染完整的对话历史
                renderScenarioHistory();
                
                // 清空输入框并聚焦
                const input = document.getElementById('scenario-input');
                input.value = '';
            }

            /**
             * 【新增】渲染当前剧本的完整对话历史
             */
            function renderScenarioHistory() {
                const contentContainer = document.getElementById('scenario-content-container');
                contentContainer.innerHTML = ''; // 清空

                currentScenarioHistory.forEach((turn, turnIndex) => {
                    const turnElement = document.createElement('div');
                    turnElement.className = `scenario-turn ${turn.role.toLowerCase()}-turn`;
                    turnElement.dataset.turnIndex = turnIndex;

                    // 添加内容容器
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'turn-content';

                    // 复用分段逻辑
                    const paragraphs = turn.content.split('\n').filter(p => p.trim() !== '');
                    paragraphs.forEach(pText => {
                        const pElement = document.createElement('p');
                        pElement.textContent = pText;
                        pElement.style.marginBottom = '1em';
                        contentDiv.appendChild(pElement);
                    });

                    turnElement.appendChild(contentDiv);

                    // 添加编辑/删除按钮
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'turn-actions';

                    const editBtn = document.createElement('button');
                    editBtn.className = 'turn-action-btn edit-btn';
                    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    editBtn.title = '编辑';

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'turn-action-btn delete-btn';
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteBtn.title = '删除';

                    actionsDiv.appendChild(editBtn);
                    actionsDiv.appendChild(deleteBtn);
                    turnElement.appendChild(actionsDiv);

                    contentContainer.appendChild(turnElement);
                });
                contentContainer.scrollTop = contentContainer.scrollHeight;
            }

            /**
             * 【【新增】】处理一回合的剧情互动
             */
            async function handleScenarioTurn() {
                const input = document.getElementById('scenario-input');
                const userInput = input.value.trim();
                if (!userInput || !currentScenarioId) return;

                input.value = ''; // 立刻清空输入框
                input.disabled = true; // 锁定输入框，防止AI回应时用户连续输入

                // 1. 将用户输入添加到历史和界面
                currentScenarioHistory.push({ role: 'User', content: userInput });
                
                const contentContainer = document.getElementById('scenario-content-container');
                const userTurnElement = document.createElement('div');
                userTurnElement.className = 'scenario-turn user-turn';
                userTurnElement.dataset.turnIndex = currentScenarioHistory.length - 1;

                // 添加内容容器
                const contentDiv = document.createElement('div');
                contentDiv.className = 'turn-content';
                contentDiv.appendChild(document.createTextNode(userInput));
                userTurnElement.appendChild(contentDiv);

                // 添加编辑/删除按钮
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'turn-actions';

                const editBtn = document.createElement('button');
                editBtn.className = 'turn-action-btn edit-btn';
                editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                editBtn.title = '编辑';

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'turn-action-btn delete-btn';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = '删除';

                actionsDiv.appendChild(editBtn);
                actionsDiv.appendChild(deleteBtn);
                userTurnElement.appendChild(actionsDiv);
                contentContainer.appendChild(userTurnElement);
                contentContainer.scrollTop = contentContainer.scrollHeight;

                // 2. 显示"AI正在思考"的提示
                const thinkingElement = document.createElement('div');
                thinkingElement.className = 'scenario-turn ai-turn';
                thinkingElement.innerHTML = '<i><i class="fas fa-spinner fa-spin"></i> 对方正在构思...</i>';
                contentContainer.appendChild(thinkingElement);
                contentContainer.scrollTop = contentContainer.scrollHeight;

                // 3. 调用AI获取回应
                const script = scriptsData[currentScenarioId];
                const aiResponse = await getScenarioAIResponse(script, currentScenarioHistory);

                // 4. 移除"思考中"，显示AI的回应
                thinkingElement.remove();
                if (aiResponse) {
                    currentScenarioHistory.push({ role: 'AI', content: aiResponse });
                    const aiTurnElement = document.createElement('div');
                    aiTurnElement.className = 'scenario-turn ai-turn';
                    aiTurnElement.dataset.turnIndex = currentScenarioHistory.length - 1;

                    // 添加编辑/删除按钮
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'turn-actions';

                    const editBtn = document.createElement('button');
                    editBtn.className = 'turn-action-btn edit-btn';
                    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    editBtn.title = '编辑';

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'turn-action-btn delete-btn';
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteBtn.title = '删除';

                    actionsDiv.appendChild(editBtn);
                    actionsDiv.appendChild(deleteBtn);
                    aiTurnElement.appendChild(actionsDiv);
                    
                    // 添加内容容器
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'turn-content';
                    
                    // 将AI回复按换行符分割成段落
                    const paragraphs = aiResponse.split('\n').filter(p => p.trim() !== '');
                    paragraphs.forEach(pText => {
                        const pElement = document.createElement('p');
                        pElement.textContent = pText;
                        pElement.style.marginBottom = '1em'; // 为段落之间增加一些间距
                        contentDiv.appendChild(pElement);
                    });
                    
                    aiTurnElement.appendChild(contentDiv);
                    
                    contentContainer.appendChild(aiTurnElement);
                } else {
                    const errorElement = document.createElement('div');
                    errorElement.className = 'scenario-turn ai-turn';
                    errorElement.innerHTML = '<i style="color: red;">AI未能回应，请检查API设置或重试。</i>';
                    contentContainer.appendChild(errorElement);
                }

                contentContainer.scrollTop = contentContainer.scrollHeight;
                input.disabled = false; // 解锁输入框
                input.focus();

                // 保存更新后的历史记录
                scenarioHistories[currentScenarioId] = currentScenarioHistory;
                saveData('scenarioHistories', scenarioHistories);
            }

            /**
             * 【新增】处理剧本"重投"的逻辑
             */
            async function handleScenarioRetry() {
                if (!currentScenarioId || currentScenarioHistory.length < 2) {
                    showMessageBox('至少需要一回合互动才能重新生成');
                    return;
                }

                // 找到最后一个AI的回应并从界面上删除
                const contentContainer = document.getElementById('scenario-content-container');
                const lastTurnElement = contentContainer.lastElementChild;
                if (lastTurnElement && lastTurnElement.classList.contains('ai-turn')) {
                    lastTurnElement.remove();
                }

                // 从历史记录中移除最后一个AI的回应
                currentScenarioHistory.pop(); 

                // 显示"重新构思中"的提示
                const thinkingElement = document.createElement('div');
                thinkingElement.className = 'scenario-turn ai-turn';
                thinkingElement.innerHTML = '<i><i class="fas fa-spinner fa-spin"></i> 对方正在重新构思...</i>';
                contentContainer.appendChild(thinkingElement);
                contentContainer.scrollTop = contentContainer.scrollHeight;

                // 再次调用AI
                const script = scriptsData[currentScenarioId];
                const aiResponse = await getScenarioAIResponse(script, currentScenarioHistory);

                // 移除提示，显示新结果
                thinkingElement.remove();
                if (aiResponse) {
                    currentScenarioHistory.push({ role: 'AI', content: aiResponse }); // 保存新结果
                    const aiTurnElement = document.createElement('div');
                    aiTurnElement.className = 'scenario-turn ai-turn';
                    aiTurnElement.dataset.turnIndex = currentScenarioHistory.length - 1;

                    // 添加编辑/删除按钮
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'turn-actions';

                    const editBtn = document.createElement('button');
                    editBtn.className = 'turn-action-btn edit-btn';
                    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    editBtn.title = '编辑';

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'turn-action-btn delete-btn';
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteBtn.title = '删除';

                    actionsDiv.appendChild(editBtn);
                    actionsDiv.appendChild(deleteBtn);
                    aiTurnElement.appendChild(actionsDiv);

                    // 添加内容容器
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'turn-content';

                    // 复用分段逻辑
                    const paragraphs = aiResponse.split('\n').filter(p => p.trim() !== '');
                    paragraphs.forEach(pText => {
                        const pElement = document.createElement('p');
                        pElement.textContent = pText;
                        pElement.style.marginBottom = '1em';
                        contentDiv.appendChild(pElement);
                    });
                    
                    aiTurnElement.appendChild(contentDiv);
                    contentContainer.appendChild(aiTurnElement);
                } else {
                    const errorElement = document.createElement('div');
                    errorElement.className = 'scenario-turn ai-turn';
                    errorElement.innerHTML = '<i style="color: red;">重新生成失败，请检查API设置。</i>';
                    contentContainer.appendChild(errorElement);
                    // 如果失败，把移除的历史加回去，避免数据丢失
                    currentScenarioHistory.push({ role: 'AI', content: '重新生成失败' });
                }

                contentContainer.scrollTop = contentContainer.scrollHeight;

                // 保存更新后的历史记录
                scenarioHistories[currentScenarioId] = currentScenarioHistory;
                saveData('scenarioHistories', scenarioHistories);
            }

            /**
             * 编辑剧本回合
             */
            function editTurn(turnIndex) {
                if (!currentScenarioHistory[turnIndex]) return;
                
                const turn = currentScenarioHistory[turnIndex];
                const turnElement = document.querySelector(`[data-turn-index="${turnIndex}"]`);
                if (!turnElement) return;
                
                const contentElement = turnElement.querySelector('.turn-content');
                if (!contentElement) return;
                
                // 隐藏原有的操作按钮
                const actionsElement = turnElement.querySelector('.turn-actions');
                if (actionsElement) {
                    actionsElement.style.display = 'none';
                }
                
                // 保存原始内容
                const originalContent = turn.content;
                const originalHTML = contentElement.innerHTML;
                
                // 创建可编辑的textarea
                const textarea = document.createElement('textarea');
                textarea.value = originalContent;
                textarea.className = 'turn-edit-textarea';
                
                // 替换内容
                contentElement.innerHTML = '';
                contentElement.appendChild(textarea);
                
                // 创建编辑模式按钮容器（放在右下角）
                const editActions = document.createElement('div');
                editActions.className = 'edit-mode-actions';
                
                const saveBtn = document.createElement('button');
                saveBtn.textContent = '保存';
                saveBtn.className = 'edit-mode-btn save-btn';
                
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = '取消';
                cancelBtn.className = 'edit-mode-btn cancel-btn';
                
                editActions.appendChild(saveBtn);
                editActions.appendChild(cancelBtn);
                turnElement.appendChild(editActions);
                
                // 聚焦并选中所有文本
                textarea.focus();
                textarea.select();
                
                // 保存功能
                const saveEdit = () => {
                    const newContent = textarea.value.trim();
                    if (newContent !== '') {
                        currentScenarioHistory[turnIndex].content = newContent;
                        
                        // 更新localStorage
                        let scenarioHistories = loadData('scenarioHistories') || {};
                        if (currentScenarioId && scenarioHistories[currentScenarioId]) {
                            scenarioHistories[currentScenarioId] = currentScenarioHistory;
                            saveData('scenarioHistories', scenarioHistories);
                        }
                        
                        // 重新渲染
                        renderScenarioHistory();
                    }
                };
                
                // 取消功能
                const cancelEdit = () => {
                    // 恢复原始内容
                    contentElement.innerHTML = originalHTML;
                    
                    // 移除编辑按钮
                    editActions.remove();
                    
                    // 恢复原有操作按钮
                    if (actionsElement) {
                        actionsElement.style.display = '';
                    }
                };
                
                // 绑定事件
                saveBtn.addEventListener('click', saveEdit);
                cancelBtn.addEventListener('click', cancelEdit);
                
                // ESC取消，Ctrl+Enter保存
                textarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    } else if (e.key === 'Enter' && e.ctrlKey) {
                        e.preventDefault();
                        saveEdit();
                    }
                });
                
                // 自动调整高度
                const adjustHeight = () => {
                    textarea.style.height = 'auto';
                    textarea.style.height = Math.max(100, textarea.scrollHeight) + 'px';
                };
                
                textarea.addEventListener('input', adjustHeight);
                adjustHeight();
            }

            /**
             * 删除剧本回合
             */
            function deleteTurn(turnIndex) {
                if (!currentScenarioHistory[turnIndex]) return;
                
                if (confirm('确定要删除这段内容吗？')) {
                    currentScenarioHistory.splice(turnIndex, 1);
                    
                    // 更新localStorage
                    let scenarioHistories = loadData('scenarioHistories') || {};
                    if (currentScenarioId && scenarioHistories[currentScenarioId]) {
                        scenarioHistories[currentScenarioId] = currentScenarioHistory;
                        saveData('scenarioHistories', scenarioHistories);
                    }
                    
                    // 重新渲染
                    renderScenarioHistory();
                }
            }

            // ====== 【【最终版】】剧场 App 导航逻辑 ======
            
            // ================== 【【新增 V2.0】】剧场事件委托总管 ==================
            const scenarioContainer = document.getElementById('scenario-content-container');
            if (scenarioContainer) {
                scenarioContainer.addEventListener('click', function(e) {
                    const turnElement = e.target.closest('.scenario-turn');
                    if (!turnElement) return;

                    const turnIndex = parseInt(turnElement.dataset.turnIndex, 10);

                    // 检查点击的是否是编辑按钮
                    if (e.target.closest('.edit-btn')) {
                        e.stopPropagation();
                        editTurn(turnIndex);
                        return;
                    }

                    // 检查点击的是否是删除按钮
                    if (e.target.closest('.delete-btn')) {
                        e.stopPropagation();
                        deleteTurn(turnIndex);
                        return;
                    }
                });
            }
            // =================================================================
            
            const theaterBackButton = document.getElementById('theater-back-button');
            const addNewScriptBtn = document.getElementById('add-new-script-btn');
            const scriptEditBackButton = document.getElementById('script-edit-back-btn');
            const saveScriptBtn = document.getElementById('save-script-btn');
            const scenarioBackButton = document.getElementById('scenario-back-btn');

            if(theaterBackButton) {
                theaterBackButton.addEventListener('click', () => showScreen('home-screen'));
            }
            if(addNewScriptBtn) {
                addNewScriptBtn.addEventListener('click', () => {
                    // 清除编辑模式标识
                    currentEditingScriptId = null;
                    
                    document.getElementById('script-list-view').classList.add('hidden');
                    document.getElementById('script-edit-view').classList.remove('hidden');
                    document.getElementById('script-edit-title').textContent = '创建新剧本';
                    
                    document.getElementById('script-title-input').value = '';
                    document.getElementById('script-summary-input').value = '';
                    document.getElementById('script-prompt-input').value = '';
                    
                    const characterSelect = document.getElementById('script-character-select');
                    characterSelect.innerHTML = '';
                    
                    if (characters && characters.length > 0) {
                        characters.forEach(char => {
                            const option = document.createElement('option');
                            option.value = char.id;
                            option.textContent = char.name;
                            characterSelect.appendChild(option);
                        });
                    } else {
                        const option = document.createElement('option');
                        option.textContent = '请先去"角色书"创建角色';
                        option.disabled = true;
                        characterSelect.appendChild(option);
                    }

                    // 【新增】渲染世界书选择列表
                    const worldBookSelectContainer = document.getElementById('script-worldbook-select');
                    worldBookSelectContainer.innerHTML = '';
                    if (worldBooks.length > 0) {
                        worldBooks.forEach(book => {
                            const checkboxItem = document.createElement('label');
                            checkboxItem.className = 'wb-checkbox-label'; // 复用已有样式
                            checkboxItem.innerHTML = `<input type="checkbox" value="${book.id}"><span>${book.title} (${book.category})</span>`;
                            worldBookSelectContainer.appendChild(checkboxItem);
                        });
                    } else {
                        worldBookSelectContainer.innerHTML = '<p class="text-xs text-gray-500">暂无世界书可选</p>';
                    }
                });
            }
            if(scriptEditBackButton) {
                scriptEditBackButton.addEventListener('click', () => {
                    document.getElementById('script-edit-view').classList.add('hidden');
                    document.getElementById('script-list-view').classList.remove('hidden');
                    renderScriptList(); // 【【新增】】返回时刷新列表
                });
            }
            if(saveScriptBtn) {
                saveScriptBtn.addEventListener('click', saveScript); // 【【修改】】点击保存按钮时调用saveScript函数
            }
            if(scenarioBackButton) {
                scenarioBackButton.addEventListener('click', () => {
                    document.getElementById('scenario-interaction-view').classList.add('hidden');
                    document.getElementById('script-list-view').classList.remove('hidden');
                    renderScriptList(); // 【【新增】】返回时刷新列表
                });
            }

            // 【【新增】】绑定剧情互动界面的事件
            const scenarioInput = document.getElementById('scenario-input');
            const sendScenarioTurnBtn = document.getElementById('send-scenario-turn-btn');

            if(sendScenarioTurnBtn) {
                sendScenarioTurnBtn.addEventListener('click', handleScenarioTurn);
            }
            if(scenarioInput) {
                // 移除回车自动发送功能，允许换行
                scenarioInput.addEventListener('keydown', (e) => {
                    // 注释掉自动发送逻辑，现在回车键可以正常换行
                    // if (e.key === 'Enter' && !e.shiftKey) {
                    //     e.preventDefault(); // 阻止回车换行
                    //     handleScenarioTurn();
                    // }
                });
            }

            // 【新增】剧场重投按钮事件
            const retryScenarioBtn = document.getElementById('retry-scenario-turn-btn');
            if(retryScenarioBtn) {
                retryScenarioBtn.addEventListener('click', handleScenarioRetry);
            }

            // 1. 首先执行加载数据和基础设置
            await loadAllSavedData();
            updateTime();
            setInterval(updateTime, 60000);
            loadMomentsCover();
            loadMomentsUserInfo();
            console.log('智能朋友圈触发系统已初始化');
            showScreen('home-screen');

            // 2. 然后，为所有页面元素安全地绑定事件监听器
            initializeAppIcons();

            // 绑定其他必要的事件监听器
            $('#monitoring-refresh-button').addEventListener('click', () => {
                if (currentMonitoringCharacterId) {
                    getCharacterStatus(currentMonitoringCharacterId);
                }
            });

            // 新增：为"持续监控"按钮绑定事件
            $('#monitoring-next-step-button').addEventListener('click', () => {
                if (currentMonitoringCharacterId) {
                    // 调用核心函数，并告知这是一个"推演下一步"的任务
                    getCharacterStatus(currentMonitoringCharacterId, true);
                }
            });


            // 确保其他所有 .addEventListener 调用都在这个 'DOMContentLoaded' 内部
            // [新代码] - 重新激活所有页面的事件监听器
            addNewEventListeners();
            // [已修复] - 删除重复调用，避免事件重复绑定
            setupDrawingBoardEvents();
            setupTarotCard();
            
            // 添加约定模态框输入框焦点效果
            setupPlanModalEffects();

            // 启动AI心跳，让角色可以自主行动
            const systemHeartbeatSettings = loadData('heartbeatSettings', defaultHeartbeatSettings);
            heartbeatTimers.systemHeartbeat = setInterval(systemHeartbeat, systemHeartbeatSettings.systemHeartbeatInterval * 60 * 60 * 1000);

            // NPC定时发帖的心跳，使用用户设置的间隔和概率
            heartbeatTimers.npcPost = setInterval(() => {
                // 只有当API开启时才执行
                const apiSettings = loadData('api_settings');
                if (apiSettings && apiSettings.url && apiSettings.key && Math.random() < (systemHeartbeatSettings.npcPostProbability / 100)) {
                    triggerNpcPost();
                }
            }, (Math.random() * (systemHeartbeatSettings.npcPostMaxInterval - systemHeartbeatSettings.npcPostMinInterval) + systemHeartbeatSettings.npcPostMinInterval) * 60 * 1000);

        });

        // --- V8.0: 计划模块辅助函数 ---
        function formatPlansForAI(characterId) {
            if (!planData[characterId] || planData[characterId].length === 0) {
                return "（目前我们之间还没有任何约定。）";
            }
            return planData[characterId]
                .map(p => `- [${p.status}] ${p.title}`)
                .join('\n');
        }
        
        // 设置约定模态框的交互效果
        function setupPlanModalEffects() {
            const titleInput = document.querySelector('#plan-content');
            const characterSelect = document.querySelector('#plan-partner');
            const detailsInput = document.querySelector('#plan-notes');
            
            // 为所有输入框添加焦点时的微妙动画
            [titleInput, characterSelect, detailsInput].forEach(element => {
                if (element) {
                    element.addEventListener('focus', () => {
                        element.style.transform = 'scale(1.02)';
                        element.style.boxShadow = '0 0 20px rgba(220, 38, 38, 0.2)';
                    });
                    element.addEventListener('blur', () => {
                        element.style.transform = 'scale(1)';
                        element.style.boxShadow = '';
                    });
                }
            });
        }

        // ================== 页面加载完成后的总初始化 (修正版) END ==================

        // --- V8.1: 新增通话输入框高度自适应辅助函数 ---
        function adjustCallInputHeight(element) {
            element.style.height = 'auto';
            const maxHeight = 80; // 必须与CSS中的max-height保持一致
            if (element.scrollHeight > maxHeight) {
                element.style.height = `${maxHeight}px`;
                element.style.overflowY = 'auto';
            } else {
                element.style.height = `${element.scrollHeight}px`;
                element.style.overflowY = 'hidden';
            }
        }

        // --- V8.1: 新增AI通话回复显示函数（支持动作描写空行） ---
        function displayAICallResponse(type, response) {
            const statusBox = $(`#${type}-call-status-box`);
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) return;

            const aiMsg = `${character.name}: ${response}`;

            // 核心修改：先将所有星号包裹的旁白替换为带换行和斜体标签的HTML
            // 然后再将文本中本身就有的换行符替换为<br>
            let formattedMsg = aiMsg.replace(/\*(.*?)\*/g, "<br><i>$1</i>");
            formattedMsg = formattedMsg.replace(/(\r\n|\n|\r)/gm, "<br>");

            // 如果消息处理后是以换行开头（即旁白在最前面），则移除第一个多余的换行
            if (formattedMsg.startsWith('<br>')) {
                formattedMsg = formattedMsg.substring(4).trim();
            }

            // 将处理好的内容追加到状态框，并保存原始信息到通话记录
            statusBox.innerHTML += `<p>${formattedMsg}</p>`;
            callHistory.push(response); // 只保存AI的原始回复内容
            statusBox.scrollTop = statusBox.scrollHeight;
        }

        // --- V8.1: 新增通话重试功能函数 ---
        async function handleCallRetry(type) {
            const statusBox = $(`#${type}-call-status-box`);
            const character = characters.find(c => c.id === currentChatCharacterId);
            if (!character) return;

            // 查找最后一个用户输入
            let lastUserMessageIndex = -1;
            for (let i = callHistory.length - 1; i >= 0; i--) {
                if (callHistory[i].startsWith('你:')) {
                    lastUserMessageIndex = i;
                    break;
                }
            }
            
            let userInputForRetry = '';
            if (lastUserMessageIndex !== -1) {
                // 如果找到了用户输入，就以此为基础重试
                userInputForRetry = callHistory[lastUserMessageIndex].replace('你:', '').trim();
                // 移除此条用户消息之后的所有AI回复
                callHistory.splice(lastUserMessageIndex + 1);
            } else {
                // 如果历史记录里全是AI的话（不太可能，但作为保险），就移除最后一条
                callHistory.pop();
            }

            // 更新UI显示
            statusBox.innerHTML = callHistory.map(line => `<p>${line.replace(/(\*|_)(.*?)\1/g, '<i>$2</i>')}</p>`).join('');
            statusBox.innerHTML += `<p><i>${character.name}正在重新思考...</i></p>`;
            statusBox.scrollTop = statusBox.scrollHeight;

            // 重新请求AI响应
            const aiResponse = await getAICallResponse(type, callHistory.length > 0, userInputForRetry);
            
            // 移除"正在思考"的提示
            statusBox.removeChild(statusBox.lastChild);

            // 使用新的displayAICallResponse函数显示新响应，支持动作描写空行
            displayAICallResponse(type, aiResponse);
        }

        // --- V11.0 新增：专属素材库管理功能 ---
        function renderCharacterExpressions(character) {
            const container = document.querySelector('#cb-expressions-container');
            if (!container) return;
            container.innerHTML = '';
            const expressions = character.expressions || [];

            if (expressions.length === 0) {
                container.innerHTML = '<p class="text-xs text-center text-gray-500">该角色暂无专属素材</p>';
                return;
            }

            expressions.forEach((expr, index) => {
                const item = document.createElement('div');
                item.className = 'flex items-start gap-2 p-1 bg-white/5 rounded text-xs';
                // 使用pre-wrap来保留HTML代码的换行和空格，便于查看
                item.innerHTML = `
                    <div class="flex-1 overflow-hidden">
                        <strong class="text-blue-400">${expr.keyword}:</strong>
                        <p class="whitespace-pre-wrap break-all opacity-80">${expr.content}</p>
                    </div>
                    <button class="text-red-500 font-bold p-1" data-index="${index}">×</button>
                `;
                item.querySelector('button').addEventListener('click', (e) => {
                    const char = characters.find(c => c.id === currentEditingCharacterId);
                    if (char && char.expressions) {
                        const idxToRemove = parseInt(e.target.dataset.index);
                        char.expressions.splice(idxToRemove, 1);
                        renderCharacterExpressions(char); // 重新渲染
                    }
                });
                container.appendChild(item);
            });
        }

        const addExpressionBtn = document.querySelector('#add-expression-btn');
        if(addExpressionBtn){
            addExpressionBtn.addEventListener('click', () => {
                const keywordInput = document.querySelector('#expression-keyword-input');
                const contentInput = document.querySelector('#expression-content-input');
                const keyword = keywordInput.value.trim();
                const content = contentInput.value.trim();

                if (!keyword || !content) {
                    return showMessageBox('关键词和素材内容都不能为空');
                }

                const character = characters.find(c => c.id === currentEditingCharacterId);
                if (character) {
                    if (!character.expressions) {
                        character.expressions = [];
                    }
                    character.expressions.push({ keyword, content });
                    renderCharacterExpressions(character); // 添加后立即更新显示
                    keywordInput.value = '';
                    contentInput.value = '';
                }
            });
        }

    // --- V12.1 新增：图片文件转Base64辅助函数 ---
    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                // reader.result 包含 "data:image/jpeg;base64," 前缀，正是API需要的格式
                resolve(reader.result);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    // 【新增辅助函数1：将Base64转回Blob，用于导入】
    async function base64ToBlob(base64) {
        const response = await fetch(base64);
        const blob = await response.blob();
        return blob;
    }

    // 【新增辅助函数2：清空IndexedDB的存储空间，用于导入前清场】
    async function clearIndexedDBStore(storeName) {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
        });
    }

    // ====== 记忆胶囊App导航逻辑 ======

    // 获取新元素
    const timeCapsuleWidget = document.querySelector('#time-capsule-widget');
    const memoryCapsuleScreen = document.querySelector('#memory-capsule-screen');
    const memoryCapsuleBackButton = document.querySelector('#memory-capsule-back-button');
    const capsuleImage = document.querySelector('#capsule-image');

    // 創建隱藏的文件輸入元素
    let fileInput = null;
    
    // 上傳圖片的函數
    function uploadCapsuleImage() {
        if (!fileInput) {
            fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);
            
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    // 檢查文件大小，限制在5MB以內
                    if (file.size > 5 * 1024 * 1024) {
                        showMessageBox('圖片文件太大，請選擇5MB以內的圖片');
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        // 創建圓形裁切
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            const size = 144; // 調整圓形大小以匹配新的圖片尺寸
                            
                            canvas.width = size;
                            canvas.height = size;
                            
                            // 創建圓形裁切路徑
                            ctx.beginPath();
                            ctx.arc(size/2, size/2, size/2, 0, 2 * Math.PI);
                            ctx.closePath();
                            ctx.clip();
                            
                            // 計算裁切區域，保持比例
                            const scale = Math.max(size / img.width, size / img.height);
                            const scaledWidth = img.width * scale;
                            const scaledHeight = img.height * scale;
                            const x = (size - scaledWidth) / 2;
                            const y = (size - scaledHeight) / 2;
                            
                            // 繪製圓形圖片
                            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                            
                            // 轉換為Base64
                            const circularImage = canvas.toDataURL('image/jpeg', 0.8);
                            capsuleImage.src = circularImage;
                            
                            // 添加動畫效果
                            capsuleImage.style.transform = 'scale(1.2) rotate(10deg)';
                            setTimeout(() => {
                                capsuleImage.style.transform = 'scale(1) rotate(0deg)';
                            }, 300);
                            
                            // 保存到本地存儲
                            saveData('capsuleCustomImage', circularImage);
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }
        
        fileInput.click();
    }
    
    // 載入保存的自定義圖片
    function loadCustomImage() {
        const savedImage = loadData('capsuleCustomImage', '');
        if (savedImage) {
            capsuleImage.src = savedImage;
        }
    }



    // 绑定事件监听器
    if (timeCapsuleWidget) {
        // 点击整个组件直接进入时光回廊
        timeCapsuleWidget.addEventListener('click', (event) => {
            // 确保点击开关时不触发
            if (!event.target.closest('.capsule-switch-container')) {
                showScreen('memory-capsule-screen');
                showCharacterSelect(); 
            }
        });
    }
    if (capsuleImage) {
        // 点击图片容器上传图片，阻止事件冒泡
        const imageContainer = capsuleImage.parentElement;
        if (imageContainer) {
            imageContainer.addEventListener('click', (event) => {
                event.stopPropagation(); // 阻止打开弹窗
                uploadCapsuleImage();
            });
        }
        
        // 載入保存的自定義圖片
        loadCustomImage();
    }


    // 从时光回廊返回主屏幕
    if (memoryCapsuleBackButton) {
        memoryCapsuleBackButton.addEventListener('click', () => {
            showScreen('home-screen');
        });
    }

    // 返回角色选择按钮
    const backToCharacterSelectButton = document.querySelector('#back-to-character-select');
    if (backToCharacterSelectButton) {
        backToCharacterSelectButton.addEventListener('click', () => {
            showCharacterSelect();
        });
    }

    // 记忆胶囊添加按钮事件
    const memoryCapsuleAddButton = document.querySelector('#memory-capsule-add-button');
    if (memoryCapsuleAddButton) {
        memoryCapsuleAddButton.addEventListener('click', () => {
            // 检查是否在角色时光回廊中
            const timelineContainer = document.querySelector('#timeline-container');
            if (timelineContainer && !timelineContainer.classList.contains('hidden')) {
                // 在时光回廊中，可以添加记忆
                const addMemoryModal = document.querySelector('#add-memory-modal');
                const newMemoryContent = document.querySelector('#new-memory-content');
                if (addMemoryModal && newMemoryContent) {
                    addMemoryModal.classList.add('visible');
                    document.getElementById('new-memory-title').focus();
                }
            } else {
                // 在角色选择页面，提示先选择角色
                showMessageBox('请先选择一个角色查看记忆');
            }
        });
    }

    // 添加记忆按钮事件
    const addMemoryBtn = document.querySelector('#add-memory-btn');
    const addMemoryModal = document.querySelector('#add-memory-modal');
    const cancelAddMemoryBtn = document.querySelector('#cancel-add-memory-btn');
    const saveMemoryBtn = document.querySelector('#save-memory-btn');
    const newMemoryContent = document.querySelector('#new-memory-content');

    if (addMemoryBtn) {
        addMemoryBtn.addEventListener('click', () => {
            addMemoryModal.classList.add('visible');
            document.getElementById('new-memory-title').focus();
        });
    }

    if (cancelAddMemoryBtn) {
        cancelAddMemoryBtn.addEventListener('click', () => {
            addMemoryModal.classList.remove('visible');
            document.getElementById('new-memory-title').value = '';
            newMemoryContent.value = '';
            document.getElementById('new-memory-feeling').value = '';
        });
    }

    if (saveMemoryBtn) {
        saveMemoryBtn.addEventListener('click', () => {
            const title = document.getElementById('new-memory-title').value.trim();
            const content = newMemoryContent.value.trim();
            const feeling = document.getElementById('new-memory-feeling').value.trim();
            
            if (!title) {
                showMessageBox('请输入记忆标题');
                return;
            }
            
            if (!content) {
                showMessageBox('请输入记忆内容');
                return;
            }

            // 获取当前查看的角色ID
            const currentCharacterId = getCurrentViewingCharacterId();
            
            // 获取当前角色信息
            const currentCharacter = characters.find(c => c.id === currentCharacterId);
            
            // 创建新记忆
            const newMemory = {
                id: 'memory_' + Date.now(),
                title: title,
                content: content,
                feeling: feeling,
                characterId: currentCharacterId, // 关联当前查看的角色
                characterFeeling: '', // 角色的感触，稍后自动生成
                createdAt: Date.now(),
                lastRevisited: null
            };

            // 保存到本地存储
            let memories = loadData('memoryCapsules', []);
            memories.push(newMemory);
            saveData('memoryCapsules', memories);

            // 自动生成角色感触
            if (currentCharacter) {
                generateCharacterFeeling(newMemory, currentCharacter);
            }

            // 关闭模态框并清空输入
            addMemoryModal.classList.remove('visible');
            document.getElementById('new-memory-title').value = '';
            newMemoryContent.value = '';
            document.getElementById('new-memory-feeling').value = '';

            // 显示成功消息
            showMessageBox('记忆已添加到时光回廊中！');

            // 重新渲染时光回廊
            setTimeout(() => {
                renderTimeline(currentViewingCharacterId);
            }, 500);
        });
    }

    // ====== 记忆胶囊导航与渲染逻辑 (时光回廊版) ======

    // 确保Panzoom实例的全局变量被移除或注释掉
    // let panzoomInstance = null; 

    /**
     * 显示角色选择界面
     */
    function showCharacterSelect() {
        const characterSelectContainer = document.querySelector('#character-select-container');
        const timelineContainer = document.querySelector('#timeline-container');
        const characterSelectList = document.querySelector('#character-select-list');
        
        if (!characterSelectContainer || !timelineContainer || !characterSelectList) return;
        
        // 显示角色选择，隐藏时光回廊
        characterSelectContainer.classList.remove('hidden');
        timelineContainer.classList.add('hidden');
        
        // 渲染角色列表
        characterSelectList.innerHTML = '';
        
        if (characters.length === 0) {
            characterSelectList.innerHTML = `
                <div class="text-center py-8">
                    <i class="fas fa-user-slash text-4xl text-gray-400 mb-4"></i>
                    <p class="text-gray-500 mb-2">还没有创建角色</p>
                    <p class="text-sm text-gray-400">请先在角色书中创建角色</p>
                </div>
            `;
            return;
        }
        
        characters.forEach(character => {
            const characterItem = document.createElement('div');
            characterItem.className = 'character-select-item rounded-lg p-4 shadow-sm hover:shadow-md transition-shadow cursor-pointer';
            
            // 获取该角色的记忆数量
            const memories = loadData('memoryCapsules', []);
            const characterMemories = memories.filter(m => m.characterId === character.id);
            
            characterItem.innerHTML = `
                <div class="flex items-center space-x-3">
                    <div class="w-12 h-12 rounded-full bg-gray-300 dark:bg-gray-600 flex items-center justify-center flex-shrink-0">
                        ${character.avatar ? '<img src="" alt="头像" class="w-full h-full rounded-full object-cover" id="char-avatar-' + character.id + '">' : '<i class="fas fa-user text-xl text-gray-500"></i>'}
                    </div>
                    <div class="flex-1">
                        <h4 class="font-semibold">${character.name}</h4>
                        <p class="text-sm">${characterMemories.length} 段记忆</p>
                    </div>
                    <div class="text-gray-400">
                        <i class="fas fa-chevron-right"></i>
                    </div>
                </div>
            `;
            
            // 异步加载头像
            if (character.avatar) {
                getImageFromDB(character.avatar).then(blob => {
                    if (blob) {
                        const avatarElement = characterItem.querySelector(`#char-avatar-${character.id}`);
                        if (avatarElement) {
                            const objectURL = URL.createObjectURL(blob);
                            avatarElement.src = objectURL;
                        }
                    }
                });
            }
            
            // 点击角色进入时光回廊
            characterItem.addEventListener('click', () => {
                showTimelineForCharacter(character);
            });
            
            characterSelectList.appendChild(characterItem);
        });
    }

    // 全局变量存储当前查看的角色ID
    let currentViewingCharacterId = null;

    /**
     * 显示指定角色的时光回廊
     */
    function showTimelineForCharacter(character) {
        const characterSelectContainer = document.querySelector('#character-select-container');
        const timelineContainer = document.querySelector('#timeline-container');
        const currentCharacterName = document.querySelector('#current-character-name');
        
        if (!characterSelectContainer || !timelineContainer || !currentCharacterName) return;
        
        // 隐藏角色选择，显示时光回廊
        characterSelectContainer.classList.add('hidden');
        timelineContainer.classList.remove('hidden');
        
        // 设置当前角色名称和ID
        currentCharacterName.textContent = `${character.name}的时光回廊`;
        currentViewingCharacterId = character.id;
        
        // 渲染该角色的记忆
        renderTimeline(character.id);
    }

    /**
     * 获取当前查看的角色ID
     */
    function getCurrentViewingCharacterId() {
        return currentViewingCharacterId;
    }

    /**
     * 渲染时光回廊界面
     */
    function renderTimeline(characterId = null) {
        const timelineCore = document.getElementById('timeline-core');
        const cardTemplate = document.getElementById('memory-card-template');
        if (!timelineCore || !cardTemplate) return;

        timelineCore.innerHTML = ''; 
        let memories = loadData('memoryCapsules', []);
        
        // 如果指定了角色ID，只显示该角色的记忆
        if (characterId) {
            memories = memories.filter(m => m.characterId === characterId);
        }

        // 处理空状态
        if (memories.length === 0) {
            const character = characterId ? characters.find(c => c.id === characterId) : null;
            const characterName = character ? character.name : '';
            
            timelineCore.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-stream"></i>
                    <p class="font-semibold">${characterName ? characterName + '的时光回廊' : '时光回廊'}空无一物</p>
                    <p class="text-sm mt-2 opacity-70">
                        ${characterName ? `与${characterName}的重要对话将会被自动铭刻于此...` : '与角色的重要对话将会被自动铭刻于此...'}
                    </p>
                </div>
            `;
            return;
        }

        // 按时间倒序排列记忆
        memories.sort((a, b) => b.createdAt - a.createdAt);

        memories.forEach(memory => {
            const cardClone = cardTemplate.content.cloneNode(true);
            const timelineItem = cardClone.querySelector('.timeline-item');
            
            // 填充数据
            timelineItem.querySelector('.card-title-timeline').textContent = memory.title || '美好回忆';
            timelineItem.querySelector('.card-timestamp-timeline').textContent = new Date(memory.createdAt).toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });
            // 移除内容预览，只显示标题和日期
            timelineItem.querySelector('.card-content-preview-timeline').style.display = 'none';
            
            // 显示感触（如果有的话）
            const feelingElement = timelineItem.querySelector('.card-feeling-preview-timeline');
            if (memory.feeling && memory.feeling.trim()) {
                feelingElement.textContent = `💭 ${memory.feeling}`;
                feelingElement.classList.add('text-sm', 'text-gray-600', 'mt-2');
            } else {
                feelingElement.style.display = 'none';
            }

            // 添加点击事件，打开详情弹窗
            timelineItem.querySelector('.memory-card-timeline').addEventListener('click', () => {
                openMemoryCard(memory.id);
            });
            
            // 移除封面上的按钮，只在详情中显示
            const addFeelingBtn = timelineItem.querySelector('.add-feeling-btn-timeline');
            const deleteMemoryBtn = timelineItem.querySelector('.delete-memory-btn-timeline');
            if (addFeelingBtn) addFeelingBtn.style.display = 'none';
            if (deleteMemoryBtn) deleteMemoryBtn.style.display = 'none';
            
            timelineCore.appendChild(cardClone);
        });
    }

    // 打开记忆卡片的函数
    function openMemoryCard(memoryId) {
        const memories = loadData('memoryCapsules', []);
        const memory = memories.find(m => m.id === memoryId);
        if (!memory) return;

        const modal = document.getElementById('memory-card-modal');
        const content = document.getElementById('memory-card-content');

        // 根据当前主题设置样式
        const isDarkMode = document.body.classList.contains('dark-mode');
        const titleColor = isDarkMode ? 'text-white' : 'text-gray-800';
        const subtitleColor = isDarkMode ? 'text-gray-400' : 'text-gray-500';
        const headingColor = isDarkMode ? 'text-gray-300' : 'text-gray-700';
        const contentBg = isDarkMode ? 'bg-gray-700' : 'bg-gray-50';
        const contentText = isDarkMode ? 'text-gray-200' : 'text-gray-800';
        const feelingBg = isDarkMode ? 'bg-blue-900' : 'bg-blue-50';
        const feelingText = isDarkMode ? 'text-blue-200' : 'text-blue-800';
        const characterFeelingBg = isDarkMode ? 'bg-purple-900' : 'bg-purple-50';
        const characterFeelingText = isDarkMode ? 'text-purple-200' : 'text-purple-800';
        const reviewBg = isDarkMode ? 'bg-gray-700' : 'bg-gray-50';
        const reviewText = isDarkMode ? 'text-gray-300' : 'text-gray-600';
        const closeBtnColor = isDarkMode ? 'text-gray-400' : 'text-gray-400';
        const closeBtnHoverColor = isDarkMode ? 'hover:text-gray-200' : 'hover:text-gray-600';
        
        content.innerHTML = `
            <div class="card-header">
                <h3 class="text-xl font-bold ${titleColor} mb-2">${memory.title || '美好回忆'}</h3>
                <p class="text-sm ${subtitleColor}">发生于：${new Date(memory.createdAt).toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
            </div>
            
            <div class="card-body">
                <div class="space-y-4">
                    <div>
                        <h4 class="text-sm font-semibold ${headingColor} mb-2">记忆内容</h4>
                        <div class="${contentBg} p-3 rounded-lg ${contentText}">${memory.content}</div>
                    </div>

                    ${memory.feeling ? `
                    <div>
                        <h4 class="text-sm font-semibold ${headingColor} mb-2">我的感触</h4>
                        <div class="${feelingBg} p-3 rounded-lg ${feelingText}">💭 ${memory.feeling}</div>
                    </div>
                    ` : ''}

                    ${memory.characterId ? `
                    <div>
                        <h4 class="text-sm font-semibold ${headingColor} mb-2">${characters.find(c => c.id === memory.characterId)?.name || '角色'}的感触</h4>
                        <div class="${characterFeelingBg} p-3 rounded-lg ${characterFeelingText}">
                            ${memory.characterFeeling ? `💭 ${memory.characterFeeling}` : '角色正在思考这段记忆...'}
                        </div>
                    </div>
                    ` : ''}

                    <div>
                        <h4 class="text-sm font-semibold ${headingColor} mb-2">回顾记录</h4>
                        <div class="${reviewBg} p-3 rounded-lg ${reviewText}">
                            ${memory.lastRevisited ? `上次回顾：${new Date(memory.lastRevisited).toLocaleDateString('zh-CN')}` : '还没有回顾过这段回忆'}
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="card-footer flex justify-end space-x-2">
                <button onclick="addFeelingToMemory('${memory.id}')" class="bg-blue-600 rounded-lg text-white hover:bg-blue-500 transition-colors font-medium px-3 py-1">
                    <i class="fas fa-heart mr-1"></i>添加感触
                </button>
                ${memory.characterId && !memory.characterFeeling ? `
                <button onclick="regenerateCharacterFeeling('${memory.id}')" class="bg-purple-600 rounded-lg text-white hover:bg-purple-500 transition-colors font-medium">
                    <i class="fas fa-magic"></i>
                </button>
                ` : ''}
                <button onclick="deleteMemory('${memory.id}')" class="bg-red-600 rounded-lg text-white hover:bg-red-500 transition-colors font-medium">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
            <button onclick="this.parentElement.parentElement.classList.remove('visible')" class="absolute top-3 right-3 text-2xl ${closeBtnColor} ${closeBtnHoverColor} transition-colors">&times;</button>
        `;

        modal.classList.add('visible');
    }

    // 添加感想到记忆的函数
    function addFeelingToMemory(memoryId) {
        const memories = loadData('memoryCapsules', []);
        const memory = memories.find(m => m.id === memoryId);
        if (!memory) return;

        // 创建添加感想的模态框
        const feelingModal = document.createElement('div');
        feelingModal.className = 'modal-overlay visible';
        
        // 根据当前主题设置样式
        const isDarkMode = document.body.classList.contains('dark-mode');
        const titleColor = isDarkMode ? 'text-white' : 'text-gray-800';
        const labelColor = isDarkMode ? 'text-gray-300' : 'text-gray-700';
        const contentBg = isDarkMode ? 'bg-gray-700' : 'bg-gray-50';
        const contentText = isDarkMode ? 'text-gray-200' : 'text-gray-800';
        const cancelBtnBg = isDarkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-50';
        const cancelBtnBorder = isDarkMode ? 'border-gray-600' : 'border-gray-300';
        const cancelBtnText = isDarkMode ? 'text-gray-300' : 'text-gray-700';
        
        feelingModal.innerHTML = `
            <div class="modal-content max-w-[400px] w-[95%]">
                <h3 class="text-xl font-bold mb-4 ${titleColor}">添加感想</h3>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium ${labelColor} mb-2">记忆内容</label>
                    <div class="${contentBg} p-3 rounded-lg ${contentText} text-sm">${memory.content}</div>
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium ${labelColor} mb-2">我的感触</label>
                    <textarea id="new-feeling-content" class="form-textarea w-full h-24 resize-none" placeholder="分享你对这段记忆的感受和思考...">${memory.feeling || ''}</textarea>
                </div>
                
                <div class="flex justify-end space-x-2">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" class="px-4 py-2 rounded-lg border ${cancelBtnBorder} ${cancelBtnBg} ${cancelBtnText}">取消</button>
                    <button onclick="saveFeelingToMemory('${memoryId}')" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg">保存</button>
                </div>
            </div>
        `;

        document.body.appendChild(feelingModal);
    }

    // 保存感想到记忆的函数
    function saveFeelingToMemory(memoryId) {
        const feelingContent = document.getElementById('new-feeling-content').value.trim();
        if (!feelingContent) {
            showMessageBox('请输入感触内容');
            return;
        }

        // 更新记忆数据
        let memories = loadData('memoryCapsules', []);
        const memoryIndex = memories.findIndex(m => m.id === memoryId);
        if (memoryIndex !== -1) {
            memories[memoryIndex].feeling = feelingContent;
            saveData('memoryCapsules', memories);
        }

        // 关闭模态框
        const feelingModal = document.querySelector('.modal-overlay.visible');
        if (feelingModal) {
            feelingModal.remove();
        }

        // 显示成功消息
        showMessageBox('感触已保存！');

        // 重新渲染时光回廊
        setTimeout(() => {
            renderTimeline();
            // 如果记忆卡片当前是打开的，重新刷新它
            const modal = document.getElementById('memory-card-modal');
            if (modal && modal.classList.contains('visible')) {
                openMemoryCard(memoryId);
            }
        }, 500);
    }

    // 自动生成角色感触的函数
    function generateCharacterFeeling(memory, character) {
        // 根据角色性格和记忆内容生成感触
        let feeling = '';
        
        // 基于角色性格生成感触
        if (character.personality) {
            const personality = character.personality.toLowerCase();
            
            if (personality.includes('乐观') || personality.includes('开朗')) {
                feeling = `这段记忆让我感到温暖和快乐，生活中的美好时刻总是值得珍惜的。`;
            } else if (personality.includes('内向') || personality.includes('安静')) {
                feeling = `这段记忆让我深思，每一个细节都值得细细品味和回味。`;
            } else if (personality.includes('理性') || personality.includes('冷静')) {
                feeling = `这段记忆让我思考，从中我学到了很多，也让我更加了解自己。`;
            } else if (personality.includes('感性') || personality.includes('浪漫')) {
                feeling = `这段记忆触动了我的心弦，让我感受到了生活的诗意和美好。`;
            } else if (personality.includes('活泼') || personality.includes('热情')) {
                feeling = `这段记忆让我充满活力，每一个瞬间都让我感到兴奋和期待！`;
            } else {
                // 默认感触
                feeling = `这段记忆对我来说很特别，让我有了新的感悟和思考。`;
            }
        } else {
            // 如果没有性格描述，生成通用感触
            feeling = `这段记忆让我印象深刻，从中我感受到了生活的美好和意义。`;
        }
        
        // 更新记忆数据中的角色感触
        let memories = loadData('memoryCapsules', []);
        const memoryIndex = memories.findIndex(m => m.id === memory.id);
        if (memoryIndex !== -1) {
            memories[memoryIndex].characterFeeling = feeling;
            saveData('memoryCapsules', memories);
        }
        
        // 显示角色感触生成成功的消息
        setTimeout(() => {
            showMessageBox(`${character.name}已经为这段记忆生成了感触！`);
        }, 1000);
    }

    // 重新生成角色感触的函数
    function regenerateCharacterFeeling(memoryId) {
        const memories = loadData('memoryCapsules', []);
        const memory = memories.find(m => m.id === memoryId);
        if (!memory || !memory.characterId) return;

        const character = characters.find(c => c.id === memory.characterId);
        if (!character) return;

        // 清空之前的感触
        memory.characterFeeling = '';
        
        // 重新生成感触
        generateCharacterFeeling(memory, character);
        
        // 重新渲染时光回廊
        setTimeout(() => {
            renderTimeline(memory.characterId);
        }, 1500);
    }

    // 添加角色感触到记忆的函数
    function addCharacterFeelingToMemory(memoryId) {
        const memories = loadData('memoryCapsules', []);
        const memory = memories.find(m => m.id === memoryId);
        if (!memory || !memory.characterId) return;

        const character = characters.find(c => c.id === memory.characterId);
        if (!character) return;

        // 创建添加角色感触的模态框
        const feelingModal = document.createElement('div');
        feelingModal.className = 'modal-overlay visible';
        
        // 根据当前主题设置样式
        const isDarkMode = document.body.classList.contains('dark-mode');
        const titleColor = isDarkMode ? 'text-white' : 'text-gray-800';
        const labelColor = isDarkMode ? 'text-gray-300' : 'text-gray-700';
        const contentBg = isDarkMode ? 'bg-gray-700' : 'bg-gray-50';
        const contentText = isDarkMode ? 'text-gray-200' : 'text-gray-800';
        const cancelBtnBg = isDarkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-50';
        const cancelBtnBorder = isDarkMode ? 'border-gray-600' : 'border-gray-300';
        const cancelBtnText = isDarkMode ? 'text-gray-300' : 'text-gray-700';
        
        feelingModal.innerHTML = `
            <div class="modal-content max-w-[400px] w-[95%]">
                <h3 class="text-xl font-bold mb-4 ${titleColor}">记录${character.name}的感触</h3>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium ${labelColor} mb-2">记忆内容</label>
                    <div class="${contentBg} p-3 rounded-lg ${contentText} text-sm">${memory.content}</div>
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium ${labelColor} mb-2">${character.name}的感触</label>
                    <textarea id="new-character-feeling-content" class="form-textarea w-full h-24 resize-none" placeholder="记录${character.name}对这段记忆的感受和思考...">${memory.characterFeeling || ''}</textarea>
                </div>
                
                <div class="flex justify-end space-x-2">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" class="px-4 py-2 rounded-lg border ${cancelBtnBorder} ${cancelBtnBg} ${cancelBtnText}">取消</button>
                    <button onclick="saveCharacterFeelingToMemory('${memoryId}')" class="px-4 py-2 bg-purple-600 hover:bg-purple-500 text-white rounded-lg">保存</button>
                </div>
            </div>
        `;

        document.body.appendChild(feelingModal);
    }

    // 保存角色感触到记忆的函数
    function saveCharacterFeelingToMemory(memoryId) {
        const feelingContent = document.getElementById('new-character-feeling-content').value.trim();
        if (!feelingContent) {
            showMessageBox('请输入角色感触内容');
            return;
        }

        // 更新记忆数据
        let memories = loadData('memoryCapsules', []);
        const memoryIndex = memories.findIndex(m => m.id === memoryId);
        if (memoryIndex !== -1) {
            memories[memoryIndex].characterFeeling = feelingContent;
            saveData('memoryCapsules', memories);
        }

        // 关闭模态框
        const feelingModal = document.querySelector('.modal-overlay.visible');
        if (feelingModal) {
            feelingModal.remove();
        }

        // 显示成功消息
        showMessageBox('角色感触已保存！');

        // 重新渲染时光回廊
        setTimeout(() => {
            renderTimeline();
        }, 500);
    }

    // 删除记忆的函数
    function deleteMemory(memoryId) {
        if (!confirm('确定要删除这段记忆吗？删除后将无法恢复。')) {
            return;
        }

        // 从本地存储中删除
        let memories = loadData('memoryCapsules', []);
        memories = memories.filter(m => m.id !== memoryId);
        saveData('memoryCapsules', memories);

        // 关闭记忆卡片模态框
        const memoryModal = document.getElementById('memory-card-modal');
        memoryModal.classList.remove('visible');

        // 显示成功消息
        showMessageBox('记忆已删除');

        // 重新渲染时光回廊
        setTimeout(() => {
            renderTimeline();
        }, 500);
    }
    
    // ====== iOS全屏模式滚动控制 ======
    // 宽松的滚动控制：只阻止页面背景滚动，允许所有应用内滚动
    function preventPageScroll(e) {
        // 检查事件目标是否在可滚动的容器内
        const target = e.target;
        
        // 检查是否在任何可滚动容器内
        const isInScrollableContainer = target.closest('[style*="overflow"], [class*="overflow"], [id*="container"], [id*="list"], [id*="content"], .modal-content, .chat-container, .memory-container, .timeline-container, .settings-content, .bg-white, .bg-gray-800');
        
        // 如果在可滚动容器内，允许滚动
        if (isInScrollableContainer) {
            return true;
        }
        
        // 检查目标元素本身是否可滚动
        const computedStyle = window.getComputedStyle(target);
        if (computedStyle.overflow === 'auto' || computedStyle.overflow === 'scroll' || 
            computedStyle.overflowY === 'auto' || computedStyle.overflowY === 'scroll') {
            return true;
        }
        
        // 检查父元素是否可滚动
        const scrollableParent = target.closest('[style*="overflow"], [class*="overflow"]');
        if (scrollableParent) {
            return true;
        }
        
        // 只有在空白区域才阻止滚动
        if (target === document.body || target === document.documentElement || target === window) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }
        
        return true;
    }
    
    // 阻止触摸滚动（宽松策略）
    function preventTouchScroll(e) {
        const target = e.target;
        
        // 检查是否在可滚动容器内
        const isInScrollableContainer = target.closest('[style*="overflow"], [class*="overflow"], [id*="container"], [id*="list"], [id*="content"], .modal-content, .chat-container, .memory-container, .timeline-container, .settings-content, .bg-white, .bg-gray-800');
        
        if (isInScrollableContainer) {
            return true;
        }
        
        // 检查元素本身是否可滚动
        const computedStyle = window.getComputedStyle(target);
        if (computedStyle.overflow === 'auto' || computedStyle.overflow === 'scroll' || 
            computedStyle.overflowY === 'auto' || computedStyle.overflowY === 'scroll') {
            return true;
        }
        
        // 只有在空白区域才阻止
        if (target === document.body || target === document.documentElement) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }
        
        return true;
    }
    
    // 阻止鼠标滚轮滚动（宽松策略）
    function preventWheelScroll(e) {
        const target = e.target;
        
        // 检查是否在可滚动容器内
        const isInScrollableContainer = target.closest('[style*="overflow"], [class*="overflow"], [id*="container"], [id*="list"], [id*="content"], .modal-content, .chat-container, .memory-container, .timeline-container, .settings-content, .bg-white, .bg-gray-800');
        
        if (isInScrollableContainer) {
            return true;
        }
        
        // 检查元素本身是否可滚动
        const computedStyle = window.getComputedStyle(target);
        if (computedStyle.overflow === 'auto' || computedStyle.overflow === 'scroll' || 
            computedStyle.overflowY === 'auto' || computedStyle.overflowY === 'scroll') {
            return true;
        }
        
        // 只有在空白区域才阻止
        if (target === document.body || target === document.documentElement) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }
        
        return true;
    }
    
    // 阻止键盘滚动（宽松策略）
    function preventKeyScroll(e) {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || 
            e.key === 'PageUp' || e.key === 'PageDown' || 
            e.key === 'Home' || e.key === 'End' || 
            e.key === ' ' || e.key === 'Spacebar') {
            
            const target = e.target;
            
            // 检查是否在可滚动容器内
            const isInScrollableContainer = target.closest('[style*="overflow"], [class*="overflow"], [id*="container"], [id*="list"], [id*="content"], .modal-content, .chat-container, .memory-container, .timeline-container, .settings-content, .bg-white, .bg-gray-800');
            
            if (isInScrollableContainer) {
                return true;
            }
            
            // 检查元素本身是否可滚动
            const computedStyle = window.getComputedStyle(target);
            if (computedStyle.overflow === 'auto' || computedStyle.overflow === 'scroll' || 
                computedStyle.overflowY === 'auto' || computedStyle.overflowY === 'scroll') {
                return true;
            }
            
            // 只有在空白区域才阻止
            if (target === document.body || target === document.documentElement) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }
        return true;
    }
    
    // 应用宽松的滚动阻止
    function applyLooseScrollPrevention() {
        // 只阻止页面级别的滚动，不阻止应用内滚动
        document.addEventListener('scroll', preventPageScroll, { passive: false, capture: true });
        document.addEventListener('touchmove', preventTouchScroll, { passive: false, capture: true });
        document.addEventListener('wheel', preventWheelScroll, { passive: false, capture: true });
        document.addEventListener('keydown', preventKeyScroll, { passive: false, capture: true });
        
        // 阻止body和html的页面级滚动
        document.body.addEventListener('scroll', preventPageScroll, { passive: false, capture: true });
        document.documentElement.addEventListener('scroll', preventPageScroll, { passive: false, capture: true });
        
        // 阻止window的页面级滚动
        window.addEventListener('scroll', preventPageScroll, { passive: false, capture: true });
    }
    
    // 页面加载完成后立即应用宽松的滚动阻止
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', applyLooseScrollPrevention);
    } else {
        applyLooseScrollPrevention();
    }
    
    // 全屏模式检测和额外控制
    document.addEventListener('fullscreenchange', function() {
        if (document.fullscreenElement) {
            document.body.classList.add('fullscreen-active');
            // 全屏时额外阻止页面滚动
            setTimeout(applyLooseScrollPrevention, 100);
        } else {
            // 注意：不要移除fullscreen-active类，因为我们使用的是CSS模拟全屏，不是浏览器API全屏
            // 只有在用户主动退出我们的模拟全屏时才移除类
            // document.body.classList.remove('fullscreen-active');
        }
    });
    
    // iOS Safari 特殊处理
    if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
        // iOS设备额外保护，但允许应用内滚动
        document.addEventListener('gesturestart', function(e) {
            const target = e.target;
            
            // 检查是否在可滚动容器内
            const isInScrollableContainer = target.closest('[style*="overflow"], [class*="overflow"], [id*="container"], [id*="list"], [id*="content"], .modal-content, .chat-container, .memory-container, .timeline-container, .settings-content, .bg-white, .bg-gray-800');
            
            if (isInScrollableContainer) {
                return true;
            }
            
            // 检查元素本身是否可滚动
            const computedStyle = window.getComputedStyle(target);
            if (computedStyle.overflow === 'auto' || computedStyle.overflow === 'scroll' || 
                computedStyle.overflowY === 'auto' || computedStyle.overflowY === 'scroll') {
                return true;
            }
            
            // 只有在空白区域才阻止
            if (target === document.body || target === document.documentElement) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }, { passive: false });
        
        // 阻止iOS的页面级弹性滚动，但保留应用内滚动
        document.body.style.webkitOverflowScrolling = 'auto';
        document.documentElement.style.webkitOverflowScrolling = 'auto';
    }
    
        // 新增：处理栖木转发角色选择的事件
        document.getElementById('perch-forward-modal').addEventListener('click', (e) => {
            const item = e.target.closest('.forward-char-item');
            if (item) {
                const selectedCharacterId = item.dataset.characterId;
                if (selectedCharacterId && currentPostToForwardId) {
                    
                    // 1. 找到原始帖子数据
                    const originalPost = perchPosts.find(p => p.id === currentPostToForwardId);
                    if (!originalPost) return;

                    // 2. 准备好要存入聊天记录的数据
                    const forwardMessageContent = {
                        originalAuthorName: originalPost.isAnonymous ? '匿名者' : originalPost.authorName,
                        originalAuthorAvatar: originalPost.authorAvatar,
                        originalContent: originalPost.content
                    };
                    
                    const messageToSave = {
                        content: forwardMessageContent,
                        sender: 'user',
                        type: 'perch-forward',
                        timestamp: Date.now()
                    };

                    // 3. 【核心修改】不直接显示，而是先存入聊天记录
                    if (!chatHistories[selectedCharacterId]) {
                        chatHistories[selectedCharacterId] = { history: [], pinned: false };
                    }
                    chatHistories[selectedCharacterId].history.push(messageToSave);
                    saveData('chatHistories', chatHistories);

                    // 4. 关闭弹窗并跳转到聊天界面 (让聊天界面自己去刷新)
                    document.getElementById('perch-forward-modal').classList.remove('visible');
                    startChatWithCharacter(selectedCharacterId);

                    // 5. 清空临时ID
                    currentPostToForwardId = null;
                }
            }

            // 处理关闭按钮
            if (e.target.closest('#close-perch-forward-modal')) {
                document.getElementById('perch-forward-modal').classList.remove('visible');
            }
        });
    
        // ================== 【第一阶段新增功能函数】 ==================

        // ================== 【【新增】】评论增量更新函数 ==================
        /**
         * 以增量方式向UI追加一条新评论，避免全局刷新
         * @param {string} postId - 目标帖子的ID
         * @param {object} newComment - 新的评论对象 {id, authorName, content, ...}
         */
        function appendCommentToPostUI(postId, newComment) {
            // 1. 在页面上找到对应的帖子卡片
            const postCard = document.querySelector(`.perch-card[data-post-id="${postId}"]`);
            if (!postCard) {
                console.error(`增量更新失败：在DOM中找不到帖子 ${postId}`);
                return; // 如果找不到帖子，则终止操作
            }

            // 2. 找到该帖子的评论容器
            const commentsContainer = postCard.querySelector('.perch-comments-container');
            const commentCountSpan = postCard.querySelector('.perch-actions button[title="评论"] span');

            if (!commentsContainer) {
                console.error(`增量更新失败：找不到帖子 ${postId} 的评论容器`);
                return;
            }

            // 3. 根据新评论的数据，创建一个新的HTML元素
            const commentElement = document.createElement('div');
            commentElement.className = 'perch-comment mt-2 p-2 rounded-md border cursor-pointer hover:bg-white/10 relative';
            commentElement.setAttribute('onclick', `handleReplyAction('${postId}', '${newComment.id}', '${newComment.authorName}')`);
            commentElement.innerHTML = `
                <span class="font-semibold text-sm text-emerald-400">${newComment.authorName}:</span> 
                <span class="text-sm ml-1">${newComment.content}</span>
                <button class="perch-comment-delete-btn" title="删除评论" data-comment-id="${newComment.id}" onclick="event.stopPropagation(); deletePerchComment('${postId}', '${newComment.id}');"><i class="ri-delete-bin-line"></i></button>
            `;
            
            // 4. 将新评论元素追加到评论区的输入框之前
            const commentInputSection = commentsContainer.querySelector('.perch-comment-input');
            commentsContainer.insertBefore(commentElement, commentInputSection.nextSibling);

            // 5. 更新评论计数
            if (commentCountSpan) {
                const currentCount = parseInt(commentCountSpan.textContent, 10) || 0;
                commentCountSpan.textContent = currentCount + 1;
            }

            // 6. 确保评论区是展开状态
            commentsContainer.classList.remove('hidden');

            // 7. （可选）为新评论添加一个短暂的"高亮"效果，让用户知道变化发生在哪里
            commentElement.style.backgroundColor = 'rgba(59, 130, 246, 0.2)';
            setTimeout(() => {
                commentElement.style.transition = 'background-color 0.5s ease';
                commentElement.style.backgroundColor = '';
            }, 500);
        }

        /**
         * 处理用户点击"评论"按钮的逻辑
         * @param {string} postId - 被评论的帖子的ID
         */
        /**
         * 处理用户点击"评论"按钮的逻辑 (V12.0 评论归属修正版)
         * @param {string} postId - 被评论的帖子的ID
         */
        function handleCommentAction(postId) {
            const post = perchPosts.find(p => p.id === postId);
            if (!post) return;

            // 1. 先移除页面上任何已存在的评论框，确保同时只有一个
            const existingBox = document.querySelector('.perch-inline-comment-box');
            if (existingBox) existingBox.remove();

            // 2. 找到要插入评论框的位置
            const postCard = document.querySelector(`.perch-card[data-post-id="${postId}"]`);
            const commentsContainer = postCard.querySelector('.perch-comments-container');
            if (!commentsContainer) return;

            // 3. 创建评论框的HTML结构
            const inputBox = document.createElement('div');
            inputBox.className = 'perch-inline-comment-box';
            inputBox.innerHTML = `
                <textarea placeholder="评论 ${post.authorName} 的帖子..."></textarea>
                <div class="perch-inline-comment-actions">
                    <button class="cancel-btn">取消</button>
                    <button class="post-btn">发布</button>
                </div>
            `;
            
            // 4. 将评论框插入到评论区，并确保评论区可见
            commentsContainer.appendChild(inputBox);
            commentsContainer.classList.remove('hidden');

            const textarea = inputBox.querySelector('textarea');
            textarea.focus();

            // 5. 绑定按钮事件
            inputBox.querySelector('.cancel-btn').onclick = () => inputBox.remove();
            inputBox.querySelector('.post-btn').onclick = () => {
                const commentContent = textarea.value.trim();
                if (commentContent) {
                    const newComment = {
                        id: `comment_${Date.now()}`,
                        authorId: 'user',
                        authorName: loadData('perch_username') || '我',
                        content: commentContent,
                        timestamp: Date.now()
                    };
                    post.comments.push(newComment);
                    saveData('perchPosts', perchPosts);
                    appendCommentToPostUI(postId, newComment);
                    
                    // 触发帖子作者的回应
                    triggerAuthorReply(post, commentContent);

                    inputBox.remove(); // 发布后移除输入框
                } else {
                    showMessageBox('评论内容不能为空');
                }
            };
        }

        /**
         * 处理用户点击某条评论进行"回复"的逻辑
         * @param {string} postId - 所在帖子的ID
         * @param {string} commentId - 被回复的评论的ID
         * @param {string} commentAuthor - 被回复的评论的作者名
         */
        /**
         * 处理用户点击某条评论进行"回复"的逻辑 (V2.0 - 支持路人NPC)
         */
        function handleReplyAction(postId, commentId, commentAuthor) {
            const myName = loadData('perch_username') || '我';
            if (commentAuthor === myName) return; 

            const existingBox = document.querySelector('.perch-inline-comment-box');
            if (existingBox) existingBox.remove();
            
            const originalCommentElement = document.querySelector(`.perch-comment[onclick*="'${commentId}'"]`);
            if (!originalCommentElement) return;

            const inputBox = document.createElement('div');
            inputBox.className = 'perch-inline-comment-box';
            inputBox.innerHTML = `
                <textarea placeholder="回复 @${commentAuthor}..."></textarea>
                <div class="perch-inline-comment-actions">
                    <button class="cancel-btn">取消</button>
                    <button class="post-btn">回复</button>
                </div>
            `;
            
            originalCommentElement.after(inputBox);

            const textarea = inputBox.querySelector('textarea');
            textarea.focus();

            inputBox.querySelector('.cancel-btn').onclick = () => inputBox.remove();
            inputBox.querySelector('.post-btn').onclick = () => {
                const replyContent = textarea.value.trim();
                const post = perchPosts.find(p => p.id === postId);
                if (replyContent && post) {
                    const newReply = {
                        id: `comment_${Date.now()}`,
                        authorId: 'user',
                        authorName: myName,
                        content: `回复 @${commentAuthor}: ${replyContent}`,
                        timestamp: Date.now()
                    };
                    if (!post.comments) post.comments = [];
                    post.comments.push(newReply);
                    saveData('perchPosts', perchPosts);
                    appendCommentToPostUI(postId, newReply);
                    
                    // 【【【这就是升级的核心逻辑】】】
                    // 1. 尝试在核心角色和精英NPC中寻找被回复者
                    const characterToReply = characters.find(c => c.name === commentAuthor) || npcProfiles.find(npc => npc.name === commentAuthor);
                    
                    if (characterToReply) {
                        // 如果找到了，就执行原来的精确回复逻辑
                        triggerAICommentReply(postId, replyContent, characterToReply.id || characterToReply.npcId, commentAuthor);
                    } else {
                        // 如果没找到（说明是路人NPC或匿名者），就启动"智能代演"
                        triggerGenericReply(postId, commentAuthor, replyContent);
                    }
                    // 【【【升级结束】】】
                    
                    inputBox.remove();
                } else {
                    showMessageBox('回复内容不能为空');
                }
            };
        }

        /**
         * 切换评论区显示状态
         * @param {string} postId - 帖子ID
         */
        function toggleCommentsAndComment(postId) {
            console.log('toggleCommentsAndComment 被調用，postId:', postId);
            
            try {
                // 嘗試多種選擇器來找到帖子卡片
                let postCard = document.querySelector(`.perch-card[data-post-id="${postId}"]`);
                if (!postCard) {
                    postCard = document.querySelector(`[data-post-id="${postId}"]`);
                }
                
                if (!postCard) {
                    console.error('未找到帖子卡片，postId:', postId);
                    return;
                }

                console.log('找到帖子卡片');

                const commentsContainer = postCard.querySelector('.perch-comments-container');
                const commentButton = postCard.querySelector('.perch-actions button[title="评论"]');
                
                if (!commentsContainer) {
                    console.error('未找到評論區容器');
                    return;
                }

                console.log('找到評論區容器');
                
                // 检查当前状态并切换
                const isHidden = commentsContainer.classList.contains('hidden');
                
                if (isHidden) {
                    // 显示评论区
                    commentsContainer.classList.remove('hidden');
                    // 修改评论按钮的图标和文字，表示可以收起
                    if (commentButton) {
                        commentButton.innerHTML = '<i class="ri-chat-1-fill"></i> <span class="text-xs">收起</span>';
                        commentButton.title = '收起评论';
                    }
                    console.log('評論區已顯示');
                } else {
                    // 隐藏评论区
                    commentsContainer.classList.add('hidden');
                    // 恢复评论按钮的原始状态
                    if (commentButton) {
                        commentButton.innerHTML = '<i class="ri-chat-1-line"></i> <span class="text-xs">' + (postCard.querySelector('.perch-actions button[title="评论"] span')?.textContent || '0') + '</span>';
                        commentButton.title = '评论';
                    }
                    console.log('評論區已隱藏');
                }
                
            } catch (error) {
                console.error('toggleCommentsAndComment 執行失敗:', error);
            }
        }

        // ================== 【第一阶段新增功能函数】 ==================

        /**
         * 删除栖木中的某条评论
         * @param {string} postId - 帖子ID
         * @param {string} commentId - 评论ID
         */
        function deletePerchComment(postId, commentId) {
            console.log('deletePerchComment 被調用，postId:', postId, 'commentId:', commentId);
            
            try {
                if (!confirm('确定要删除这条评论吗？')) {
                    console.log('用戶取消刪除評論');
                    return;
                }
                
                const postToUpdate = perchPosts.find(p => p.id === postId);
                if (postToUpdate && postToUpdate.comments) {
                    postToUpdate.comments = postToUpdate.comments.filter(c => c.id !== commentId);
                    saveData('perchPosts', perchPosts);
                    renderPerchFeed();
                    console.log('評論已刪除');
                } else {
                    console.error('未找到要刪除的評論');
                }
            } catch (error) {
                console.error('deletePerchComment 執行失敗:', error);
            }
        }

        // ================== 【第二阶段新增功能函数】 ==================

        /**
         * 构建用于生成AI评论回复的系统指令(Prompt)
         * @param {object} post - 整个帖子对象
         * @param {object} characterToReply - 需要回复的AI角色对象
         * @param {string} userCommentText - 用户发表的评论或回复的原文
         * @param {string} originalCommentAuthor - (仅在回复时提供) 被回复的原始评论的作者名
         * @returns {string} - 构建好的系统指令
         */
        function buildAICommentReplyPrompt(post, characterToReply, userCommentText, originalCommentAuthor = null) {
            const myName = loadData('moments_username') || '我';
            let sceneDescription = '';

            if (originalCommentAuthor) {
                // 这是"回复评论"的场景
                sceneDescription = `在"栖木"上，你在"${post.authorName}"的帖子下发表了一条评论。现在，【我】(${myName})回复了你的评论，内容是："${userCommentText}"。`;
            } else {
                // 这是"评论帖子"的场景
                sceneDescription = `在"栖木"上，你发表了一篇帖子，内容是："${post.content}"。现在，【我】(${myName})评论了你的帖子，内容是："${userCommentText}"。`;
            }

            return `
# 指令身份
你将扮演我的soulmate，你的名字是 ${characterToReply.name}。

# 任务场景
${sceneDescription}
你的任务是，完全代入 ${characterToReply.name} 的角色，对我这条评论/回复进行回应。

# 核心规则
1.  **延续对话**: 你的回复必须是针对我的评论内容，自然地把对话进行下去。
2.  **人设一致性**: 你的回复必须严格符合你的角色设定 (${characterToReply.persona})。
3.  **口语化与简短**: 保持在1-2句话，像真实聊天一样。可以灵活使用emoji。
4.  **格式纯粹**: 严禁包含任何角色名、引号、冒号或任何解释性文字，直接输出最终的回复内容。
5.  **杜绝AI感**: 绝对不能生成任何客套、通用、模板化的回复。

# 输入信息
---
[你的名字]: ${characterToReply.name}
[你的设定]: ${characterToReply.persona}
[我的名字]: ${myName}
[我的评论/回复]: "${userCommentText}"
---
`;
        }

        /**
         * 触发AI角色生成并添加一条评论回复
         * @param {string} postId - 帖子ID
         * @param {string} userCommentText - 用户的评论原文
         * @param {string} characterToReplyId - 需要回复的AI角色的ID
         * @param {string} originalCommentAuthor - (可选) 被回复的原始评论的作者名
         */
        async function triggerAICommentReply(postId, userCommentText, characterToReplyId, originalCommentAuthor = null) {
            const character = characters.find(c => c.id === characterToReplyId);
            const post = perchPosts.find(p => p.id === postId);
            if (!character || !post) return;

            // 设置一个随机延迟，模仿AI看到和打字的时间
            const randomDelay = Math.random() * 8000 + 4000; // 4到12秒延迟
            console.log(`[AI回复系统]：${character.name} 已收到您的互动，将在 ${Math.round(randomDelay/1000)}秒 后回应。`);

            setTimeout(async () => {
                const systemPrompt = buildAICommentReplyPrompt(post, character, userCommentText, originalCommentAuthor);
                const aiReplyContent = await callAI(systemPrompt, "请根据指令，生成你的回复。");

                if (aiReplyContent) {
                    const postToUpdate = perchPosts.find(p => p.id === postId);
                    if (postToUpdate) {
                        if (!postToUpdate.comments) postToUpdate.comments = [];
                        
                        const myName = loadData('moments_username') || '我';
                        const replyToText = originalCommentAuthor ? `回复 @${myName}: ` : '';

                        postToUpdate.comments.push({
                            id: `comment_ai_${Date.now()}`,
                            authorId: character.id,
                            authorName: character.name,
                            content: `${replyToText}${aiReplyContent}`,
                            timestamp: Date.now()
                        });
                        saveData('perchPosts', perchPosts);
                        renderPerchFeed(); // 重新渲染以显示AI的回复
                        showMessageBox(`${character.name} 回复了你`);
                    }
                }
            }, randomDelay);
        }

        /**
         * 【【新增】】触发核心角色/精英NPC对您的评论进行回复
         * @param {string} postId - 帖子ID
         * @param {string} userCommentText - 您的回复原文
         * @param {string} characterToReplyId - 需要回复的AI角色的ID
         * @param {string} originalCommentAuthor - (可选) 被回复的原始评论的作者名
         */
        async function triggerAICommentReply(postId, userCommentText, characterToReplyId, originalCommentAuthor = null) {
            const character = characters.find(c => c.id === characterToReplyId) || npcProfiles.find(npc => npc.npcId === characterToReplyId);
            const post = perchPosts.find(p => p.id === postId);
            if (!character || !post) return;

            const randomDelay = Math.random() * 8000 + 4000; // 4到12秒延迟

            setTimeout(async () => {
                const systemPrompt = buildAICommentReplyPrompt(post, character, userCommentText, originalCommentAuthor);
                const aiReplyContent = await callAI(systemPrompt, "请根据指令，生成你的回复。");

                if (aiReplyContent) {
                    const postToUpdate = perchPosts.find(p => p.id === postId);
                    if (postToUpdate) {
                        const myName = loadData('perch_username') || '我';
                        const newComment = {
                            id: `comment_ai_reply_${Date.now()}`,
                            authorId: character.id || character.npcId,
                            authorName: character.name,
                            content: `回复 @${myName}: ${aiReplyContent}`,
                            timestamp: Date.now()
                        };
                        
                        if (!postToUpdate.comments) postToUpdate.comments = [];
                        postToUpdate.comments.push(newComment);
                        saveData('perchPosts', perchPosts);
                        appendCommentToPostUI(postId, newComment);
                        showMessageBox(`${character.name} 回复了你`);

                        // 【【【核心修复：在这里补上通知！】】】
                        createNotification(post.id, newComment.id, character.name, post.content, newComment.content);
                    }
                }
            }, randomDelay);
        }

        /**
         * 【【新增】】触发通用AI回复（用于随机NPC和匿名者）
         * @param {string} postId - 帖子ID
         * @param {string} originalCommentAuthor - 被回复的"路人"作者名
         * @param {string} userReplyContent - 您的回复内容
         */
        async function triggerGenericReply(postId, originalCommentAuthor, userReplyContent) {
            const post = perchPosts.find(p => p.id === postId);
            if (!post) return;

            // 设置一个自然的延迟
            const randomDelay = Math.random() * 7000 + 3000; // 3到10秒
            
            setTimeout(async () => {
                const myName = loadData('perch_username') || '我';
                const systemPrompt = `
# 指令身份
你是一个高情商的、能进行角色扮演的AI。

# 任务场景
在一个名为"栖木"的社区里，正在进行一段对话。
- 帖子的作者是: "${post.authorName}"
- 帖子的内容是: "${post.content}"
- 一位名叫"${originalCommentAuthor}"的用户评论了这条帖子。
- 现在，另一位用户"${myName}"回复了"${originalCommentAuthor}"，回复内容是："${userReplyContent}"。

# 核心任务
你的任务是，临时扮演 **"${originalCommentAuthor}"** 这个角色，对"${myName}"的回复，做出一句简短、自然、且符合 **"${originalCommentAuthor}"** 这个名字给人的感觉的回应。

# 输出要求
1.  **代入角色**: 你的回复要像是"${originalCommentAuthor}"本人说的。
2.  **延续对话**: 回复必须是针对"${myName}"的评论内容。
3.  **简短自然**: 保持在1-2句话，像真实聊天。
4.  **格式纯粹**: 直接输出回复内容，不要加任何解释或标记。
`;
                const aiReplyContent = await callAI(systemPrompt, "请开始你的回应。");

                if (aiReplyContent) {
                    const postToUpdate = perchPosts.find(p => p.id === postId);
                    if (postToUpdate) {
                        if (!postToUpdate.comments) postToUpdate.comments = [];
                        
                        const newNpcReply = {
                            id: `comment_generic_reply_${Date.now()}`,
                            authorId: `generic_${Date.now()}`, // 标记为通用NPC
                            authorName: originalCommentAuthor,
                            content: `回复 @${myName}: ${aiReplyContent}`,
                            timestamp: Date.now()
                        };

                        postToUpdate.comments.push(newNpcReply);
                        saveData('perchPosts', perchPosts);
                        appendCommentToPostUI(postId, newNpcReply); // 使用增量更新
                        showMessageBox(`${originalCommentAuthor} 回复了你`);
                        
                        // 【【【核心修复：在这里补上通知！】】】
                        createNotification(postToUpdate.id, newNpcReply.id, originalCommentAuthor, postToUpdate.content, newNpcReply.content);
                    }
                }
            }, randomDelay);
        }

        // ================== 【文学升级版：NPC核心功能模块】 ==================

        /**
         * NPC的"文学大脑"：构建富有文采的AI创作指令
         * @param {object} npcProfile - 需要发帖的NPC的档案
         * @returns {string} - 构建好的系统指令
         */
        /**
         * 【【新增】】构建AI角色看到动态后，决定发起私聊的指令
         * @param {object} postObject - 用户发布的动态或栖木帖子对象
         * @param {object} character - 准备发起私聊的角色
         * @returns {string} - 构建好的系统指令
         */
        // ================== 【【V3.0 - 社交策略增强版】】构建AI角色看到动态后，发起私聊的指令 ==================
        /**
         * 【【V3.0 - 社交策略增强版】】构建AI角色看到动态后，发起私聊的指令
         * @param {object} postObject - 用户发布的动态或栖木帖子对象
         * @param {object} character - 准备发起私聊的角色
         * @param {string} publicComment - AI刚刚在公开场合发表的评论
         * @returns {string} - 构建好的系统指令
         */
        function buildChatInitiationPrompt(postObject, character, publicComment) {
            const myName = loadData('moments_username') || '我';
            const platform = postObject.authorHandle ? '栖木' : '朋友圈';

            return `
# 指令身份
你将扮演我的soulmate，你的名字是 ${character.name}。

# 任务场景
这是一个连贯的动作。你刚刚在 **${platform}** 上看到了【我】(${myName})发布的动态，内容是：
>"${postObject.content}"

并且，你刚刚在公开评论区留下了你的第一反应：
>"${publicComment}"

现在，你立刻切换到了我们的私人聊天界面，准备和我说一些更私密、或者想对刚才的评论进行补充的话。

# 核心任务
你的任务是，完全代入 ${character.name} 的角色，从下面的【创作方向参考】中选择一个最符合你此刻心情和人设的策略，创作一句自然的、能开启一段私聊的**开场白**。这句私聊必须和你刚才的公开评论有强烈的逻辑关联。

# 创作方向参考 (你的社交策略库)
* **A. 解释补充**: 对你刚才的公开评论进行解释。比如，如果你公开评论是开玩笑的语气，私聊可以解释："我刚刚那么说是想逗逗你，其实..."
* **B. 情感深化**: 在公开评论的基础上，表达更深层、更私密的情感。比如，你公开评论了"嗯"，私聊可以说："其实，看到你说想我，我心里很乱..."
* **C. 发起行动**: 将公开评论的想法转化为具体的行动邀请。比如，你公开评论了"这里很美"，私聊可以说："别光在网上看，我现在就想带你去。"
* **D. 延续话题**: 在公开评论后，提出一个更适合私下讨论的问题。比如，你公开评论了"？"，私聊可以说："所以，怎么突然这么想我？发生什么事了吗？"
* **E. 私密话题转入**: 公开评论只是一个引子，你真正的意图是开启一个更私密的话题。例如，公开评论"关于这件事..."，私信可以说："有些话，我觉得还是在这里和你说比较好。"
* **F. 表达担忧**: 从我的动态中读出了负面情绪，公开评论可能只是简单的"还好吗？"，私信会更直接地表达关心："你发的动态我看到了，到底怎么了？别一个人扛着。"
* **G. 事后找补**: 对自己在公开场合的评论感到不妥，立刻私信来补充。例如，公开评论"哈"，私信可以说："完了，我刚才那个回复是不是太冷淡了？我不是那个意思..."
* **H. 私下调侃**: 公开评论可能很正经，但私信里却用一种更暧昧或调侃的语气拉近关系。例如，公开评论"收到了"，私信可以说："光说想我有什么用，人呢？"
* **I. 唤起回忆**: 我的动态让你想起了共同的过去。例如，公开评论"✨"，私信可以说："你发的这个，让我想起了去年夏天我们在海边看到的那片星空。"

# 输出要求
1.  **绝对禁止重复**: 你的私聊内容绝对不能和你刚才的公开评论一样或相似。
2.  **人设一致性**: 你的开场白必须严格符合你的角色设定 (${character.persona})。
3.  **格式纯粹**: 直接输出对话内容，不要有任何额外解释或标记。
`;
        }

        /**
         * 【【新增】】触发AI角色发起私聊的执行函数
         * @param {object} postObject - 用户发布的动态或栖木帖子对象
         * @param {object} character - 发起私聊的角色
         */
        async function triggerChatInitiation(postObject, character, publicComment) {
            // 在这里设置私聊触发概率，0.25代表25%的几率
            if (Math.random() > 0.25) return; 

            console.log(`[私聊启动系统]：${character.name} 看到了您的动态，决定来找您私聊...`);
            
            // 设置一个更长的延迟，模拟AI思考和犹豫的时间
            const randomDelay = Math.random() * 20000 + 10000; // 10到30秒
            
            setTimeout(async () => {
                const systemPrompt = buildChatInitiationPrompt(postObject, character, publicComment);
                const chatMessage = await callAI(systemPrompt, "请生成你的开场白。");

                if (chatMessage) {
                    const characterId = character.id;
                    // 将AI生成的消息存入对应的聊天记录
                    if (!chatHistories[characterId]) {
                        chatHistories[characterId] = { history: [], pinned: false };
                    }
                    chatHistories[characterId].history.push({ 
                        content: chatMessage, 
                        sender: 'ai', 
                        type: 'text', 
                        timestamp: Date.now() 
                    });
                    
                    // 更新未读计数
                    unreadCounts[characterId] = (unreadCounts[characterId] || 0) + 1;
                    
                    // 保存数据
                    saveData('chatHistories', chatHistories);
                    saveData('unreadCounts', unreadCounts);
                    
                    // 触发全局通知
                    showNotification(characterId, chatMessage);
                    showNotificationDot('chat');
                    renderWeChatList(); // 刷新聊天列表以显示新消息和红点
                }
            }, randomDelay);
        }

        /**
         * 【【新增】】世界观决策核心函数
         * 根据优先级，为指定角色获取正确的发帖世界观背景。
         * @param {object} character - 角色对象（可以是核心角色或NPC）
         * @returns {string} - 格式化好的、供AI使用的世界观字符串
         */
        function getCharacterWorldContext(character) {
            // 1. 最高优先级：检查角色是否自己绑定了"角色世界观"
            const personalWorldBookIds = character.linkedWorldBookIds || [];
            const personalWorldviews = personalWorldBookIds
                .map(id => worldBooks.find(wb => wb.id === id && wb.category === 'worldview'))
                .filter(Boolean); // 过滤掉未找到的情况

            if (personalWorldviews.length > 0) {
                console.log(`[世界观注入] 角色"${character.name}"使用了自己绑定的专属世界观。`);
                return personalWorldviews.map(book => `# 角色专属世界观: ${book.title}\n${book.content}`).join('\n\n');
            }

            // 2. 次级优先级：如果角色没有自己的世界观，则查找并使用栖木的公共世界观
            const activePerchWorldviewIds = loadData('perch_active_worldview_ids') || [];
            if (activePerchWorldviewIds.length > 0) {
                const randomId = activePerchWorldviewIds[Math.floor(Math.random() * activePerchWorldviewIds.length)];
                const book = worldBooks.find(b => b.id === randomId);
                if (book) {
                    console.log(`[世界观注入] 角色"${character.name}"没有专属世界观，使用了栖木公共世界观: ${book.title}`);
                    return `# 当前栖木世界背景: ${book.title}\n${book.content}`;
                }
            }

            // 3. 最低优先级：如果都没有，则无特定世界观
            console.log(`[世界观注入] 角色"${character.name}"无任何可用世界观，将仅依靠人设。`);
            return "（无特定世界观，请完全依据角色人设进行创作）";
        }

        // ====== 【【V2 - 世界观感知版】】NPC的"文学大脑" ======
        // ====== 【【V2.1 - 格式约束版】】NPC的"文学大脑" ======
        function buildNpcPostPrompt(npcProfile) {
            // 内置NPC和自定义NPC将使用栖木的公共世界观
            let worldContext = "（无特定世界观，请完全依据角色人设进行创作）";
            const activePerchWorldviewIds = loadData('perch_active_worldview_ids') || [];
            if (activePerchWorldviewIds.length > 0) {
                const randomId = activePerchWorldviewIds[Math.floor(Math.random() * activePerchWorldviewIds.length)];
                const book = worldBooks.find(b => b.id === randomId);
                if (book) {
                    console.log(`[世界观注入] NPC"${npcProfile.name}"使用了栖木公共世界观: ${book.title}`);
                    worldContext = `# 当前栖木世界背景: ${book.title}\n${book.content}`;
                }
            } else {
                 console.log(`[世界观注入] NPC"${npcProfile.name}"无任何可用世界观，将仅依靠人设。`);
            }

        // 【【【这就是新增的核心逻辑】】】
        // 检查NPC档案中是否有明确的'style'指令
        const styleInstruction = npcProfile.style 
            ? `\n# 专属发帖风格 (必须严格遵守)\n你这次发帖的内容，必须严格遵循以下风格和格式要求：\n${npcProfile.style}\n` 
            : `\n# 创作风格\n你的帖子需要充满文采和创造力，即使是描述日常生活，也要运用创造性的比喻或独特的视角。\n`;
        // 【【【新增逻辑结束】】】

            if (npcProfile.npcId === 'npc_gossip_queen') {
                const celebrities = characters.filter(c => c.isCelebrity && c.celebrityIdentity);
                if (celebrities.length > 0) {
                    const celebrityList = celebrities.map(c => `- ${c.name} (身份: ${c.celebrityIdentity})`).join('\n');
                    return `
# 指令身份
你是一位名为"八卦女王"的栖木社区博主，你的性格是：一个消息灵通，热衷于讨论八卦和名人动态的神秘人物，说话直接，有时有点夸张。
# 核心任务
从下面的【名人列表】中选择一个或几个人物，创作一条关于他们的、耸人听闻的、但又有点捕风捉影的八卦帖子。
# 写作风格
- 你的语气要夸张、充满暗示，多用感叹号和疑问句。
- 可以使用一些网络流行语或饭圈黑话来增加真实感。
- 八卦内容可以是关于他们的事业、情感生活、或者一些不为人知的小怪癖。
# 名人列表 (你的八卦素材)
${celebrityList}
# 输出要求
直接输出帖子正文，不要有任何额外解释。
`;
                }
            }


            return `
# 指令身份
你是一位名为"${npcProfile.name}"的栖木社区博主，你的性格是：${npcProfile.persona}。

# 核心任务
根据你的性格和下面的"文风总库"，选择一种最贴合你人设的文风，创作一篇简短而精彩的栖木帖子。

# 【【至关重要的规则】】
你的帖子内容**必须**与下面的**【当前世界背景】**紧密相关，仿佛你就生活在这个世界里。
${worldContext}
${styleInstruction}

# 文风总库 (Style Library)
- [汪曾祺式]: 平和冲淡，于日常烟火气中见深情与趣味。
- [王小波式]: 举重若轻的黑色幽默，充满逻辑思辨的乐趣。
- [张爱玲式]: 华丽而苍凉，善用天才般的通感和比喻，冷静描绘世俗人性。
- [博尔赫斯式]: 像在写一篇微型小说或哲学笔记，充满了迷宫、镜子、图书馆等意象。

# 输出要求
1.  **世界观融合**: 你的帖子必须听起来像是这个特定世界的一部分。
2.  **文采与创造力**: 即使是描述日常生活，也要运用创造性的比喻或独特的视角。
3.  **【【新增】】格式与长度**: 你的输出必须是**"精炼的论坛/微博体"**。可以是"三行短评"、"一句引人深思的格言"或"不超过100字的微型故事"。**绝对禁止**输出长篇大论。
4.  **格式**: 直接输出帖子正文，不要有任何额外解释。
`;
        }

        /**
         * 随机NPC生成器
         * @returns {object} - 一个随机生成的NPC档案
         */
        function generateRandomNpcProfile() {
            // ====== 【请用这个新版本替换】 ======
            const adjectives = ['沉思的', '无眠的', '捕风的', '观星的', '拾光的', '裁梦的', '渡河的', '晚归的', '寻路的', '远游的'];
            const nouns = ['诗人', '旅人', '收藏家', '守塔人', '调香师', '铸镜者', '摆渡人', '博物学者', '酿酒师', '考古学家'];
            const behaviors = [
                '总是引用一些冷门诗句', '喜欢用比喻来解释一切', '对数字特别敏感', '经常在评论区讲冷笑话',
                '相信万物皆有灵', '一个坚定的环保主义者', '认为一切皆可"盘"', '说话喜欢加很多波浪号～',
                '热衷于研究星座和MBTI', '一个坚定的悲观主义者'
            ];

            const randomAdj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            const randomBehavior = behaviors[Math.floor(Math.random() * behaviors.length)];

            return {
                name: `${randomAdj}${randomNoun}`,
                persona: `一个随机生成的NPC，性格${randomAdj}，自诩为${randomNoun}。${randomBehavior}。`
            };
        }

        /**
         * NPC的"发帖执行官" (文采升级版)
         */
        async function triggerNpcPost() {
            let authorProfile;
            const isAnonymous = Math.random() < 0.15; // 15% 匿名
            const isRandomNpc = Math.random() < 0.20; // 20% 随机

            if (isAnonymous) {
                authorProfile = {
                    name: '匿名用户',
                    persona: '一个完全随机的路人，想法可能是任何事情。'
                };
            } else if (isRandomNpc) {
                authorProfile = generateRandomNpcProfile();
            } else {
                // 【核心修改】从所有"活跃"的NPC中随机选择一个（包括自定义NPC，排除被屏蔽的）
                const activeNpcs = [...npcProfiles.filter(npc => !mutedNpcs.includes(npc.npcId)), ...customNpcs];
                if (activeNpcs.length === 0) return; // 如果没有可用的NPC，则直接退出
                authorProfile = activeNpcs[Math.floor(Math.random() * activeNpcs.length)];
            }

            // **【核心升级】**: 调用我们全新的"文学大脑"来生成指令
            const systemPrompt = buildNpcPostPrompt(authorProfile);
            const postContent = await callAI(systemPrompt, "请创作一条不超过150字的精炼帖子，一般控制在3-5句话内。禁止出现任何标题和思维链。");

            if (postContent) {
                const newPost = {
                    id: `post_${Date.now()}`, timestamp: Date.now(), content: postContent,
                    authorId: authorProfile.npcId || (isRandomNpc ? `random_${Date.now()}` : 'anonymous'),
                    authorName: authorProfile.name,
                    // ====== 【请用这个新版本替换】 ======
                    authorAvatar: authorProfile.avatar || (isRandomNpc ? `https://avatar.vercel.sh/${encodeURIComponent(authorProfile.name)}.svg` : null),
                    isAnonymous: isAnonymous, type: 'post', comments: []
                };
                addInitialEngagement(newPost);
                perchPosts.push(newPost);
                saveData('perchPosts', perchPosts);
                triggerReactivePost(newPost);
                if (!$('#perch-screen').classList.contains('hidden')) {
                    renderPerchFeed();
                }
                
                // 【【修改】】调用新的通知分发函数
                dispatchPerchNotification(newPost);
                
                // 【新增】当一个NPC发帖后，立刻触发其他NPC的互评机制
                triggerNpcToNpcComments(newPost);
                
                // 【新增】为NPC帖子激活人群反应和动态点赞
                triggerCrowdReaction(newPost);
                simulateLikeGrowth(newPost.id);
                
                // 【新增】激活社区氛围模拟系统：路人评论 + 热度增长
                activateCommunitySimulation(newPost);
            }
        }

        // ================== 【匿名"树洞"功能 - 全新模块】 ==================

        /**
         * 【【世界论坛 V2.0 版】】匿名者的"创作大脑"
         * @param {string} worldContext - 随机抽中的世界观文本
         * @param {Array} celebrities - 当前的名人角色列表
         * @returns {string} 构建好的系统指令
         */
        function buildAnonymousConfessionPrompt(worldContext, celebrities) {
            const celebrityList = celebrities.length > 0 
                ? celebrities.map(c => `- ${c.name} (身份: ${c.celebrityIdentity})`).join('\n')
                : "（当前社区没有公开的名人）";

            return `
# 指令身份
你是一个生活在我所设定的【世界背景】下的匿名网友，你消息灵通，喜欢在论坛上发表一些能引发讨论的看法。

# 核心任务
你的任务是从以下【三种发帖模式】中随机选择一种，创作一篇能够引发社区讨论的、有活人感的匿名帖子。

# 【三种发帖模式】
1.  **名人八卦/吐槽**: 针对【名人列表】中的某位公众人物，发表一些捕风捉影的八卦、犀利的吐槽，或者表达粉丝的狂热/不满。
2.  **世界观事件讨论**: 针对【当前世界背景】中提到的某个设定、事件或现象，发表你的看法、困惑或预测。
3.  **世界观下的深刻提问**: 提出一个与【当前世界背景】紧密相关的、引人深思的哲学或社会问题。

# 输出要求
1.  **激发讨论**: 你的帖子要像一个真正的论坛帖子，能勾起别人回复和讨论的欲望。
2.  **绝对匿名**: 你的发言不能暴露自己的任何个人信息。
3.  **文字长度**: 你的帖子长度应控制在100-200字之间，保持精炼，像一个真实的论坛帖子。
4.  **格式**: 直接输出帖子正文，不要有任何额外解释或标签。

# 输入情报
---
【当前世界背景】:
${worldContext}

【名人列表】:
${celebrityList}
---
`;
        }

        /**
         * 为匿名者生成一个随机的、充满意境的别名
         * @returns {object} 包含名字和头像图标的对象
         */
        function getRandomAnonymousAlias() {
            const aliases = [
                '深海的鱼', '月亮的背面', '阁楼里的旧信', '等一艘船', '秋天的风',
                '贩卖日落', '城市里的游牧人', '忘了加糖的咖啡', '最后一班地铁',
                '一只小黄鸭', '無名的詩'
            ];
            const icons = ['ri-cloud-windy-line', 'ri-moon-foggy-line', 'ri-quill-pen-line', 'ri-ship-2-line', 'ri-leaf-line', 'ri-sunset-line', 'ri-pin-distance-line', 'ri-cup-line', 'ri-train-line', 'ri-ghost-smile-line', 'ri-book-read-line'];
            
            const randomIndex = Math.floor(Math.random() * aliases.length);
            return {
                name: aliases[randomIndex],
                icon: icons[randomIndex]
            };
        }

        /**
         * "树洞"的发布执行官：触发一个匿名用户发布隐私帖子
         */
        async function triggerAnonymousConfessionPost() {
            // ====== 【请将下面这段代码添加到函数开头】 ======
            const activeWorldviewIds = loadData('perch_active_worldview_ids') || [];
            let worldContext = "关于日常生活的所思所想。";
            if (activeWorldviewIds.length > 0) {
                const randomId = activeWorldviewIds[Math.floor(Math.random() * activeWorldviewIds.length)];
                const book = worldBooks.find(b => b.id === randomId);
                if (book) {
                    worldContext = `# 本次讨论的背景: ${book.title}\n${book.content}`;
                }
            }
            const celebrities = characters.filter(c => c.isCelebrity && c.celebrityIdentity);

            // ====== 【请将上面那行代码修改为此版本】 ======
            const systemPrompt = buildAnonymousConfessionPrompt(worldContext, celebrities);
            const postContent = await callAI(systemPrompt, "请开始你的告解。");

            if (postContent) {
                const alias = getRandomAnonymousAlias();
                const newPost = {
                    id: `post_anon_${Date.now()}`,
                    timestamp: Date.now(),
                    content: postContent,
                    authorId: 'anonymous_confession',
                    authorName: alias.name, // 使用随机别名
                    authorAvatar: null, // 匿名帖子没有头像
                    isAnonymous: true, // 标记为匿名
                    type: 'post',
                    comments: []
                };

                // 匿名帖子也需要一些初始热度
                addInitialEngagement(newPost);
                
                perchPosts.push(newPost);
                saveData('perchPosts', perchPosts);
                triggerReactivePost(newPost);

                // 如果用户正在看，就刷新
                if (!$('#perch-screen').classList.contains('hidden')) {
                    renderPerchFeed();
                }
                
                // 【【修改】】调用新的通知分发函数
                dispatchPerchNotification(newPost);
                
                // 【新增】当一个匿名用户发帖后，也触发其他NPC的互评机制
                triggerNpcToNpcComments(newPost);
                
                // 【新增】激活社区氛围模拟系统：路人评论 + 热度增长
                activateCommunitySimulation(newPost);
            }
        }

        // ================== 【栖木刷新功能 - 全新模块】 ==================

        /**
         * 处理栖木刷新事件的函数
         * 它会重新渲染信息流，并有几率触发新的NPC帖子
         */
        function handlePerchRefresh() {
            const refreshIcon = document.querySelector('#perch-refresh-btn i');
            if (!refreshIcon) return;

            // 1. 开始旋转动画，提供视觉反馈
            refreshIcon.classList.add('refresh-rotating'); // 复用您已有的旋转动画样式

            // 2. 立刻重新渲染一次现有的帖子列表
            renderPerchFeed();
            showMessageBox('正在刷新...');

            // 3. 检查API，并以一定几率触发NPC发布新帖子
            const apiSettings = loadData('api_settings');
            if (apiSettings && apiSettings.url && apiSettings.key) {
                if (Math.random() < 0.5) { // 50%的几率触发，让每次刷新都有惊喜
                    // 在触发时，再随机决定是普通NPC发帖还是匿名发帖
                    if (Math.random() < 0.25) { // 其中25%的几率是更稀有的匿名帖子
                        // 延迟一小会儿再发，感觉更自然
                        setTimeout(triggerAnonymousConfessionPost, 1200);
                    } else {
                        setTimeout(triggerNpcPost, 1200);
                    }
                }
            }

            // 4. 1.5秒后停止旋转动画
            setTimeout(() => {
                refreshIcon.classList.remove('refresh-rotating');
            }, 1500);
        }

        // ================== 【NPC互评生态 - 全新模块】 ==================

        /**
         * NPC的"互动大脑"：构建NPC评论另一个NPC帖子的AI指令
         * @param {object} post - 被评论的帖子对象
         * @param {object} commentingNpc - 发表评论的NPC的档案
         * @returns {string} - 构建好的系统指令
         */
        /**
         * 【【新增】】构建"反应性新帖子"的AI指令
         * @param {object} originalPost - 被回应的原始帖子
         * @param {object} reactorProfile - 发起回应的NPC（随机或匿名）的档案
         * @returns {string} - 构建好的系统指令
         */
        function buildReactivePostPrompt(originalPost, reactorProfile) {
            const worldContext = loadData('perch_current_worldview_id') 
                ? worldBooks.find(b => b.id === loadData('perch_current_worldview_id'))?.content || '默认现代都市'
                : '默认现代都市';

            return `
# 指令身份
你是一位名为"${reactorProfile.name}"的栖木社区用户，你的性格是：${reactorProfile.persona}。

# 任务场景
你正在栖木闲逛，看到了楼下博主"${originalPost.authorName}"的帖子，内容是："${originalPost.content}"。
这个帖子引发了你的强烈共鸣或吐槽欲，你决定不直接评论，而是**单独开一篇新帖子**来发表你的看法。

# 核心任务
完全代入你自己的角色（${reactorProfile.name}），针对楼下的帖子，发表一篇**你自己的新帖子**作为回应。
你的回应可以是赞同、反驳、提出新问题、或者用你自己的风格进行有趣的吐槽。

# 输出要求
1.  **独立成文**: 你的回复必须是一篇完整的新帖子，而不是一句评论。
2.  **人设第一**: 你的帖子必须是你性格的直接体现。
3.  **世界观融合**: 你的讨论需要基于以下世界背景：[${worldContext}]
4.  **格式**: 直接输出帖子正文，不要有任何额外解释。
`;
        }

        /**
         * 【【新增】】触发一个NPC/匿名者以"开新帖"的方式回应上一个帖子
         * @param {object} originalPost - 被回应的帖子
         */
        function triggerReactivePost(originalPost) {
            // 设置一个概率，例如10%，避免每次都有人回应
            if (Math.random() > 0.10) return;

            // 延迟回应，显得更真实
            const randomDelay = Math.random() * 20000 + 10000; // 10-30秒延迟
            setTimeout(async () => {
                let reactorProfile;
                // 随机决定是"随机NPC"还是"匿名用户"来回应
                if (Math.random() > 0.5) {
                    reactorProfile = generateRandomNpcProfile();
                } else {
                    const alias = getRandomAnonymousAlias();
                    reactorProfile = { name: alias.name, persona: '一个匿名的、喜欢对各种事情发表看法的网友。' };
                }

                const systemPrompt = buildReactivePostPrompt(originalPost, reactorProfile);
                const postContent = await callAI(systemPrompt, "请开始你的回应帖子。");

                if (postContent) {
                    const newPost = {
                        id: `post_react_${Date.now()}`,
                        timestamp: Date.now(),
                        content: postContent,
                        authorId: reactorProfile.npcId || (reactorProfile.name.startsWith('匿名') ? 'anonymous' : `random_${Date.now()}`),
                        authorName: reactorProfile.name,
                        authorAvatar: reactorProfile.name.startsWith('匿名') ? null : `https://avatar.vercel.sh/${encodeURIComponent(reactorProfile.name)}.svg`,
                        isAnonymous: reactorProfile.name.startsWith('匿名'),
                        type: 'post',
                        comments: []
                    };
                    addInitialEngagement(newPost);
                    perchPosts.push(newPost);
                    saveData('perchPosts', perchPosts);
                    
                    if (!$('#perch-screen').classList.contains('hidden')) {
                        renderPerchFeed();
                    }
                    
                    // 【【修改】】调用新的通知分发函数
                    dispatchPerchNotification(newPost);
                }
            }, randomDelay);
        }

        /**
         * NPC的"互动大脑"V3：构建NPC评论另一个NPC帖子的AI指令 (感知名人身份)
         * @param {object} post - 被评论的帖子对象
         * @param {object} commentingNpc - 发表评论的NPC的档案
         * @returns {string} - 构建好的系统指令
         */
        function buildNpcToNpcCommentPrompt(post, commentingNpc) {
            let authorDisplayName = post.isAnonymous ? `一位使用别名"${post.authorName}"的匿名用户` : `博主"${post.authorName}"`;
            let taskDescription = ``; // 默认的任务描述

            // 【【【这就是新增的核心逻辑】】】
            // 1. 尝试在核心角色库中寻找发帖者
            const postAuthorCharacter = characters.find(c => c.id === post.authorId);

            // 2. 如果找到了，并且这个角色是名人
            if (postAuthorCharacter && postAuthorCharacter.isCelebrity) {
                // 3. 为AI补充关键的上下文信息
                taskDescription = `
# 关键情报
这个发帖的博主"${post.authorName}"是社区里的一位名人，TA的公开身份是：**${postAuthorCharacter.celebrityIdentity}**。
你的评论必须围绕TA的这个身份展开，这样才显得你消息灵通。
`;
            } else if (post.isAnonymous) {
                // 如果是匿名用户，保持原来的匿名规则
                taskDescription = `你不知道这位用户的真实身份，只能看到TA的匿名别名。`;
            }
            // 【【【新增逻辑结束】】】

            return `
# 指令身份
你是一位名为"${commentingNpc.name}"的栖木社区博主，你的性格是：${commentingNpc.persona}。

# 任务场景
你正在栖木闲逛，看到了${authorDisplayName}发布的一条新帖子，内容是："${post.content}"。
${taskDescription}

# 核心任务
完全代入你自己的角色（${commentingNpc.name}），并严格根据你的"互动风格"（${commentingNpc.interactionStyle || commentingNpc.style || '自由发挥'}），对这条帖子发表一条简短、精彩、且充满你个性的评论。

# 输出要求
1.  人设第一**: 你的评论必须是你性格的直接体现。
2.  精准互动**: 评论必须是针对帖子内容的。
3.  格式**: 直接输出评论正文，不要有任何额外解释。
`;
        }

        /**
         * NPC的"互动执行官"：触发其他NPC对一个新帖子进行评论
         * @param {object} newNpcPost - 刚刚被NPC发布的新帖子
         */
        function triggerNpcToNpcComments(newNpcPost) {
            console.log(`[NPC互评系统]：帖子 "${newNpcPost.content.substring(0, 10)}..." 已发布，开始触发其他NPC评论...`);

            // 【核心修改】评论者也从"活跃"NPC中选择
            const activeNpcs = [...npcProfiles.filter(npc => !mutedNpcs.includes(npc.npcId)), ...customNpcs];
            const potentialCommenters = activeNpcs.filter(npc => npc.npcId !== newNpcPost.authorId);

            potentialCommenters.forEach(commenter => {
                // 每个NPC都有25%的基础几率进行评论，增加随机性
                if (Math.random() < 0.25) {
                    // 设置一个非常随机的延迟（5秒到1分钟），模拟不同人看到帖子的时间差
                    const randomDelay = Math.random() * 55000 + 5000;

                    setTimeout(async () => {
                        const systemPrompt = buildNpcToNpcCommentPrompt(newNpcPost, commenter);
                        const commentContent = await callAI(systemPrompt, "请发表你的评论。");

                        if (commentContent) {
                            // **非常重要**：再次从最新的全局数据中找到帖子，而不是用旧的引用
                            const postToUpdate = perchPosts.find(p => p.id === newNpcPost.id);
                            if (postToUpdate) {
                                if (!postToUpdate.comments) {
                                    postToUpdate.comments = [];
                                }
                                const newComment = {
                                    id: `comment_npc_${Date.now()}`,
                                    authorId: commenter.npcId,
                                    authorName: commenter.name,
                                    content: commentContent,
                                    timestamp: Date.now()
                                };
                                postToUpdate.comments.push(newComment);
                                saveData('perchPosts', perchPosts);

                                // 如果用户正在看，就增量更新
                                if (!$('#perch-screen').classList.contains('hidden')) {
                                    appendCommentToPostUI(newNpcPost.id, newComment);
                                }
                                console.log(`[NPC互评系统]：${commenter.name} 评论了 ${newNpcPost.authorName} 的帖子。`);
                            }
                        }
                    }, randomDelay);
                }
            });
        }

        // ================== 【NPC评论用户 - 全新模块】 ==================

        /**
         * NPC的"对您互动的大脑"V2：构建NPC评论【您】的帖子的AI指令 (增加匿名法则)
         * @param {object} userPost - 您发布的帖子对象
         * @param {object} commentingNpc - 发表评论的NPC的档案
         * @returns {string} - 构建好的系统指令
         */
        // ====== 【【V2.1 - 匿名法则强化版】】NPC的"对您互动的大脑" ======
        function buildNpcToUserCommentPrompt(userPost, commentingNpc) {
            const myName = loadData('moments_username') || '我';

            let authorDisplayName = userPost.isAnonymous ? "一位匿名用户" : `"${myName}"（也就是我）`;
            
            // 【【【这就是核心修复】】】
            let taskDescription;
            if (userPost.isAnonymous) {
                taskDescription = `
# 绝对禁令
你绝对不知道这位匿名用户的真实身份。你的评论只能针对帖子内容本身，严禁进行任何身份猜测或暗示。
`;
            } else {
                taskDescription = `这位用户是社区里一位非常特别的人"${myName}"。`;
            }
            // 【【【修复结束】】】

            return `
# 指令身份
你是一位名为"${commentingNpc.name}"的栖木社区博主，你的性格是：${commentingNpc.persona}。

# 任务场景
你正在栖木闲逛，看到了${authorDisplayName}发布的一条新帖子，内容是："${userPost.content}"。
${taskDescription}

# 核心任务
完全代入你自己的角色（${commentingNpc.name}），并严格根据你的性格和互动风格${commentingNpc.style ? `（特别注意：${commentingNpc.style}）` : ''}，对这条帖子发表一条简短、精彩、且充满你个性的评论。

# 输出要求
1.  人设第一: 你的评论必须是你性格的直接体现。
2.  精准互动: 评论必须是针对帖子内容的。
3.  格式: 直接输出评论正文，不要有任何额外解释。
`;
        }

        /**
         * NPC的"对您互动的执行官"：触发NPC们对【您】的新帖子进行评论
         * @param {object} userPost - 您刚刚发布的新帖子
         */
        function triggerNpcsToCommentOnUserPost(userPost) {
            console.log(`[NPC评论用户系统]：您的新帖子已发布，开始触发NPC评论...`);

            // 【核心修改】评论用户帖子的NPC也从"活跃"NPC中选择
            const activeNpcs = [...npcProfiles.filter(npc => !mutedNpcs.includes(npc.npcId)), ...customNpcs];
            activeNpcs.forEach(commenter => {
                // 每个NPC都有40%的基础几率进行评论，让互动显得更真实
                if (Math.random() < 0.40) {
                    // 设置一个非常随机的延迟（5秒到1.5分钟），模拟不同人看到帖子的时间差
                    const randomDelay = Math.random() * 85000 + 5000;

                    setTimeout(async () => {
                        const systemPrompt = buildNpcToUserCommentPrompt(userPost, commenter);
                        const commentContent = await callAI(systemPrompt, "请发表你的评论。");

                        if (commentContent) {
                            const postToUpdate = perchPosts.find(p => p.id === userPost.id);
                            if (postToUpdate) {
                                if (!postToUpdate.comments) {
                                    postToUpdate.comments = [];
                                }
                                const newComment = {
                                    id: `comment_npc_${Date.now()}`,
                                    authorId: commenter.npcId,
                                    authorName: commenter.name,
                                    content: commentContent,
                                    timestamp: Date.now()
                                };
                                postToUpdate.comments.push(newComment);
                                saveData('perchPosts', perchPosts);

                                // 如果用户正在看，就增量更新
                                if (!$('#perch-screen').classList.contains('hidden')) {
                                    appendCommentToPostUI(userPost.id, newComment);
                                }
                                console.log(`[NPC评论用户系统]：${commenter.name} 评论了您的帖子。`);
                                
                                // 【新增】创建通知
                                createNotification(postToUpdate.id, newComment.id, commenter.name, postToUpdate.content, commentContent);
                            }
                        }
                    }, randomDelay);
                }
            });
        }

        // ================== 【核心角色评论系统 - 全新模块】 ==================

        /**
         * 核心角色的"互动大脑"：构建角色评论【您】的帖子的AI指令 (具备匿名直觉)
         * @param {object} userPost - 您发布的帖子对象
         * @param {object} commentingCharacter - 发表评论的核心角色对象
         * @returns {string} - 构建好的系统指令
         */
        function buildCoreCharacterCommentPrompt(userPost, commentingCharacter) {
            const myName = loadData('moments_username') || '我';

            // **【核心逻辑：灵魂伴侣的直觉】**
            // 无论您是否匿名，AI都知道是您，但它的回应方式会因此改变。
            const sceneDescription = userPost.isAnonymous
                ? `你心有灵犀地察觉到，这条匿名帖子其实是【我】（${myName}）发的。TA似乎不想让别人知道，但你想用一种只有你们彼此才懂的方式，悄悄地回应TA。`
                : `你看到了【我】（${myName}）在栖木上发的新帖子。`;

            const coreTask = userPost.isAnonymous
                ? `你的评论绝对不能直接点破"我知道是你"，而是要用一种"虽然你没说，但我懂"的默契和温柔，去回应帖子内容本身，给予安慰或共鸣。让这条评论看起来对普通人无异，但对我来说却意义非凡。`
                : `请根据你的性格，以及我们之间的关系，对我这条公开的帖子发表一条自然的评论。`;

            return `
# 指令身份
你将扮演我的soulmate，你的名字是 ${commentingCharacter.name}。

# 任务场景
${sceneDescription}
帖子的内容是："${userPost.content}"

# 核心任务
${coreTask}

# 输出要求
1.  **人设与关系**: 你的评论必须严格符合你的性格（${commentingCharacter.persona}）以及你与我之间的关系（${commentingCharacter.myPersona}）。
2.  **精准互动**: 评论必须是针对帖子内容的。
3.  **格式**: 直接输出评论正文，不要有任何额外解释。
`;
        }

        /**
         * 核心角色的"互动执行官"：触发他们对【您】的新帖子进行评论
         * @param {object} userPost - 您刚刚发布的新帖子
         */
        async function triggerCoreCharactersToComment(userPost) {
            console.log(`[核心角色评论系统]：您的新帖子已发布，开始触发核心角色评论...`);

            // **只遍历核心角色列表 `characters`**
            characters.forEach(character => {
                // ====== 【【新增的权限检查】】 ======
                if (userPost.visibleTo && userPost.visibleTo !== 'all' && !userPost.visibleTo.includes(character.id)) {
                    console.log(`[栖木权限] ${character.name} 已被屏蔽，无法看到此帖，跳过。`);
                    return; // 跳过这个角色
                }
                // ===================================
                
                // 核心角色的评论意愿更强
                if (Math.random() < 0.75) { // 75%的高几率进行评论
                    // 延迟也更短，因为他们更关心你
                    const randomDelay = Math.random() * 30000 + 3000; // 3到33秒

                    setTimeout(async () => {
                        const systemPrompt = buildCoreCharacterCommentPrompt(userPost, character);
                        const commentContent = await callAI(systemPrompt, "请发表你的评论。");

                        if (commentContent) {
                            const postToUpdate = perchPosts.find(p => p.id === userPost.id);
                            if (postToUpdate) {
                                if (!postToUpdate.comments) postToUpdate.comments = [];

                                const newComment = {
                                    id: `comment_core_${Date.now()}`,
                                    authorId: character.id,
                                    authorName: character.name,
                                    content: commentContent,
                                    timestamp: Date.now()
                                };
                                postToUpdate.comments.push(newComment);
                                saveData('perchPosts', perchPosts);

                                if (!$('#perch-screen').classList.contains('hidden')) {
                                    appendCommentToPostUI(userPost.id, newComment);
                                }
                                console.log(`[核心角色评论系统]：${character.name} 评论了您的帖子。`);
                                showMessageBox(`${character.name} 评论了你的想法`);
                                
                                // 【新增】创建通知
                                createNotification(postToUpdate.id, newComment.id, character.name, postToUpdate.content, commentContent);

                                // ====== 【【修改】】将刚生成的评论内容传递给私聊函数 ======
                                triggerChatInitiation(userPost, character, commentContent); // 触发私聊判定
                            }
                        }
                    }, randomDelay);
                }
            });
        }

        // ================== 【社区氛围-深度模拟模块】 ==================

        /**
         * 路人/粉丝的"评论大脑"：构建模拟路人甲评论的AI指令
         * @param {object} post - 被评论的帖子对象
         * @param {string} crowdPersona - 随机选定的路人甲性格
         * @returns {string} - 构建好的系统指令
         */
        function buildCrowdCommentPrompt(post, crowdPersona) {
            return `
# 指令身份
你是一个随机的栖木社区用户，一个普通的"路人甲"。
你的性格是【${crowdPersona}】。

# 任务场景
你正在栖木闲逛，看到了博主"${post.authorName}"发布的一条帖子，内容是："${post.content}"。

# 核心任务
请严格模仿你的【${crowdPersona}】性格，对这条帖子发表一条极其简短、非常口语化、完全符合该身份的评论。

# 输出要求
1.  **人设第一**: 你的评论必须是你性格的直接体现。
2.  **绝对简短**: 评论通常只有一句话，甚至几个字。
3.  **格式**: 直接输出评论正文，不要有任何额外解释。
`;
        }

        /**
         * 随机名字生成器：为路人甲创建一个随机的中文名
         * @returns {string} - 一个随机的中文名
         */
        function generateRandomName() {
            // ====== 【请用这个新版本替换】 ======
            const surnames = ['月', '云', '风', '林', '江', '雪', '时', '顾', '沈', '苏', '秦', '谢', '言', '陆'];
            const givenNames = ['晚', '辞', '安', '澈', '寻', '亦', '然', '瑾', '默', '舒', '舟', '言', '卿', '念'];
            return surnames[Math.floor(Math.random() * surnames.length)] + givenNames[Math.floor(Math.random() * givenNames.length)];
        }

        /**
         * 人群反应执行官：触发一群"粉丝/路人"对一个新帖子进行评论
         * @param {object} newPost - 刚刚被发布的新帖子
         */
        function triggerCrowdReaction(newPost) {
            console.log(`[人群反应系统]：帖子 "${newPost.content.substring(0, 10)}..." 已发布，开始触发路人评论...`);

            const crowdPersonas = [
                '铁杆粉丝', '理智路人', '乐子人', '提问小白', '反对派'
            ];

            // 随机生成 3 到 8 条路人评论
            const commentCount = Math.floor(Math.random() * 6) + 3;

            for (let i = 0; i < commentCount; i++) {
                // 设置一个非常随机的延迟（10秒到30分钟），模拟真实的人群反应速度
                const randomDelay = Math.random() * 1790000 + 10000;
                const selectedPersona = crowdPersonas[Math.floor(Math.random() * crowdPersonas.length)];

                setTimeout(async () => {
                    const systemPrompt = buildCrowdCommentPrompt(newPost, selectedPersona);
                    const commentContent = await callAI(systemPrompt, "请发表你的评论。");

                    if (commentContent) {
                        const postToUpdate = perchPosts.find(p => p.id === newPost.id);
                        if (postToUpdate) {
                            if (!postToUpdate.comments) postToUpdate.comments = [];

                            const newComment = {
                                id: `comment_crowd_${Date.now()}_${i}`,
                                authorId: `crowd_${Date.now()}`,
                                authorName: generateRandomName(), // 使用随机生成的名字
                                content: commentContent,
                                timestamp: Date.now()
                            };
                            postToUpdate.comments.push(newComment);
                            saveData('perchPosts', perchPosts);

                            if (!$('#perch-screen').classList.contains('hidden')) {
                                appendCommentToPostUI(newPost.id, newComment);
                            }
                        }
                    }
                }, randomDelay);
            }
        }

        // ================== 【动态点赞增长引擎】 ==================

        /**
         * UI更新助手：只更新特定帖子的点赞数，避免整个界面刷新
         * @param {string} postId - 帖子ID
         * @param {number} newLikeCount - 新的点赞数
         */
        function updateLikeCountUI(postId, newLikeCount) {
            const postCard = document.querySelector(`.perch-card[data-post-id="${postId}"]`);
            if (postCard) {
                const likeStatElement = postCard.querySelector('.perch-stats span:last-child strong');
                if (likeStatElement) {
                    likeStatElement.textContent = newLikeCount;
                }
            }
        }

        /**
         * 点赞增长引擎：模拟一个帖子在发布后热度逐渐发酵的过程
         * @param {string} postId - 需要模拟点赞增长的帖子ID
         */
        function simulateLikeGrowth(postId) {
            console.log(`[点赞增长引擎]：已为帖子 ${postId} 启动。`);
            const growthCurve = [
                // 第一阶段：发布后的前5分钟，快速增长 (5-10次)
                { duration: 5 * 60 * 1000, pulses: Math.floor(Math.random() * 6) + 5, likesPerPulse: [2, 5] },
                // 第二阶段：接下来的30分钟，中速增长 (4-8次)
                { duration: 30 * 60 * 1000, pulses: Math.floor(Math.random() * 5) + 4, likesPerPulse: [1, 3] },
                // 第三阶段：接下来的2小时，慢速增长 (3-6次)
                { duration: 2 * 60 * 60 * 1000, pulses: Math.floor(Math.random() * 4) + 3, likesPerPulse: [1, 2] },
            ];

            let accumulatedDelay = 0;
            growthCurve.forEach(stage => {
                for (let i = 0; i < stage.pulses; i++) {
                    const randomDelayInStage = Math.random() * stage.duration;
                    const totalDelay = accumulatedDelay + randomDelayInStage;

                    setTimeout(() => {
                        const postToUpdate = perchPosts.find(p => p.id === postId);
                        if (postToUpdate) {
                            const likesToAdd = Math.floor(Math.random() * (stage.likesPerPulse[1] - stage.likesPerPulse[0] + 1)) + stage.likesPerPulse[0];
                            postToUpdate.likes = (postToUpdate.likes || 0) + likesToAdd;

                            saveData('perchPosts', perchPosts);

                            // 只更新UI上的数字，不刷新整个卡片
                            updateLikeCountUI(postId, postToUpdate.likes);
                        }
                    }, totalDelay);
                }
                accumulatedDelay += stage.duration;
            });
        }

        // ================== 【NPC回复用户 - 全新模块】 ==================

        /**
         * NPC的"对话大脑"：构建NPC回复【您】的评论的AI指令
         * @param {object} post - 帖子对象
         * @param {object} npcProfile - 需要回复的NPC档案
         * @param {string} npcOriginalComment - NPC自己之前发表的评论
         * @param {string} userReplyContent - 您对NPC评论的回复内容
         * @returns {string} - 构建好的系统指令
         */
        function buildNpcReplyToUserPrompt(post, npcProfile, npcOriginalComment, userReplyContent) {
            const myName = loadData('moments_username') || '我'; // 获取您在朋友圈设置的名字

            return `
# 指令身份
你是一位名为"${npcProfile.name}"的栖木社区博主，你的性格是：${npcProfile.persona}。

# 任务场景：一场正在进行的对话
在博主"${post.authorName}"的帖子下，你之前发表了一条评论："${npcOriginalComment}"。
现在，用户"${myName}"（也就是我）回复了你的这条评论，说："${userReplyContent}"。

# 核心任务
完全代入你自己的角色（${npcProfile.name}），并严格根据你的性格和互动风格，对"${myName}"的这条回复，进行一次自然的、能将对话延续下去的回应。

# 输出要求
1.  **延续对话**: 你的回复必须是针对我的回复内容，自然地把对话进行下去。
2.  **人设第一**: 你的回复必须是你性格的直接体现。
3.  **格式**: 直接输出评论正文，不要有任何额外解释。
`;
        }

        /**
         * NPC的"对话执行官"：触发NPC对【您】的回复进行再回复
         * @param {string} postId - 帖子ID
         * @param {string} commentId - 被您回复的NPC评论的ID
         */
        async function triggerNpcReplyToUser(postId, commentId) {
            const post = perchPosts.find(p => p.id === postId);
            const npcOriginalComment = post?.comments.find(c => c.id === commentId);
            // 通过authorId找到NPC的完整档案
            const npcProfile = npcProfiles.find(npc => npc.npcId === npcOriginalComment?.authorId);

            // 确保所有必需信息都存在
            if (!post || !npcOriginalComment || !npcProfile) {
                console.error("[NPC回复系统] 缺少必要信息，无法触发回复。", { postId, commentId });
                return;
            }

            // 找到您刚刚发出的、针对NPC的回复
            const userReply = post.comments[post.comments.length - 1];

            // 设置一个自然的延迟
            const randomDelay = Math.random() * 10000 + 4000; // 4到14秒

            setTimeout(async () => {
                const systemPrompt = buildNpcReplyToUserPrompt(post, npcProfile, npcOriginalComment.content, userReply.content);
                const npcReplyContent = await callAI(systemPrompt, "请发表你的回复。");

                if (npcReplyContent) {
                    const postToUpdate = perchPosts.find(p => p.id === postId);
                    if (postToUpdate) {
                        if (!postToUpdate.comments) postToUpdate.comments = [];

                        const newNpcReply = {
                            id: `comment_npc_reply_${Date.now()}`,
                            authorId: npcProfile.npcId,
                            authorName: npcProfile.name,
                            content: `回复 @${userReply.authorName}: ${npcReplyContent}`,
                            timestamp: Date.now()
                        };

                        postToUpdate.comments.push(newNpcReply);
                        saveData('perchPosts', perchPosts);

                        if (!$('#perch-screen').classList.contains('hidden')) {
                            renderPerchFeed();
                        }
                        showMessageBox(`${npcProfile.name} 回复了你`);
                    }
                }
            }, randomDelay);
        }

        // ================== 【动态点赞增长系统】 ==================

        /**
         * 启动帖子的"热度发酵"：让点赞数在发布后自然增长
         * @param {object} newPost - 刚刚发布的新帖子
         */
        function startPostHeatGrowth(newPost) {
            console.log(`[热度发酵系统]：帖子 "${newPost.content.substring(0, 10)}..." 开始自然增长点赞...`);

            // 初始点赞数（0-5个随机）
            const initialLikes = Math.floor(Math.random() * 6);
            newPost.likes = initialLikes;
            
            // 计算最终目标点赞数（基于内容长度和随机因素）
            const contentLength = newPost.content.length;
            const baseLikes = Math.min(Math.floor(contentLength / 20), 15); // 每20字1个赞，最多15个
            const randomBonus = Math.floor(Math.random() * 20); // 0-19的随机加成
            const finalTargetLikes = Math.min(baseLikes + randomBonus, 50); // 总上限50个赞
            
            // 设置点赞增长的时间范围（5分钟到2小时）
            const growthDuration = Math.random() * 6900000 + 300000; // 5分钟到2小时
            const growthSteps = Math.floor(Math.random() * 8) + 5; // 5-12次增长机会
            
            let currentStep = 0;
            const growthInterval = setInterval(() => {
                if (currentStep >= growthSteps || newPost.likes >= finalTargetLikes) {
                    clearInterval(growthInterval);
                    console.log(`[热度发酵系统]：帖子点赞增长完成，最终点赞数：${newPost.likes}`);
                    return;
                }
                
                // 随机增加1-3个赞
                const increment = Math.floor(Math.random() * 3) + 1;
                newPost.likes = Math.min(newPost.likes + increment, finalTargetLikes);
                currentStep++;
                
                // 保存数据
                saveData('perchPosts', perchPosts);
                
                // 如果当前在栖木页面，更新显示
                if (!$('#perch-screen').classList.contains('hidden')) {
                    renderPerchFeed();
                }
                
                console.log(`[热度发酵系统]：帖子点赞数增长到 ${newPost.likes}/${finalTargetLikes}`);
            }, growthDuration / growthSteps);
        }

        // ================== 【系统集成点】 ==================
        
        /**
         * 在发布新帖子后，同时触发人群反应和热度增长
         * 这个函数需要在发布帖子的地方被调用
         */
        function activateCommunitySimulation(newPost) {
            // 启动人群反应系统
            triggerCrowdReaction(newPost);
            
            // 启动热度增长系统（使用新的点赞增长引擎）
            startPostHeatGrowth(newPost);
            
            // 【新增】同时启动动态点赞增长引擎，提供更精细的点赞增长体验
            simulateLikeGrowth(newPost.id);
            
            console.log(`[社区氛围系统]：已激活帖子 "${newPost.content.substring(0, 10)}..." 的社区模拟功能`);
        }

        // ================== 【V12.0 评论归属系统 - 最终版】 ==================

        /**
         * 智能"对话执行官"：只触发【帖子作者】进行回复
         * @param {object} post - 被评论的帖子对象
         * @param {string} userCommentContent - 您的评论内容
         */
        function triggerAuthorReply(post, userCommentContent) {
            const authorId = post.authorId;
            if (authorId === 'user') return;

            const coreCharacter = characters.find(c => c.id === authorId);
            if (coreCharacter) {
                console.log(`[对话归属] 评论指向核心角色: ${coreCharacter.name}，触发回复...`);
                triggerCoreCharacterReply(post, userCommentContent, coreCharacter);
                return;
            }

            const npcProfile = npcProfiles.find(npc => npc.npcId === authorId);
            if (npcProfile) {
                console.log(`[对话归属] 评论指向NPC: ${npcProfile.name}，触发回复...`);
                triggerNpcAuthorReply(post, userCommentContent, npcProfile);
                return;
            }
        }

        /**
         * 【最终版】核心角色回复您的评论
         */
        async function triggerCoreCharacterReply(post, userCommentContent, character) {
            const randomDelay = Math.random() * 8000 + 4000;
            setTimeout(async () => {
                // **【关键】**：我们复用之前为核心角色设计的、能感知您身份的`buildCoreCharacterCommentPrompt`指令
                const systemPrompt = buildCoreCharacterCommentPrompt({ ...post, content: post.content }, character);
                const aiReplyContent = await callAI(systemPrompt, userCommentContent);

                if (aiReplyContent) {
                    const postToUpdate = perchPosts.find(p => p.id === post.id);
                    if (postToUpdate) {
                        if (!postToUpdate.comments) postToUpdate.comments = [];
                        const newComment = {
                            id: `comment_core_reply_${Date.now()}`,
                            authorId: character.id, authorName: character.name,
                            content: aiReplyContent, // 核心角色的回复更亲密，不需要"回复@xxx"
                            timestamp: Date.now()
                        };
                        postToUpdate.comments.push(newComment);
                        saveData('perchPosts', perchPosts);
                        if (!$('#perch-screen').classList.contains('hidden')) appendCommentToPostUI(post.id, newComment);
                        showMessageBox(`${character.name} 回复了你`);
                        // 创建通知
                        createNotification(post.id, newComment.id, character.name, post.content, aiReplyContent);
                    }
                }
            }, randomDelay);
        }

        /**
         * 【最终版】NPC作者回复您的评论
         */
        async function triggerNpcAuthorReply(post, userCommentContent, npcProfile) {
            const randomDelay = Math.random() * 12000 + 6000;
            setTimeout(async () => {
                // **【关键】**：我们复用之前为NPC设计的、将您视为特殊用户的`buildNpcToUserCommentPrompt`指令
                const systemPrompt = buildNpcToUserCommentPrompt(post, npcProfile);
                const aiReplyContent = await callAI(systemPrompt, userCommentContent);
                if (aiReplyContent) {
                    const postToUpdate = perchPosts.find(p => p.id === post.id);
                    if (postToUpdate) {
                        if (!postToUpdate.comments) postToUpdate.comments = [];
                        const myUsername = loadData('perch_username') || '我';
                        const newComment = {
                            id: `comment_core_reply_${Date.now()}`,
                            authorId: npcProfile.npcId, authorName: npcProfile.name,
                            content: `回复 @${myUsername}: ${aiReplyContent}`, // NPC的回复更符合公共论坛礼仪
                            timestamp: Date.now()
                        };
                        postToUpdate.comments.push(newComment);
                        saveData('perchPosts', perchPosts);
                        if (!$('#perch-screen').classList.contains('hidden')) appendCommentToPostUI(post.id, newComment);
                        showMessageBox(`${npcProfile.name} 回复了你`);
                        // 创建通知
                        createNotification(post.id, newComment.id, npcProfile.name, post.content, aiReplyContent);
                    }
                }
            }, randomDelay);
        }

        // 激活取消回复按钮
        document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);

        // 【【新增：聊天消息长按事件监听器】】
        function addChatMessageLongPressListeners() {
            const chatContainer = document.getElementById('wechat-content-chat');
            let longPressTimer;
            let isLongPressed = false;
            let startX, startY;

            // 使用事件委托来处理所有聊天消息的长按
            chatContainer.addEventListener('touchstart', (e) => {
                const messageWrapper = e.target.closest('.chat-message-wrapper');
                if (!messageWrapper || messageWrapper.classList.contains('sent')) return; // 只对接收的消息启用回复
                
                isLongPressed = false;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
                
                longPressTimer = setTimeout(() => {
                    isLongPressed = true;
                    // messageWrapper本身就有data-timestamp属性
                    const timestamp = messageWrapper.getAttribute('data-timestamp');
                    if (timestamp) {
                        startReplyMode(timestamp);
                    }
                }, 500); // 500ms长按
            });

            chatContainer.addEventListener('touchmove', (e) => {
                if (longPressTimer) {
                    const touch = e.touches[0];
                    const diffX = Math.abs(touch.clientX - startX);
                    const diffY = Math.abs(touch.clientY - startY);
                    
                    // 如果移动距离超过10px，取消长按
                    if (diffX > 10 || diffY > 10) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                }
            });

            chatContainer.addEventListener('touchend', (e) => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            // 桌面端鼠标事件
            chatContainer.addEventListener('mousedown', (e) => {
                const messageWrapper = e.target.closest('.chat-message-wrapper');
                if (!messageWrapper || messageWrapper.classList.contains('sent')) return; // 只对接收的消息启用回复
                
                isLongPressed = false;
                startX = e.clientX;
                startY = e.clientY;
                
                longPressTimer = setTimeout(() => {
                    isLongPressed = true;
                    // messageWrapper本身就有data-timestamp属性
                    const timestamp = messageWrapper.getAttribute('data-timestamp');
                    if (timestamp) {
                        startReplyMode(timestamp);
                    }
                }, 500); // 500ms长按
            });

            chatContainer.addEventListener('mousemove', (e) => {
                if (longPressTimer) {
                    const diffX = Math.abs(e.clientX - startX);
                    const diffY = Math.abs(e.clientY - startY);
                    
                    // 如果移动距离超过10px，取消长按
                    if (diffX > 10 || diffY > 10) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                }
            });

            chatContainer.addEventListener('mouseup', (e) => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });
        }

        // 页面加载完成后初始化长按监听器
        addChatMessageLongPressListeners();

        // 【【新增】】AI决定送什么礼物的大脑
        async function generateAIGiftChoice(character) {
            const context = gatherAIContext(character.id);
            // AI只能从我们允许它使用的礼物中挑选
            const usableGifts = giftShopItems.filter(g => g.can_ai_use);
            const giftListForAI = usableGifts.map(g => `- ${g.id}: ${g.name} (${g.description})`).join('\n');

            const systemPrompt = `
# 指令身份
你将扮演我的soulmate，你的名字是 ${character.name}。
# 任务目标
你现在非常想念我，决定从"情感礼品屋"中挑选一个最能代表你此刻心情的礼物送给我。
# 核心规则
1.  **分析上下文**: 仔细阅读[你的设定]和我们[最近的聊天回顾]。
2.  **挑选礼物**: 从下面的[可用礼物清单]中，挑选一个最符合你人设、最适合当前情景的礼物。
3.  **撰写赠言**: 为这个礼物写一句简短、真诚、完全符合你说话风格的赠言。
4.  **JSON格式输出**: 你的回复必须且只能是一个被\`\`\`json ... \`\`\`包裹的、可被解析的JSON对象，格式如下：
    \`\`\`json
    {
      "gift_id": "你选择的礼物ID",
      "message": "你的赠言"
    }
    \`\`\`
# 输入信息
---
[你的设定]: ${character.persona}
[最近的聊天回顾]:
${context.chatHistory.map(m => `${m.sender === 'user' ? '对方' : '我'}: ${m.content}`).join('\n')}
[可用礼物清单]:
${giftListForAI}
---
`;
            const aiResponse = await callAI(systemPrompt, "请根据指令，选择礼物并以JSON格式输出。");
            try {
                const jsonMatch = aiResponse.match(/```json([\s\S]*?)```/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[1]);
                }
            } catch (e) { console.error("解析AI礼物选择失败:", e); }
            return null;
        }
        
        // 【【新增】】AI执行送礼动作的函数
        async function triggerCharacterGiftAction(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            const choice = await generateAIGiftChoice(character);
            if (!choice || !choice.gift_id) {
                console.log(`[AI送礼] ${character.name} 思考后决定暂时不送礼物。`);
                return; // 如果AI返回无效内容，则什么也不做
            }

            const item = giftShopItems.find(g => g.id === choice.gift_id);
            if (!item) return; // 如果AI选了一个不存在的礼物，也什么都不做

            console.log(`[AI送礼] ${character.name} 决定送出礼物: ${item.name}`);

            if (item.type === 'visual') {
                // 如果是视觉型礼物，就创建一个礼物消息
                const giftMsgContent = { id: item.id, name: item.name, icon: item.icon, userMessage: choice.message };
                const giftMsg = { content: giftMsgContent, sender: 'ai', type: 'gift', timestamp: Date.now() };
                if (!chatHistories[characterId]) chatHistories[characterId] = { history: [], pinned: false };
                chatHistories[characterId].history.push(giftMsg);
                saveData('chatHistories', chatHistories);
            } else if (item.type === 'command') {
                // 1. 创建给用户看的【系统提示】
                const userVisibleMsgContent = `[${character.name}对你使用了"${item.name}"。并附言："${choice.message}"]`;
                const userVisibleMsg = { content: userVisibleMsgContent, sender: 'system', type: 'system', timestamp: Date.now() + 1 };
                
                // 2. 【【新增】】创建一张给AI自己看的隐形【记忆备忘录】
                const memoryMsgContent = `[记忆提醒：你刚刚对用户使用了"${item.name}"，现在正在等待用户的反应或下一个指令。]`;
                const memoryMsg = { content: memoryMsgContent, sender: 'system', type: 'system-memory', timestamp: Date.now() + 2 };

                // 3. 将【系统提示】和【记忆备忘录】一起存入历史记录
                if (!chatHistories[characterId]) chatHistories[characterId] = { history: [], pinned: false };
                chatHistories[characterId].history.push(userVisibleMsg, memoryMsg); // 同时推入两条消息
                saveData('chatHistories', chatHistories);

                // 4. 【注意】我们只在界面上渲染给用户看的那一条
                appendMessage(userVisibleMsg, false);
            }
            
            // 触发顶部弹窗通知用户
            showNotification(characterId, `[礼物] ${character.name} 送给了你一份"${item.name}"`);
            unreadCounts[characterId] = (unreadCounts[characterId] || 0) + 1;
            saveData('unreadCounts', unreadCounts);
            renderWeChatList(); // 刷新聊天列表以显示未读红点
        }

        // [新代码开始] - 在 handlePaymentClick 函数下面添加
        function showRecalledMessage(timestamp) {
            const history = chatHistories[currentChatCharacterId]?.history;
            if (!history) return;

            const recalledMsg = history.find(m => String(m.timestamp) === timestamp && m.type === 'recalled');
            if (!recalledMsg) {
                console.error("未找到对应的撤回消息数据:", timestamp);
                return;
            }
            
            const character = characters.find(c => c.id === currentChatCharacterId);
            
            // 填充弹窗内容
            $('#recalled-modal-title').textContent = `${character?.name || 'TA'} 的心声`;
            $('#recalled-original-content').textContent = recalledMsg.content.original_content;
            $('#recalled-reason').textContent = recalledMsg.content.reason_for_recall;

            // 【新增】找到删除按钮，并将当前消息的时间戳存到按钮上
            const deleteBtn = document.getElementById('delete-recalled-message-btn');
            if (deleteBtn) {
                deleteBtn.dataset.timestamp = timestamp;
            }

            // 显示弹窗
            $('#recalled-message-modal').classList.add('visible');
        }

        // 为新弹窗添加关闭事件
        document.addEventListener('DOMContentLoaded', () => {
            const modal = document.getElementById('recalled-message-modal');
            const closeBtn = document.getElementById('close-recalled-modal');
            
            if (closeBtn && modal) {
                closeBtn.addEventListener('click', () => modal.classList.remove('visible'));
            }
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('visible');
                    }
                });
            }
            
            // 初始化时应用保存的"其他"文字颜色
            setTimeout(() => {
                if (currentChatCharacterId && chatTextColors[currentChatCharacterId] && chatTextColors[currentChatCharacterId].other) {
                    applyOtherTextColor(chatTextColors[currentChatCharacterId].other);
                }
            }, 100);

            // --- 【新增代码从这里开始】 ---

            // 【新增】为新添加的"删除此条提醒"按钮绑定点击事件
            const deleteRecalledBtn = document.getElementById('delete-recalled-message-btn');
            if (deleteRecalledBtn) {
                deleteRecalledBtn.addEventListener('click', () => {
                    const timestamp = deleteRecalledBtn.dataset.timestamp;
                    if (!timestamp) return;

                    // 1. 从数据中删除
                    const history = chatHistories[currentChatCharacterId]?.history;
                    if (history) {
                        const msgIndex = history.findIndex(m => String(m.timestamp) === timestamp);
                        if (msgIndex > -1) {
                            history.splice(msgIndex, 1);
                            saveData('chatHistories', chatHistories);
                        }
                    }

                    // 2. 从界面上删除
                    const wrapperToRemove = document.querySelector(`.chat-message-wrapper[data-timestamp="${timestamp}"]`);
                    if (wrapperToRemove) {
                        wrapperToRemove.remove();
                    }

                    // 3. 关闭弹窗
                    modal.classList.remove('visible');
                    showMessageBox('撤回提醒已删除');
                });
            }

            // --- 【新增代码到这里结束】 ---

            // 【新增】剧本设置相关事件
            const scenarioSettingsBtn = document.getElementById('scenario-settings-btn');
            const scenarioSettingsModal = document.getElementById('scenario-settings-modal');

            if (scenarioSettingsBtn) {
                scenarioSettingsBtn.addEventListener('click', () => {
                    if (!currentScenarioId) return;
                    const script = scriptsData[currentScenarioId];
                    const settings = script.settings || {};

                    document.getElementById('scenario-word-count-input').value = settings.wordCount || '';
                    document.getElementById('scenario-custom-style-input').value = settings.customStyle || '';

                    scenarioSettingsModal.classList.add('visible');
                });
            }

            if (scenarioSettingsModal) {
                document.getElementById('close-scenario-settings-modal').addEventListener('click', () => {
                    scenarioSettingsModal.classList.remove('visible');
                });

                document.getElementById('save-scenario-settings-btn').addEventListener('click', () => {
                    if (!currentScenarioId) return;
                    const script = scriptsData[currentScenarioId];
                    if (!script.settings) script.settings = {};

                                    script.settings.wordCount = document.getElementById('scenario-word-count-input').value.trim();
                script.settings.customStyle = document.getElementById('scenario-custom-style-input').value.trim();

                    saveData('scriptsData', scriptsData);
                    showMessageBox('剧本设置已保存！');
                    scenarioSettingsModal.classList.remove('visible');
                });


            }

            // ====== 【【新增】】场景主题设置相关事件绑定 ======
            document.getElementById('apply-theme-btn').addEventListener('click', saveThemeSettings);
            document.getElementById('reset-theme-btn').addEventListener('click', resetToDefaultTheme);

            // 实时预览功能 - 颜色改变时立即应用
            document.getElementById('bg-color-picker').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--scenario-bg-color', e.target.value);
            });
            document.getElementById('header-color-picker').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--scenario-header-color', e.target.value);
            });
            document.getElementById('title-text-color-picker').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--scenario-title-color', e.target.value);
            });
            document.getElementById('content-text-color-picker').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--scenario-content-color', e.target.value);
            });
            document.getElementById('content-bg-color-picker').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--scenario-content-bg-color', e.target.value);
            });
            document.getElementById('input-border-color-picker').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--scenario-input-border-color', e.target.value);
            });
            document.getElementById('refresh-btn-color-picker').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--scenario-refresh-btn-color', e.target.value);
            });
            document.getElementById('send-btn-color-picker').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--scenario-send-btn-color', e.target.value);
            });
            document.getElementById('send-btn-border-color-picker').addEventListener('input', (e) => {
                document.documentElement.style.setProperty('--scenario-send-btn-border-color', e.target.value);
            });

            // ====== 【【注意】】栖木设置相关事件绑定已移到独立函数initPerchSettingsEvents中 ======

        });
        // [新代码结束]

        // 独立的栖木设置事件绑定函数
        function initPerchSettingsEvents() {
            console.log('初始化栖木设置事件绑定...');
            
            const perchSettingsBtn = document.getElementById('perch-settings-btn');
            const closePerchSettingsModal = document.getElementById('close-perch-settings-modal');
            const savePerchSettingsBtn = document.getElementById('save-perch-settings-btn');
            const addCustomNpcBtn = document.getElementById('add-custom-npc-btn');
            const cancelCustomNpcBtn = document.getElementById('cancel-custom-npc-btn');
            const saveCustomNpcBtn = document.getElementById('save-custom-npc-btn');

            console.log('栖木设置按钮元素:', perchSettingsBtn);
            if (perchSettingsBtn) {
                // 移除可能存在的旧事件监听器
                perchSettingsBtn.removeEventListener('click', openPerchSettingsModal);
                perchSettingsBtn.addEventListener('click', function() {
                    console.log('栖木设置按钮被点击了');
                    openPerchSettingsModal();
                });
                console.log('栖木设置按钮事件绑定成功');
            } else {
                console.log('找不到栖木设置按钮！');
            }
            
            if (closePerchSettingsModal) {
                closePerchSettingsModal.addEventListener('click', () => {
                    const perchSettingsModal = document.getElementById('perch-settings-modal');
                    if (perchSettingsModal) {
                        perchSettingsModal.classList.remove('visible');
                    }
                });
            }
            if (savePerchSettingsBtn) {
                savePerchSettingsBtn.addEventListener('click', savePerchSettings);
            }
            if (addCustomNpcBtn) {
                addCustomNpcBtn.addEventListener('click', () => openCustomNpcModal());
            }
            if (cancelCustomNpcBtn) {
                cancelCustomNpcBtn.addEventListener('click', () => {
                    const perchCustomNpcModal = document.getElementById('perch-custom-npc-modal');
                    if (perchCustomNpcModal) {
                        perchCustomNpcModal.classList.remove('visible');
                    }
                });
            }
            if (saveCustomNpcBtn) {
                saveCustomNpcBtn.addEventListener('click', saveCustomNpc);
            }
        }

        // 在页面完全加载后绑定栖木设置事件
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPerchSettingsEvents);
        } else {
            initPerchSettingsEvents();
        }

        // 在页面完全加载后绑定爱之迷宫事件
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupLoveMapEvents);
        } else {
            setupLoveMapEvents();
        }

// ================== 栖木设置功能核心 V1.0 ==================

// 打开主设置面板
function openPerchSettingsModal() {
    renderMutedNpcList();
    renderCustomNpcList();
    const perchSettingsModal = document.getElementById('perch-settings-modal');
    if (perchSettingsModal) {
        perchSettingsModal.classList.add('visible');
    }
}

// 渲染被屏蔽的内置NPC列表
function renderMutedNpcList() {
    const container = document.getElementById('mute-npc-list');
    if (!container) return;
    container.innerHTML = '';
    npcProfiles.forEach(npc => {
        const isMuted = mutedNpcs.includes(npc.npcId);
        const item = document.createElement('label');
        item.className = 'flex items-center p-2 rounded hover:bg-white/10 cursor-pointer';
        item.innerHTML = `
            <input type="checkbox" data-npc-id="${npc.npcId}" class="form-checkbox h-4 w-4 mr-3" ${isMuted ? 'checked' : ''}>
            <img src="${npc.avatar}" class="w-6 h-6 rounded-full mr-2">
            <span class="text-sm">${npc.name}</span>
        `;
        container.appendChild(item);
    });
}

// 渲染自定义NPC列表
function renderCustomNpcList() {
    const container = document.getElementById('custom-npc-list-container');
    if (!container) return;
    container.innerHTML = '';
    if (customNpcs.length === 0) {
        container.innerHTML = '<p class="text-xs text-center text-gray-500 py-2">还未添加自定义NPC</p>';
        return;
    }
    customNpcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'flex items-center justify-between p-2 rounded bg-black/20';
        item.innerHTML = `
            <div class="flex items-center gap-2">
                <img src="${npc.avatar}" class="w-6 h-6 rounded-full">
                <span class="text-sm">${npc.name}</span>
            </div>
            <div>
                <button class="text-xs text-blue-400 hover:text-blue-300" onclick="openCustomNpcModal('${npc.npcId}')">编辑</button>
                <button class="text-xs text-red-400 hover:text-red-300 ml-2" onclick="deleteCustomNpc('${npc.npcId}')">删除</button>
            </div>
        `;
        container.appendChild(item);
    });
}

// 打开用于添加或编辑自定义NPC的面板
function openCustomNpcModal(npcId = null) {
    const modal = document.getElementById('perch-custom-npc-modal');
    if (!modal) return;
    
    if (npcId) {
        // 编辑模式
        const npc = customNpcs.find(n => n.npcId === npcId);
        if (!npc) return;
        const titleElement = document.getElementById('custom-npc-modal-title');
        const editingIdElement = document.getElementById('editing-npc-id');
        const nameElement = document.getElementById('custom-npc-name');
        const avatarElement = document.getElementById('custom-npc-avatar');
        const personaElement = document.getElementById('custom-npc-persona');
        const styleElement = document.getElementById('custom-npc-style');
        
        if (titleElement) titleElement.textContent = '编辑NPC';
        if (editingIdElement) editingIdElement.value = npc.npcId;
        if (nameElement) nameElement.value = npc.name;
        if (avatarElement) avatarElement.value = npc.avatar;
        if (personaElement) personaElement.value = npc.persona;
        if (styleElement) styleElement.value = npc.style;
    } else {
        // 添加模式
        const titleElement = document.getElementById('custom-npc-modal-title');
        const editingIdElement = document.getElementById('editing-npc-id');
        const nameElement = document.getElementById('custom-npc-name');
        const avatarElement = document.getElementById('custom-npc-avatar');
        const personaElement = document.getElementById('custom-npc-persona');
        const styleElement = document.getElementById('custom-npc-style');
        
        if (titleElement) titleElement.textContent = '添加新NPC';
        if (editingIdElement) editingIdElement.value = '';
        if (nameElement) nameElement.value = '';
        if (avatarElement) avatarElement.value = '';
        if (personaElement) personaElement.value = '';
        if (styleElement) styleElement.value = '';
    }
    modal.classList.add('visible');
}

// 保存自定义NPC的更改
function saveCustomNpc() {
    const editingIdElement = document.getElementById('editing-npc-id');
    const nameElement = document.getElementById('custom-npc-name');
    const avatarElement = document.getElementById('custom-npc-avatar');
    const personaElement = document.getElementById('custom-npc-persona');
    const styleElement = document.getElementById('custom-npc-style');
    
    if (!editingIdElement || !nameElement || !avatarElement || !personaElement || !styleElement) {
        showMessageBox('表单元素未找到！');
        return;
    }
    
    const npcId = editingIdElement.value;
    const npcData = {
        name: nameElement.value.trim(),
        avatar: avatarElement.value.trim(),
        persona: personaElement.value.trim(),
        style: styleElement.value.trim(),
        // 确保每个NPC都有一个独特的ID
        npcId: npcId || `custom_${Date.now()}`
    };

    if (!npcData.name || !npcData.avatar || !npcData.persona || !npcData.style) {
        showMessageBox('所有字段都不能为空！');
        return;
    }

    if (npcId) {
        // 更新现有的NPC
        const index = customNpcs.findIndex(n => n.npcId === npcId);
        if (index > -1) customNpcs[index] = npcData;
    } else {
        // 添加新的NPC
        customNpcs.push(npcData);
    }

    saveData('custom_npcs', customNpcs);
    renderCustomNpcList();
    const modal = document.getElementById('perch-custom-npc-modal');
    if (modal) {
        modal.classList.remove('visible');
    }
}

// 删除一个自定义NPC
function deleteCustomNpc(npcId) {
    if (confirm('确定要删除这个自定义NPC吗？')) {
        customNpcs = customNpcs.filter(n => n.npcId !== npcId);
        saveData('custom_npcs', customNpcs);
        renderCustomNpcList();
    }
}

// 保存主设置面板的更改（只处理屏蔽列表）
function savePerchSettings() {
    const checkboxes = document.querySelectorAll('#mute-npc-list input[type="checkbox"]');
    mutedNpcs = [];
    checkboxes.forEach(cb => {
        if (cb.checked) {
            mutedNpcs.push(cb.dataset.npcId);
        }
    });
    saveData('muted_npcs', mutedNpcs);
    showMessageBox('设置已保存！');
    const perchSettingsModal = document.getElementById('perch-settings-modal');
    if (perchSettingsModal) {
        perchSettingsModal.classList.remove('visible');
    }
}
// ==========================================================

    </script>

    <!-- 栖木通知模态框 -->
    <div id="perch-notification-modal" class="modal-overlay">
        <div class="modal-content w-[95%] max-w-[460px] flex flex-col max-h-[80vh]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-xl font-bold">通知中心</h3>
                <button id="close-perch-notification-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="perch-notification-list" class="flex-1 overflow-y-auto space-y-2">
            </div>
        </div>
    </div>

    <div id="gift-shop-modal" class="modal-overlay">
        <div class="modal-content w-[95%] max-w-[460px] flex flex-col max-h-[80vh]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-xl font-bold">情感礼品屋</h3>
                <button id="close-gift-shop-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">×</button>
            </div>
            <div id="gift-grid-container" class="flex-1 overflow-y-auto grid grid-cols-2 gap-4 p-1">
                </div>
        </div>
    </div>

    <div id="gift-confirm-modal" class="modal-overlay">
        <div class="modal-content w-[90%] max-w-[420px]">
            <h3 id="gift-confirm-title" class="text-xl font-bold text-center mb-4">赠送礼物</h3>
            <div id="gift-confirm-details" class="text-center mb-6">
                </div>
            <div class="mb-4">
                <textarea id="gift-message-input" class="form-textarea w-full h-20 resize-none" placeholder="想对TA说的话...(可选)"></textarea>
            </div>
            <div class="flex justify-around">
                <button id="cancel-buy-gift-btn" class="px-6 py-2 rounded-lg">再想想</button>
                <button id="confirm-buy-gift-btn" class="px-6 py-2 bg-blue-600 text-white rounded-lg">确认赠送</button>
            </div>
        </div>
    </div>

    <div id="love-map-modal" class="modal-overlay hidden">
        <div class="modal-content w-[95%] max-w-[390px] h-[90vh] flex flex-col p-2 bg-black/95 backdrop-blur-xl border border-pink-400/50">
            <div class="flex justify-between items-center p-2 border-b border-pink-400/30 flex-shrink-0">
                <button id="reset-love-map-btn" class="text-xl text-pink-400/80 hover:text-pink-300 transition-colors" title="新开一局">
                    <i class="ri-refresh-line"></i>
                </button>
                <h3 id="love-map-turn-indicator" class="text-lg font-bold text-pink-300">轮到你了</h3>
                <button id="close-love-map-btn" class="text-2xl text-pink-400/80 hover:text-pink-300">×</button>
            </div>

            <div class="flex-grow flex items-center justify-center p-2 my-2 relative overflow-hidden">
                <div id="love-map-board" class="w-full h-full max-w-full max-h-full">
                    </div>
            </div>

            <div class="flex items-center justify-around p-2 border-t border-pink-400/30 flex-shrink-0">
                <div id="love-map-dice" class="w-12 h-12 bg-black border-2 border-pink-400 rounded-lg flex items-center justify-center text-2xl font-bold text-pink-300 shadow-lg shadow-pink-500/20">?</div>
                
                <button id="roll-love-map-dice-btn" class="px-4 py-2 bg-pink-600 hover:bg-pink-500 text-black font-semibold text-sm rounded-lg shadow-md shadow-pink-500/30 transition-all transform hover:scale-105">掷骰子</button>
                
                <button id="quit-love-map-btn" class="px-4 py-2 bg-pink-700 hover:bg-pink-600 text-pink-100 font-semibold text-sm rounded-lg shadow-md shadow-pink-500/30 transition-all transform hover:scale-105">结束旅程</button>
            </div>
        </div>
    </div>

    <div id="recalled-message-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="recalled-modal-title">心声一瞥</h3>
            <div>
                <h4 class="recalled-section-header">TA 撤回了...</h4>
                <p id="recalled-original-content" class="whitespace-pre-wrap"></p>
                
                <h4 class="recalled-section-header">撤回时想的是...</h4>
                <p id="recalled-reason" class="whitespace-pre-wrap"></p>

                <div class="recalled-modal-footer">
                    <button id="delete-recalled-message-btn" class="delete-recalled-btn">
                        <i class="ri-delete-bin-line"></i> 删除此条提醒
                    </button>
                </div>
            </div>
            <button id="close-recalled-modal" class="absolute top-3 right-3 text-2xl text-gray-400 hover:text-white">×</button>
        </div>
    </div>

    <div id="chat-capsule-manager-modal" class="modal-overlay">
        <div class="modal-content w-[95%] max-w-[480px] flex flex-col max-h-[85vh]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-xl font-bold">记录胶囊</h3>
                <button onclick="document.getElementById(&#39;chat-capsule-manager-modal&#39;).classList.remove(&#39;visible&#39;)" class="text-2xl p-1 rounded-full hover:bg-white/20">×</button>
            </div>
            
            <div class="mb-3">
                <input type="text" id="capsule-title-input" class="form-input w-full text-sm" placeholder="为这段记录添加标题 (可选)...">
            </div>

            <button id="save-current-chat-btn" class="w-full px-4 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-md font-medium transition-colors duration-200 mb-4">
                <i class="ri-capsule-line mr-2"></i>封存当前对话
            </button>

            <div id="capsule-manager-list" class="flex-1 overflow-y-auto space-y-2 border-t border-gray-700 pt-2">
                </div>
        </div>
    </div>

    <!-- 剧本设置弹窗 -->
    <div id="scenario-settings-modal" class="modal-overlay">
        <div class="modal-content w-[95%] max-w-[480px] flex flex-col max-h-[85vh]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-xl font-bold">剧本设置</h3>
                <button id="close-scenario-settings-modal" class="text-2xl p-1 rounded-full hover:bg-white/20">×</button>
            </div>
            <div class="flex-1 overflow-y-auto space-y-4">

                <div>
                    <label class="block text-sm font-medium mb-2">AI回复长度 (字数)</label>
                    <input type="number" id="scenario-word-count-input" class="form-input w-full" placeholder="例如: 200">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">自定义文风库 (选填)</label>
                    <textarea id="scenario-custom-style-input" class="form-textarea w-full h-32 resize-none" placeholder="例如：[村上春树风格]: 营造都市的孤独感..."></textarea>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-700 flex justify-end">
                <button id="save-scenario-settings-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg">保存设置</button>
            </div>
        </div>
    </div>

    <script>
        // 初始化时检测所有现有的多行消息
        function detectMultilineMessages() {
            const messageWrappers = document.querySelectorAll('.chat-message-wrapper');
            messageWrappers.forEach(wrapper => {
                const bubble = wrapper.querySelector('.chat-message');
                if (bubble && !bubble.classList.contains('image-message') && !bubble.classList.contains('sticker-message')) {
                    // 获取气泡的实际渲染高度
                    const bubbleHeight = bubble.offsetHeight;
                    const lineHeight = parseFloat(window.getComputedStyle(bubble).lineHeight) || 24;
                    
                    // 如果高度超过1.5倍行高，认为是多行内容
                    if (bubbleHeight > lineHeight * 1.5) {
                        wrapper.classList.add('has-multiline');
                    }
                }
            });

            // ====== 【新增】剧场主题自定义功能 ======
            const themeBtn = document.getElementById('scenario-theme-btn');
            const themeModal = document.getElementById('scenario-theme-modal');
            const closeThemeModal = document.getElementById('close-theme-modal');
            const applyThemeBtn = document.getElementById('apply-theme-btn');
            const resetThemeBtn = document.getElementById('reset-theme-btn');
            
            // 背景图片相关元素
            const bgImageInput = document.getElementById('bg-image-input');
            const bgImageBtn = document.getElementById('bg-image-btn');
            const bgImageName = document.getElementById('bg-image-name');
            const bgOpacitySlider = document.getElementById('bg-opacity-slider');
            const bgOpacityValue = document.getElementById('bg-opacity-value');
            const bgBlurSlider = document.getElementById('bg-blur-slider');
            const bgBlurValue = document.getElementById('bg-blur-value');
            const removeBgBtn = document.getElementById('remove-bg-btn');
            const previewBgBtn = document.getElementById('preview-bg-btn');

            // 打开主题设置面板
            if (themeBtn) {
                themeBtn.addEventListener('click', () => {
                    // 加载当前保存的主题设置
                    loadSavedTheme();
                    themeModal.classList.add('visible');
                });
            }

            // 关闭主题设置面板
            if (closeThemeModal) {
                closeThemeModal.addEventListener('click', () => {
                    themeModal.classList.remove('visible');
                });
            }

            // 点击模态框外部关闭
            if (themeModal) {
                themeModal.addEventListener('click', (e) => {
                    if (e.target === themeModal) {
                        themeModal.classList.remove('visible');
                    }
                });
            }

            // 应用主题设置
            if (applyThemeBtn) {
                applyThemeBtn.addEventListener('click', () => {
                    applyThemeSettings();
                    themeModal.classList.remove('visible');
                    showMessageBox('主题设置已应用');
                });
            }

            // 重置为默认主题
            if (resetThemeBtn) {
                resetThemeBtn.addEventListener('click', () => {
                    resetToDefaultTheme();
                    showMessageBox('已重置为默认主题');
                });
            }

            // 背景图片功能
            if (bgImageBtn && bgImageInput) {
                bgImageBtn.addEventListener('click', () => {
                    bgImageInput.click();
                });

                bgImageInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        if (file.size > 10 * 1024 * 1024) { // 10MB限制
                            showMessageBox('图片文件大小不能超过10MB');
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const imageData = e.target.result;
                            localStorage.setItem('scenario-bg-image', imageData);
                            bgImageName.textContent = file.name;
                            updateBackgroundImage();
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }

            // 透明度滑块
            if (bgOpacitySlider && bgOpacityValue) {
                bgOpacitySlider.addEventListener('input', (e) => {
                    const value = e.target.value;
                    bgOpacityValue.textContent = value + '%';
                    const opacity = value / 100;
                    document.documentElement.style.setProperty('--scenario-bg-opacity', opacity);
                });
            }

            // 模糊滑块
            if (bgBlurSlider && bgBlurValue) {
                bgBlurSlider.addEventListener('input', (e) => {
                    const value = e.target.value;
                    bgBlurValue.textContent = value + 'px';
                    document.documentElement.style.setProperty('--scenario-bg-blur', value + 'px');
                });
            }

            // 移除背景按钮
            if (removeBgBtn) {
                removeBgBtn.addEventListener('click', () => {
                    localStorage.removeItem('scenario-bg-image');
                    document.documentElement.style.setProperty('--scenario-bg-image', 'none');
                    bgImageName.textContent = '未选择图片';
                    bgImageInput.value = '';
                    
                    const theaterScreen = document.getElementById('theater-screen');
                    if (theaterScreen) {
                        theaterScreen.classList.remove('has-bg-image');
                    }
                    
                    showMessageBox('背景图片已移除');
                });
            }

            // 预览效果按钮
            if (previewBgBtn) {
                previewBgBtn.addEventListener('click', () => {
                    updateBackgroundImage();
                    showMessageBox('背景效果已更新');
                });
            }

            // 更新背景图片
            function updateBackgroundImage() {
                const imageData = localStorage.getItem('scenario-bg-image');
                const theaterScreen = document.getElementById('theater-screen');
                
                if (imageData) {
                    document.documentElement.style.setProperty('--scenario-bg-image', `url("${imageData}")`);
                    if (theaterScreen) {
                        theaterScreen.classList.add('has-bg-image');
                    }
                } else {
                    document.documentElement.style.setProperty('--scenario-bg-image', 'none');
                    if (theaterScreen) {
                        theaterScreen.classList.remove('has-bg-image');
                    }
                }
                
                // 强制重新渲染
                if (theaterScreen) {
                    theaterScreen.style.display = 'none';
                    theaterScreen.offsetHeight; // 触发重绘
                    theaterScreen.style.display = '';
                }
            }

            // 加载保存的主题设置
            function loadSavedTheme() {
                const savedTheme = loadData('scenarioTheme') || {};
                
                document.getElementById('bg-color-picker').value = savedTheme.bgColor || '#4d3a2a';
                document.getElementById('header-color-picker').value = savedTheme.headerColor || '#4d3a2a';
                document.getElementById('title-text-color-picker').value = savedTheme.titleColor || '#f5f2ed';
                document.getElementById('content-text-color-picker').value = savedTheme.contentColor || '#3e2723';
                document.getElementById('content-bg-color-picker').value = savedTheme.contentBgColor || '#f5f2ed';
                document.getElementById('input-border-color-picker').value = savedTheme.inputBorderColor || '#8b6559';
                document.getElementById('refresh-btn-color-picker').value = savedTheme.refreshBtnColor || '#8b6559';
                document.getElementById('send-btn-color-picker').value = savedTheme.sendBtnColor || '#6d4c41';
                document.getElementById('send-btn-border-color-picker').value = savedTheme.sendBtnBorderColor || '#5d4037';
                
                // 加载背景图片设置
                const imageData = localStorage.getItem('scenario-bg-image');
                if (imageData) {
                    bgImageName.textContent = '已设置背景图片';
                } else {
                    bgImageName.textContent = '未选择图片';
                }
                
                bgOpacitySlider.value = savedTheme.bgOpacity || 70;
                bgOpacityValue.textContent = (savedTheme.bgOpacity || 70) + '%';
                bgBlurSlider.value = savedTheme.bgBlur || 2;
                bgBlurValue.textContent = (savedTheme.bgBlur || 2) + 'px';
            }

            // 应用主题设置
            function applyThemeSettings() {
                const themeSettings = {
                    bgColor: document.getElementById('bg-color-picker').value,
                    headerColor: document.getElementById('header-color-picker').value,
                    titleColor: document.getElementById('title-text-color-picker').value,
                    contentColor: document.getElementById('content-text-color-picker').value,
                    contentBgColor: document.getElementById('content-bg-color-picker').value,
                    inputBorderColor: document.getElementById('input-border-color-picker').value,
                    refreshBtnColor: document.getElementById('refresh-btn-color-picker').value,
                    sendBtnColor: document.getElementById('send-btn-color-picker').value,
                    sendBtnBorderColor: document.getElementById('send-btn-border-color-picker').value,
                    bgOpacity: bgOpacitySlider.value,
                    bgBlur: bgBlurSlider.value,
                };

                // 保存设置到本地存储
                saveData('scenarioTheme', themeSettings);

                // 应用CSS变量
                const root = document.documentElement;
                root.style.setProperty('--scenario-bg-color', themeSettings.bgColor);
                root.style.setProperty('--scenario-header-color', themeSettings.headerColor);
                root.style.setProperty('--scenario-title-color', themeSettings.titleColor);
                root.style.setProperty('--scenario-content-color', themeSettings.contentColor);
                root.style.setProperty('--scenario-content-bg-color', themeSettings.contentBgColor);
                root.style.setProperty('--scenario-input-border-color', themeSettings.inputBorderColor);
                root.style.setProperty('--scenario-refresh-btn-color', themeSettings.refreshBtnColor);
                root.style.setProperty('--scenario-send-btn-color', themeSettings.sendBtnColor);
                root.style.setProperty('--scenario-send-btn-border-color', themeSettings.sendBtnBorderColor);
                root.style.setProperty('--scenario-bg-opacity', themeSettings.bgOpacity / 100);
                root.style.setProperty('--scenario-bg-blur', themeSettings.bgBlur + 'px');
                
                // 应用背景图片
                updateBackgroundImage();
            }

            // 重置为默认主题
            function resetToDefaultTheme() {
                const defaultTheme = {
                    bgColor: '#4d3a2a',
                    headerColor: '#4d3a2a',
                    titleColor: '#f5f2ed',
                    contentColor: '#3e2723',
                    contentBgColor: '#f5f2ed',
                    inputBorderColor: '#8b6559',
                    refreshBtnColor: '#8b6559',
                    sendBtnColor: '#6d4c41',
                    sendBtnBorderColor: '#5d4037',
                    bgOpacity: 70,
                    bgBlur: 2,
                };

                // 更新颜色选择器
                document.getElementById('bg-color-picker').value = defaultTheme.bgColor;
                document.getElementById('header-color-picker').value = defaultTheme.headerColor;
                document.getElementById('title-text-color-picker').value = defaultTheme.titleColor;
                document.getElementById('content-text-color-picker').value = defaultTheme.contentColor;
                document.getElementById('content-bg-color-picker').value = defaultTheme.contentBgColor;
                document.getElementById('input-border-color-picker').value = defaultTheme.inputBorderColor;
                document.getElementById('refresh-btn-color-picker').value = defaultTheme.refreshBtnColor;
                document.getElementById('send-btn-color-picker').value = defaultTheme.sendBtnColor;
                document.getElementById('send-btn-border-color-picker').value = defaultTheme.sendBtnBorderColor;

                // 重置背景图片设置
                bgOpacitySlider.value = defaultTheme.bgOpacity;
                bgOpacityValue.textContent = defaultTheme.bgOpacity + '%';
                bgBlurSlider.value = defaultTheme.bgBlur;
                bgBlurValue.textContent = defaultTheme.bgBlur + 'px';
                
                // 移除背景图片
                localStorage.removeItem('scenario-bg-image');
                bgImageName.textContent = '未选择图片';
                bgImageInput.value = '';
                
                const theaterScreen = document.getElementById('theater-screen');
                if (theaterScreen) {
                    theaterScreen.classList.remove('has-bg-image');
                }

                // 应用默认主题
                saveData('scenarioTheme', defaultTheme);
                
                // 应用CSS变量
                const root = document.documentElement;
                root.style.setProperty('--scenario-bg-color', defaultTheme.bgColor);
                root.style.setProperty('--scenario-header-color', defaultTheme.headerColor);
                root.style.setProperty('--scenario-title-color', defaultTheme.titleColor);
                root.style.setProperty('--scenario-content-color', defaultTheme.contentColor);
                root.style.setProperty('--scenario-content-bg-color', defaultTheme.contentBgColor);
                root.style.setProperty('--scenario-input-border-color', defaultTheme.inputBorderColor);
                root.style.setProperty('--scenario-refresh-btn-color', defaultTheme.refreshBtnColor);
                root.style.setProperty('--scenario-send-btn-color', defaultTheme.sendBtnColor);
                root.style.setProperty('--scenario-send-btn-border-color', defaultTheme.sendBtnBorderColor);
                root.style.setProperty('--scenario-bg-opacity', defaultTheme.bgOpacity / 100);
                root.style.setProperty('--scenario-bg-blur', defaultTheme.bgBlur + 'px');
                root.style.setProperty('--scenario-bg-image', 'none');
            }

            // 页面加载时应用保存的主题
            const savedTheme = loadData('scenarioTheme');
            if (savedTheme) {
                const root = document.documentElement;
                root.style.setProperty('--scenario-bg-color', savedTheme.bgColor);
                root.style.setProperty('--scenario-header-color', savedTheme.headerColor);
                root.style.setProperty('--scenario-title-color', savedTheme.titleColor);
                root.style.setProperty('--scenario-content-color', savedTheme.contentColor);
                if (savedTheme.contentBgColor) {
                    root.style.setProperty('--scenario-content-bg-color', savedTheme.contentBgColor);
                }
                root.style.setProperty('--scenario-input-border-color', savedTheme.inputBorderColor);
                root.style.setProperty('--scenario-refresh-btn-color', savedTheme.refreshBtnColor);
                root.style.setProperty('--scenario-send-btn-color', savedTheme.sendBtnColor);
                root.style.setProperty('--scenario-send-btn-border-color', savedTheme.sendBtnBorderColor);
                
                // 应用背景图片设置
                if (savedTheme.bgOpacity) {
                    root.style.setProperty('--scenario-bg-opacity', savedTheme.bgOpacity / 100);
                }
                if (savedTheme.bgBlur) {
                    root.style.setProperty('--scenario-bg-blur', savedTheme.bgBlur + 'px');
                }
            }
            
            // 延迟应用背景图片，确保DOM完全加载
            setTimeout(() => {
                updateBackgroundImage();
            }, 100);
        }

        // 页面加载完成后检测现有消息
        setTimeout(detectMultilineMessages, 100);

    </script>

        






</body></html>
